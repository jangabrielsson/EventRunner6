{"initialProperties":{"typeTemplateInitialized":true,"useUiView":true,"buildNumber":1,"userDescription":"","supportedDeviceRoles":["Light","Drencher","Pin","NightLamp","Kettle","Bracket","AirConditioner","AlarmAlarm","Coffee","GardenLamp","TvSet","CeilingFan","Toaster","Radio","RoofWindow","Other","AlarmState","AlarmArm","VideoGateBell","VideoGateOpen","Valve","Fan"],"uiView":{},"quickAppVariables":{},"deviceRole":"Light","apiVersion":"1.3","useEmbededView":true,"uiCallbacks":{},"viewLayout":{"$jason":{"head":{"title":"quickApp_device_57"},"body":{"header":{"title":"quickApp_device_57","style":{"height":"0"}},"sections":{"items":{}}}}}},"files":[{"isMain":false,"isOpen":false,"name":"builtin","type":"lua","content":"fibaro.EventRunner = fibaro.EventRunner or { debugFlags = {} }\nlocal ER = fibaro.EventRunner\nlocal debugFlags = ER.debugFlags\n\nlocal args = {}\nlocal builtin = {}\nER.builtin = builtin\n\nfunction builtin.log(fm,...) if #{...} == 0 then if fm==nil then print() else print(fm) end else print(string.format(fm,...)) end end\n\nfunction builtin.post(ev,time) return ER._er.post(ev,time) end\nfunction builtin.cancel(ref) return ER._er.cancel(ref) end\nfunction builtin.fmt(...) return string.format(...) end\nfunction builtin.HM(t) return os.date(\"%H:%M\",t < os.time()-8760*3600 and t+ER.midnight() or t) end\nfunction builtin.HMS(t) return os.date(\"%H:%M\",t < os.time()-8760*3600 and t+ER.midnight() or t) end\nfunction builtin.sign(t) return t < 0 and -1 or 1 end\nfunction builtin.rnd(min,max) return math.random(min,max)end\nfunction builtin.round(num) return math.floor(num+0.5) end\nfunction builtin.sum(...) \n  local args = {...}\n  if #args == 1 and type(args[1]) == \"table\" then args = args[1] end\n  local s = 0 for i=1,#arg do s = s + arg[i] end\n  return s\nend\nfunction builtin.average(...) local s = builtin.sum(...) return s / select(\"#\", ...) end\nfunction builtin.size(t) return #t end\nfunction builtin.min(...) \n  local args = {...}\n  if #args == 1 and type(args[1]) == \"table\" then args = args[1] end\n  return math.min(table.unpack(args))\nend\nfunction builtin.max(...) \n  local args = {...}\n  if #args == 1 and type(args[1]) == \"table\" then args = args[1] end\n  return math.max(table.unpack(args))\nend\nfunction builtin.sort(t) table.sort(t) return t end\nfunction builtin.osdate(t) return os.date(t) end\nfunction builtin.ostime(t) return os.time(t) end\n\nfunction builtin.global(name)\n  local s = fibaro.getGlobalVariable(name)     \n  api.post(\"/globalVariables/\",{name=name})\n   return s == nil\nend\n\nfunction builtin.listglobals() return api.get(\"/globalVariables\") end\nfunction builtin.deleteglobal(name) api.delete(\"/globalVariables/\"..name) end\n\nfunction builtin.subscribe(event) end\nfunction builtin.publish(event) end\nfunction builtin.remote(deviceId,event) end\nfunction builtin.adde(t,v) table.insert(t,v) return t end\nfunction builtin.remove(t,v) \n  for i=#t,1,-1 do if t[i]==v then table.remove(t,i) end end \n  return t\nend\n\nfunction builtin.enable(rule) end\nfunction builtin.disable(rule) end\n\nfunction builtin.once() end\nfunction builtin.trueFor() end\nfunction builtin.again() end\n\n\n\n"},{"isMain":false,"isOpen":false,"name":"parser","type":"lua","content":"\nfibaro.EventRunner = fibaro.EventRunner or { debugFlags = {} }\nlocal ER = fibaro.EventRunner \nlocal debugFlags = ER.debugFlags\n\nlocal fmt = string.format\nlocal patterns = {}\n\nER._opers = {\n  ['%neg']={op=false, prio=14, unop=true, trans='neg'},        -- unary minus\n  ['t/']  ={op=true,  prio=14, unop=true, trans='today'},      -- today time constant, t/10:00\n  ['n/']  ={op=true,  prio=14, unop=true, trans='next'},       -- next today time constant, n/10:00\n  ['+/']  ={op=true,  prio=14, unop=true, trans='plus'},       -- from today time constant, +/10:00\n  ['$']   ={op=true,  prio=14, unop=true, trans='gv'},         -- global variable, $var\n  ['$$']  ={op=true,  prio=14, unop=true, trans='qv'},         -- quickApp variable, $var\n  ['$$$']  ={op=true,  prio=14,unop=true, trans='pv'},         -- Persistent variable, $var\n  ['..']  ={op=true,  prio=9,             trans='betw'},       -- between operator, 10:00..11:00\n  ['...'] ={op=true,  prio=9,             trans='betwo'},  \n  ['@']   ={op=true,  prio=9,  unop=true, trans='daily'},      -- day rule, @10:00\n  ['@@']  ={op=true,  prio=9,  unop=true, trans='interv'},     -- interval rule, @@00:05\n  ['+']   ={op=true, prio=11,             trans='add'},\n  ['-']   ={op=true, prio=11,             trans='sub'},\n  ['*']   ={op=true, prio=12,             trans='mul'},\n  ['/']   ={op=true, prio=12,             trans='div'},\n  ['++']  ={op=true, prio=10,             trans='conc'},         -- string concatenation\n  ['==='] ={op=true, prio=9,              trans='match'},        -- string match\n  ['%']   ={op=true, prio=12,             trans='mod'},          -- modulo\n  ['^']   ={op=true, prio=12,             trans='pow'},          -- power\n  ['==']  ={op=true, prio=6,              trans='eq'},           -- equal\n  ['<=']  ={op=true, prio=6,              trans='lte'},\n  ['>=']  ={op=true, prio=6,              trans='gte'},\n  ['~=']  ={op=true, prio=6,              trans='neq'},          -- not equal\n  ['>']   ={op=true, prio=6,              trans='gt'},\n  ['<']   ={op=true, prio=6,              trans='lt'},\n  ['&']   ={op=true, prio=5,              trans='and'},        -- logical and\n  ['|']   ={op=true, prio=4,              trans='or'},         -- logical or\n  ['!']   ={op=true, prio=5.1, unop=true, trans='not'},        -- logical not\n  ['in']  ={op=true, prio=0.1,            trans='in'},\n  ['=']   ={op=true, prio=0,              trans='assign'},       -- assignment\n}\nlocal keyword={\n  ['if']='t_if',['then']='t_then',['else']='t_else',['elseif']='t_elseif',['end']='t_end',['while']='t_while',\n  ['repeat']='t_repeat',['do']='t_do',['until']='t_until',['return']='t_return',['for']='t_for',['function']='t_function',\n  ['local']='t_local',['break']='t_break',\n  ['+=']='t_addinc',['-=']='t_subinc',['*=']='t_mulinc',['/=']='t_divinc',\n  ['=>']='t_rule',\n  ['true']='t_true',['false']='t_false',['nil']='t_nil',\n  [';'] = 't_semi',[',']='t_comma',['.']='t_dot',[':']='t_ddot',\n  [')'] = 't_rpar',['(']='t_lpar',['}']='t_rcur',['{']='t_lcur',['[']='t_lbra',[']']='t_rbra',\n}\nlocal opers0 = ER._opers\nlocal opers1 = {} for k,v in pairs(opers0) do opers1[v.trans] = v end\nER._opers1 = opers1\n\nlocal TKMT = {__tostring = function (err) \n    if type(err) == 'string' then return err end\n    local src = err.src or \"\"\n    local ptr = string.rep(' ',err.from-1)..string.rep('^',err.to-err.from+1)\n    return fmt(\"%s: %s at pos %d\\n%s\\n%s\\n\",err.type,err.msg,err.from,src,ptr)\nend}\n\nlocal function createError(typ,msg,from,to,src,mt)\n  return setmetatable({type=typ, msg=msg, from=from, to=to, src=src},mt or TKMT)\nend\nlocal function perror(typ,msg,from,to,src,mt) error(createError(typ,msg,from,to,src,mt)) end\nER.createParseError = createError\nER.perror = perror\n\nlocal function stream(tab,src)\n  local p,self=0,{ stream=tab, eof={type='t_eof', value='', dbg={from=tab[#tab].dbg.from, to=tab[#tab].dbg.to}} }\n  self.src = src\n  function self.next() p=p+1 local r = p<=#tab and tab[p] or self.eof; return r end\n  function self.last() return tab[p] or self.eof end\n  function self.prev() return tab[p-1] or self.eof end\n  function self.matchp(t,v) \n    local t2 = self.peek()\n    if t2[t]==v then self.next() return t2 end \n  end\n  function self.pushBack() p=p-1 end\n  function self.matchpt(v) return self.matchp('type',v) end\n  function self.match(t,v,m)\n    local r = self.matchp(t,v)\n    if r then return r end\n    if self.error then self.error(self,self.peek(),m or fmt('expected %s (got %s)',v,self.peek().type)) end\n    error(m or fmt('expected %s (got %s)',v,self.peek()[t]),2) \n  end \n  function self.matcht(v,m) return self.match('type',v,m) end \n  function self.peek(n) return tab[p+(n or 1)] or self.eof end\n  function self.containsOp(op) for _,t in ipairs(tab) do if t.opval == op then return true end end end\n  function self.containsType(typ) for _,t in ipairs(tab) do if t.type == typ then return true end end end\n  function self.dump(env) \n    local pr = env and env.print or print \n    for _,t in ipairs(tab) do pr(json.encode(t)) end \n  end\n  return self\nend\n\nlocal function toTimeDate(str)\n  local y,m,d,h,min,s=str:match(\"(%d?%d?%d?%d?)/?(%d+)/(%d+)/(%d%d):(%d%d):?(%d?%d?)\")\n  local t = os.date(\"*t\")\n  return os.time{year=y~=\"\" and y or t.year,month=m,day=d,hour=h,min=min,sec=s~=\"\" and s or 0}\nend\nlocal function toTime(str)\n  local h,m,s = str:match(\"(%d%d):(%d%d):?%d*\")\n  return 3600*h+60*m+(s and s~=\"\" and s or 0)\nend\n\nlocal tokenMetatable = {\n  __tostring = function (t) return fmt(\"%s:%s/%s/%s\",t.type,t.value or t.opval,t.dbg.from,t.dbg.to) end\n}\n\nlocal function token(prefix, pattern, createFn)\n  pattern = \"^(\" .. pattern .. \")\"\n  local function fn(ctx)\n    local sta, len, res, group = string.find(ctx.source, pattern)\n    if len then\n      if createFn then\n        ctx.to = ctx.cursor + len\n        ctx.from = ctx.cursor + sta\n        local tokenv,t2,len2 = createFn(group or res, ctx.source)\n        if tokenv == '%break' then return end\n        if tokenv == '%extend%' then\n          tokenv = t2\n          len = len2\n        end\n        tokenv.dbg = {from=ctx.cursor+1, to=ctx.cursor+len}\n        table.insert(ctx.tokens, tokenv)\n        setmetatable(tokenv, tokenMetatable)\n      end\n      ctx.source = string.sub(ctx.source, len+1)\n      ctx.cursor = ctx.cursor + len\n      return true\n    end\n  end\n  for c in prefix:gmatch\".\" do\n    patterns[c] = patterns[c] or {}\n    table.insert(patterns[c], fn)\n  end\nend\n\nlocal function trans(op) return opers0[op] and opers0[op].trans or op end\n\nlocal function tknError(msg) error(msg) end\ntoken(\" \\t\\n\\r\",\"[%s%c]+\")\n--2019/3/30/20:30\ntoken(\"/0123456789\",\"%d?%d?%d?%d?/?%d+/%d+/%d%d:%d%d:?%d?%d?\",function (t) return {type=\"num\", const=true, value=toTimeDate(t)} end)\ntoken(\"0123456789\",\"%d+:%d+\",function (w) if #w>5 then tknError('Bad time constant '..w) else return \"%break\" end end)\ntoken(\"0123456789\",\"%d%d:%d%d:?%d?%d?\",function (t) return {type='num', const=true, value=toTime(t)} end)\ntoken(\"t+n\",\"[t+n][/]\", function (op) return {type=\"op\", opval=trans(op)} end)\ntoken(\"#\",\"#[A-Za-z_][%w_%-]*\",function (w) return {type=\"event\", value=w:sub(2)} end)\ntoken(\"$\",\"%$+[_0-9a-zA-Z\\xC3\\xA5\\xA4\\xB6\\x85\\x84\\x96]*\",\nfunction (w) return {type='t_name', value=w} end)\ntoken(\"_abcdefghijklmnopqrstuvwxyzåäöABCDEFGHIJKLMNOPQRSTUVWXYZÅÄÖ\\xC3\\xA5\\xA4\\xB6\\x85\\x84\\x96\",\"[_a-zA-Z\\xC3\\xA5\\xA4\\xB6\\x85\\x84\\x96][_0-9a-zA-Z\\xC3\\xA5\\xA4\\xB6\\x85\\x84\\x96]*\", \nfunction (w) return opers0[w] and {type='op', opval=trans(w)} or keyword[w] and {type=keyword[w], keyw=true} or {type='t_name', value=w} end)\ntoken(\"0123456789\",\"%d+%.%d+\", function (d) return {type=\"num\", const=true, value=tonumber(d)} end)\ntoken(\"0123456789\",\"%d+\", function (d) return {type=\"num\", const=true, value=tonumber(d)} end)\nlocal cmap = {['n']='\\n',['r']='\\r',['t']='\\t'}\nlocal function getString(s,e)\n  local i,n = 2,s:len()\n  local r = {}\n  while i <= n do\n    local c = s:sub(i,i)\n    if c == '\\\\' then\n      i = i + 1\n      c = s:sub(i,i)\n      r[#r+1]=cmap[c] or c\n    elseif c == e then\n      return table.concat(r),i\n    else r[#r+1]=c end\n    i=i+1\n  end\nend\ntoken('\"','\"', function (s,src)\n  local str,i = getString(src,'\"')\n  if not str then tknError('unfinished string starting with \"...') end\n  return '%extend%', {type=\"str\", const=true, value=str}, i\nend)\ntoken(\"'\",\"'\", function (s,src)\n  local str,i = getString(src,\"'\")\n  if not str then tknError(\"unfinished string starting with '...\") end\n  return '%extend%', {type=\"str\", const=true, value=str}, i\nend)\ntoken(\"-\",\"%-%-.-\\n\")\ntoken(\"-\",\"%-%-.*\")\ntoken(\"=\",\"===\",function (op) return {type=\"op\", opval=trans(op)} end)    \ntoken(\".\",\"%.%.%.\",function (op) return {type=\"t_name\", value='...'} end)\ntoken(\".\",\"%.%.\",function (op) return {type=\"op\", opval=trans('..')} end)\ntoken(\"$\",\"%$%$%$?\", function (op) return {type=\"op\", opval=trans(op)} end)\ntoken(\"@$=<>!+-*&|/^~:\",\"[@%$=<>!+%-*&|/%^~;:][%+@=<>&|:%.]?\", \nfunction (w) return \n  keyword[w] and {type=keyword[w], keyw=true} or \n  opers0[w] and {type='op', opval=trans(w)} \n  or tknError(\"Bad token '\"..w..\"'\") end)\ntoken(\"{}(),[]#%;.\",\"[%.{}%(%),%[%]#%%;]\", \nfunction (w) return \n  keyword[w] and {type=keyword[w], keyw=true} or \n  opers0[w] and {type='op', opval=trans(w)} \n  or tknError(\"Bad token '\"..w..\"'\") end)\n\nlocal function dispatch(c,ctx) \n  for _,m in ipairs(patterns[c] or {}) do\n    if m(ctx) then return true end\n  end\nend\n\nlocal function tokenize(src)\n  local ctx = { source = src, tokens = {}, cursor = 0 }\n  local stat,res = pcall(function()\n    while #ctx.source>0 and dispatch(ctx.source:sub(1,1),ctx) do end\n    if #ctx.source > 0 then \n      tknError(fmt(\"tokenizer failed at %s in %s\",ctx.source,src))\n    end\n  end)\n  if not stat then\n    perror('Tokenizer',res or \"\",ctx.from,ctx.to,src)\n  end\n  return ctx.tokens\nend\n\nfunction ER.tokenize(str)\n  return stream(tokenize(str),str)\nend\n\n\n----------------------------- Parser ------------------------------------------------------------\n--[[\nchunk ::= block\nblock ::= {stat} [retstat]\nstat ::=  ‘;’ | \nvarlist ‘=’ exprlist | \nfunctioncall | \nlabel |          -- NOT IMPLEMENTED\nbreak | \ngoto Name |      -- NOT IMPLEMENTED\ndo block end | \nwhile exp do block end | \nrepeat block until exp | \nif exp then block {elseif exp then block} [else block] end | \nfor Name ‘=’ exp ‘,’ exp [‘,’ exp] do block end | \nfor namelist in exprlist do block end | \nfunction funcname funcbody | \n  local function Name funcbody | \n    local namelist [‘=’ exprlist] \n    -- start: ;, name, break, do, while, repeat, if, for, function, local\n    \n    retstat ::= return [exprlist] [‘;’]\n    label ::= ‘::’ Name ‘::’\n    funcname ::= Name {‘.’ Name} [‘:’ Name]\n    varlist ::= var {‘,’ var}\n    var ::=  Name | prefixexp ‘[’ exp ‘]’ | prefixexp ‘.’ Name \n    namelist ::= Name {‘,’ Name}\n    exprlist ::= exp {‘,’ exp}\n    exp ::=  nil | false | true | Numeral | LiteralString | ‘...’ | functiondef | \n    prefixexp | tableconstructor | exp binop exp | unop exp \n    -- start: nil, false, true, num, string, ..., function, name,\n    --        {, (, -, not, #, ~\n    \n    prefixexp ::= var | functioncall | ‘(’ exp ‘)’\n    functioncall ::=  prefixexp args | prefixexp ‘:’ Name args \n    args ::=  ‘(’ [exprlist] ‘)’ | tableconstructor | LiteralString \n    functiondef ::= function funcbody\n      funcbody ::= ‘(’ [parlist] ‘)’ block end\n      parlist ::= namelist [‘,’ ‘...’] | ‘...’\n      tableconstructor ::= ‘{’ [fieldlist] ‘}’ \n      fieldlist ::= field {fieldsep field} [fieldsep]\n      field ::= ‘[’ exp ‘]’ ‘=’ exp | Name ‘=’ exp | exp\n      fieldsep ::= ‘,’ | ‘;’\n      binop ::=  ‘+’ | ‘-’ | ‘*’ | ‘/’ | ‘//’ | ‘^’ | ‘%’ | \n      ‘&’ | ‘~’ | ‘|’ | ‘>>’ | ‘<<’ | ‘..’ | \n      ‘<’ | ‘<=’ | ‘>’ | ‘>=’ | ‘==’ | ‘~=’ | \n      and | or\n      unop ::= ‘-’ | not | ‘#’ | ‘~’\n      \n      -- My rewrite of the rules...\n      afterpref ::= '.' prefixexp\n      afterpref ::= '[' exp ']' afterpref\n      afterpref ::= '(' args ')' afterpref\n      afterpref ::= null\n      \n      prefixexp ::= Name\n      prefixexp ::= Name . prefixexp\n      prefixexp ::= Name [ exp ] [ afterpref ]\n      prefixexp ::= Name ( args ) [ afterpref ]\n      prefixexp ::= Name : Obj ( args ) [ afterpref ]\n      prefixexp ::= ( exp ) [ afterpref ]\n    end\n  end\nend\n¨--]]\n\nfunction ER.Stack()\n  local p,px,st,self=0,0,{},{}\n  function self.push(v) p=p+1 st[p]=v px=p end\n  function self.pushx(v) px=px+1 st[px]=v end\n  function self.getx(i) if px>p then return st[p+i] end end\n  function self.pop(n) n = n or 1; p=p-n; px=p local r= st[p+n] st[p+n]=nil return r end\n  function self.pushMultiRes(res)\n    if #res == 0 then self.push(nil) return end\n    self.push(res[1])\n    for i=2,#res do self.pushx(res[i]) end \n  end\n  function self.popm(n)\n    local pxx = px\n    p = p-n; px = p\n    return table.unpack(st,p+1,pxx)\n  end\n  function self.popmpack(n)\n    p = p-n\n    local res = {table.unpack(st,p+1,px)}\n    px = p\n    return res\n  end\n  function self.peek(n) return st[p-(n or 0)] end\n  function self.size() return p end\n  function self.isEmpty() return p <= 0 end\n  function self.dump(env) \n    local pr = env and env.print or print \n    for i=1,p do pr(string.format(\"S%02d: %s\",i,json.encode(st[i]))) end \n  end\n  function self.clear() p,px,st=0,0,{} end\n  return self\nend\n\nlocal chunk,block,stat,retstat,label,funcname,varlist,var,namelist,exprlist,expr\nlocal prefixexpr,functioncall,args,functiondef,funcbody,parlist,tablevalue\nlocal function mapT(args) local r={} for _,v in ipairs(args) do r[v]=true end return r end\nlocal function copy(t) local r={} for k,v in pairs(t) do r[k]=v end return r end\nlocal function merge(t1,t2) local t0 = copy(t1) for k,v in pairs(t2) do t0[k] = v end return t0 end\nlocal Stack,Opers\nlocal fmt = string.format\n\nlocal _perror,_source\nlocal function perror(msg,tkn)\n  _perror('Parser',msg,tkn.dbg.from,tkn.dbg.to,_source)\nend\n\nlocal function matchError(tkns,t,msg)\n  perror(msg,t)\nend\n\nlocal function mergeDbg(...)\n  local dbg = {...}\n  return {from=dbg[1]._dbg.from,to=dbg[#dbg]._dbg.to}\nend\n\nlocal function Scope()\n  local self,frame = {},{}\n  function self.push() local f = {_next=frame} frame = f end\n  function self.pop() frame=frame._next end\n  function self.setBreak() frame.breaks = true end\n  function self.addLocal(name) frame.locals = frame.locals or {} frame.locals[name] = true end\n  function self.hasBreaks() return frame.breaks end\n  function self.hasLocals(name) return frame.locals end\n  return self\nend\n\nlocal scope = Scope()\nlocal inExpr = false \n\nlocal blockEnd = mapT{'t_return','t_eof'}\nfunction block(tkns,ends) -- OK\n  scope.push()\n  local stats,ends = {},ends or blockEnd\n  local t = tkns.peek()\n  while not (ends[t.type] or t.type=='t_return') do\n    local s = stat(tkns)\n    if s then stats[#stats+1] = s end\n    t = tkns.peek()\n  end\n  if tkns.peek().type == 't_return' then\n    local r = retstat(tkns,ends)\n    if r then stats[#stats+1] = r end\n  end\n  local bs = scope.hasBreaks() or scope.hasLocals()\n  local locals = scope.hasLocals()\n  scope.pop()\n  return {type='block', statements=stats, scope = bs, locals = locals, dbg=t.dbg}\nend\n\nlocal varTypes={[\"\"]='ev',[\"$\"]='gv',[\"$$\"]='qv',[\"$$$\"]='sv'}\nlocal function varType(name) return varTypes[name:match(\"^[%$]*\")] end\n\nlocal doEnd = mapT{'t_end','t_eof'}\nlocal whileEnd = mapT{'t_do','t_eof'}\nlocal untilEnd = mapT{'t_until','t_eof'}\nlocal exprEnd = mapT{'t_semi','t_comma','t_eof','t_if','t_do','t_while','t_repeat','t_return','t_break'}\nlocal thenEnd = mapT{'t_end','t_else','t_elseif','t_eof'}\nlocal endEnd = mapT{'t_end','t_eof'}\nlocal braEnd = merge(mapT{'t_rbra','t_eof'},exprEnd)\nlocal incsMap = mapT{'t_addinc','t_subinc','t_mulinc','t_divinc'}\n\nfunction stat(tkns)\n  local pt = tkns.peek().type\n  if tkns.matchpt('t_semi') then return end\n  \n  if tkns.peek().type == 't_name' then \n    local n = tkns.matcht('t_name')\n    local v = prefixexpr(tkns,{type='name',value=n.value,_dbg=n.dbg,vt=varType(n.value)})\n    if v.type=='call' then \n      return v   -- OK. functioncall\n    elseif incsMap[tkns.peek().type]  then -- OK. var += exp\n      --local v = tkns.matcht('t_name',\"Expected variable name\").value\n      local op = tkns.next()\n      local val = expr(tkns,exprEnd)\n      return {type='incvar',name=v.value,op=op.type:sub(3,-4),value=val,_dbg=op.dbg}\n    elseif v.type=='getprop' and not (tkns.peek().opval=='assign' or tkns.matchpt('t_comma')) then\n      return v\n    else -- OK. varlist ‘=’ exprlist\n      local vl = varlist(tkns,v)\n      local t = tkns.match('opval','assign',\"Expected '=' in assignment\")\n      local e = exprlist(tkns)\n      return {type='assign',vars=vl,exprs=e,_dbg=t.dbg}\n    end\n  end\n  --label |          -- NOT IMPLEMENTED\n  if tkns.matchpt('t_break') then -- OK.\n    scope.setBreak()\n    return {type='break',_dbg=pt.dbg}\n  end\n  -- go to Name |      -- NOT IMPLEMENTED\n  if tkns.matchpt('t_do') then  -- OK. _do_block_end\n    local bl = block(tkns,doEnd)\n    tkns.matcht('t_end',\"Expected END for DO block\")\n    return bl\n  end\n  if tkns.matchpt('t_while') then -- OK. _while_exp_do_block_end\n    local e = expr(tkns,whileEnd)\n    tkns.matcht('t_do',\"Expected DO in WHILE loop\")\n    local b = block(tkns,doEnd)\n    tkns.matcht('t_end',\"Expected END in WHILE loop\")\n    return {type='while',cond=e,body=b,_dbg=pt.dbg}\n  end \n  if tkns.matchpt('t_repeat') then -- OK. _repeat_block_until_exp_\n    local b = block(tkns,untilEnd)\n    tkns.matcht('t_until',\"Expected UNTIL in REPEAT block\")\n    local e = expr(tkns,exprEnd)\n    return {type='rep'..'eat',body=b,cond=e,_dbg=pt.dbg}\n  end\n  \n  if tkns.matchpt('t_if') then -- OK. _if_exp_then_block_{elseif_exp_then_block} [else_block]_end \n    local e = expr(tkns)\n    tkns.matcht('t_then',\"Expected THEN in IF statement\")\n    local b = block(tkns,thenEnd)\n    local ifs = {{cond=e,body=b}}\n    while tkns.matchpt('t_elseif') do\n      local e = expr(tkns,thenEnd)\n      tkns.matcht('t_then',\"Expected THEN in ELSEIF statement\")\n      local b = block(tkns,thenEnd)\n      ifs[#ifs+1] = {cond=e,body=b}\n    end\n    if tkns.matchpt('t_else') then\n      local b = block(tkns,endEnd)\n      ifs[#ifs+1] = {body=b}\n    end\n    tkns.matcht('t_end',\"Expected END in IF statement\")\n    return {type='if', args=ifs,_dbg=pt.dbg}\n  end\n  if tkns.matchpt('t_for') then\n    if tkns.peek(2).opval == 'assign' then -- OK. for Name ‘=’ exp ‘,’ exp [‘,’ exp] do block end\n    local name = tkns.matcht('t_name',\"Expected loop variable name\")\n    local var = {type='name',value=name.value,_dbg=name.dbg,vt=varType(name.value)}\n    tkns.match('opval','assign',\"Expected '=' in FOR loop\")\n    local start = expr(tkns)\n    tkns.matcht('t_comma',\"Expected ',' in FOR loop\")\n    local stop = expr(tkns,{'t_comma','t_do','t_eof'})\n    local step\n    if tkns.matchpt('t_comma') then\n      step = expr(tkns,{'t_comma','t_do','t_eof'})\n    else step = {type='num',value=1,const=true,_dbg=tkns.peek().dbg} end\n    tkns.matcht('t_do',\"Expected DO in FOR loop\")\n    local body = block(tkns,endEnd)\n    tkns.matcht('t_end',\"Expected END in FOR loop\")\n    body.scope = nil -- we always have outer scope for loop var...\n    local d = {type='block',scope=true,statements={\n      {type='assign',vars={var},exprs={start},_dbg=name.dbg},\n      {type='loop',statements={\n        {type='breakif',\n        cond={type='binop',op='gt',exp1=var,exp2=stop,_dbg=name.dbg},\n        _dbg=body._dbg\n      },\n      body,\n      {type='incvar',name=name.value,op='add',value=step,_dbg=step._dbg}\n    }}}}\n    return d\n  else -- for namelist in exprlist do block_end\n    local n = namelist(tkns)\n    tkns.matcht('t_in',\"Expected 'in' in FOR loop\")\n    local e = exprlist(tkns)\n    tkns.matcht('t_do',\"Expected DO in FOR loop\")\n    local b = block(tkns,endEnd)\n    tkns.matcht('t_end',\"Expected END in FOR loop\")\n    return {type='forin',names=n,exp=e,body=b,_dbg=pt.dbg} \n  end\nend\nif tkns.matchpt('t_function') then -- OK. function funcname funcbody\n  local n = funcname(tkns)\n  local b = funcbody(tkns)\n  return {type='functiondef',name=n,fun={type='func'..'tion',params=b.params,body=b.block,_dbg=pt.dbg}}\nend\nif tkns.matchpt('t_local') then\n  if tkns.matchpt('t_function') then -- local function Name funcbody\n    local n = tkns.matcht('t_name',\"Expected FUNCTION name\")\n    scope.addLocal(n.value)\n    local b = funcbody(tkns)\n    return {type='localfunction',name=n,body=b,_dbg=pt.dbg}\n  else -- OK. local namelist [‘=’ exprlist]\n    local n = namelist(tkns)\n    for _,name in ipairs(n) do scope.addLocal(name) end\n    local e\n    if tkns.matchp('opval','assign') then\n      e = exprlist(tkns)\n    end\n    return {type='local',names=n,exprs=e,_dbg=pt.dbg}\n  end\nend\nif tkns.matchpt('t_lcur') then -- OK. tableconstructor\n  local tab = tablevalue(tkns)\n  tkns.matcht('t_ddot',\": expected for table property call\")\n  local n = tkns.matcht('t_name',\"Expected property name after ':'\").value\n  return {type='prop',prop=n,obj=tab,_dbg=pt.dbg}\nend\nif tkns.peek().type=='num' then\n  local num = tkns.matcht('num')\n  tkns.matcht('t_ddot',\": expected for number property call\")\n  local n = tkns.matcht('t_name',\"Expected property name after ':'\").value\n  if tkns.matchp('opval','assign') then\n    local val = expr(tkns)\n    return {type='putprop',prop=n,obj=num,expr=val,_dbg=pt.dbg}\n  end\n  return {type='getprop',prop=n,obj=num,_dbg=pt.dbg}\nend\nperror(fmt(\"unexpected token %s\",tkns.peek().type),tkns.peek())\nend\n\nfunction namelist(tkns)\n  local names = {tkns.matcht('t_name',\"Expected variable name\").value}\n  while tkns.matchpt('t_comma') do\n    names[#names+1] = tkns.matcht('t_name',\"Expected variable name\").value\n  end\n  return names\nend\n\nfunction funcname(tkns)\n  local n = {tkns.matcht('t_name',\"Expected FUNCTION name\").value}\n  while tkns.matchpt('t_dot') do\n    n[#n+1] = tkns.matcht('t_name',\"Expected FUNCTION name\").value\n  end\n  if tkns.matchpt('t_ddot') then\n    n[#n+1] = tkns.matcht('t_name').value\n  end\n  return n\nend\n\nfunction funcbody(tkns)\n  tkns.matcht('t_lpar',\"Expected '(' in FUNCTION definition\")\n  local p = parlist(tkns)\n  tkns.matcht('t_rpar',\"Expected ')' in FUNCTION definition\")\n  local b = block(tkns,endEnd)\n  tkns.matcht('t_end',\"Expected 'end' in FUNCTION definition\")\n  return {params=p,block=b}\nend\n\nlocal function args(tkns)\n  tkns.matcht('t_lpar',\"Expected '(' in FUNCTION call\")\n  local exprs = exprlist(tkns)\n  tkns.matcht('t_rpar',\"Expected ')' in FUNCTION call\")\n  return exprs\nend\n\nfunction prefixexpr(tkns,r)\n  local t = tkns.peek()\n  if t.type == 't_dot' then\n    tkns.next()\n    local n = tkns.matcht('t_name',\"Expected name after '.'\")\n    return prefixexpr(tkns,{type='aref',tab=r,idx=n.value,_dbg=n.dbg})\n  elseif t.type == 't_lbra' then\n    tkns.next()\n    local e = expr(tkns,braEnd)\n    if e.const then e = e.value end\n    tkns.matcht('t_rbra',\"Expected ']' to end table access\")\n    return prefixexpr(tkns,{type='aref',tab=r,idx=e,_dbg=t.dbg})\n  elseif t.type == 't_lcur' then -- ToDo\n    error(\"Not implemented yet\")\n  elseif t.type == 't_lpar' then\n    local isExpr = inExpr\n    local args = args(tkns)\n    return prefixexpr(tkns,{type='call',fun=r,args=args,expr=isExpr,_dbg=t.dbg}) \n  elseif t.type == 't_ddot' then\n    tkns.next()\n    local n = tkns.matcht('t_name',\"Expected name after ':'\").value\n    if tkns.peek().type == 't_lpar' then -- method call\n      local isExpr = inExpr\n      local args = args(tkns)\n      return prefixexpr(tkns,{type='objcall',obj=r,fun=n,args=args,expr=isExpr,_dbg=t.dbg})\n    else\n      return {type='getprop',obj=r,prop=n,expr=inExpr,_dbg=t.dbg} -- property access\n    end\n  else return r end\nend\n\nfunction parlist(tkns)\n  local n = namelist(tkns)\n  if tkns.matchpt('...') then\n    n[#n+1] = '...'\n  end\n  return n\nend\n\nfunction varlist(tkns,var)\n  local v = {var}\n  while tkns.matchpt('t_comma') do\n    local p = tkns.peek()\n    local n = tkns.matcht('t_name',\"Expected variable name\")\n    v[#v+1] = prefixexpr(tkns,{type='name',value=n.value,_dbg=p.dbg,vt=varType(n.value)})\n    local e = v[#v]\n    if not(e.type == 'name' or e.type == 'aref' or e.type == 'getprop') then \n      perror(fmt(\"expected variable or table assignment\"),p)\n    end\n  end\n  return v\nend\n\nfunction exprlist(tkns)\n  local e = {expr(tkns,exprEnd)}\n  while tkns.matchpt('t_comma') do\n    e[#e+1] = expr(tkns,exprEnd)\n  end\n  return e\nend\n\nlocal curlEnd = merge(mapT{'t_rbra','t_rcurl,t_comma'},exprEnd)\nfunction tablevalue(tkns)\n  local tab,idx,n = {},1,0\n  local t0 = tkns.peek()\n  while tkns.peek().type ~= 't_rcur' do\n    local t = tkns.peek()\n    if t.type == 't_lbra' then --[expr] = ...\n      tkns.next()\n      local k = expr(tkns,curlEnd)\n      tkns.matcht('t_rbra',\"Expected ']' in table constructor\")\n      tkns.match('opval','assign',\"Expected '=' in table constructor\")\n      local v = expr(tkns,curlEnd)\n      if k.const then k = k.value \n        tab[#tab+1] = {key=k.value,value=v}; n = n + (v.const and 1 or 0)\n      else tab[#tab+1] = {expr=k,value=v} end\n    elseif t.type == 't_name' and tkns.peek(2).opval == 'assign' then  -- name = expr\n      local name = t.value\n      tkns.next()\n      tkns.match('opval','assign',\"Expected '=' in table constructor\")\n      local v = expr(tkns,curlEnd)\n      tab[#tab+1] = {key=name,value=v}; n = n + (v.const and 1 or 0)\n    else\n      local v = expr(tkns,curlEnd)\n      tab[#tab+1] = {key=idx,value=v}; idx=idx+1; n = n + (v.const and 1 or 0)\n    end\n    if not tkns.matchpt('t_comma') then break end\n  end \n  tkns.matcht('t_rcur')\n  if next(tab)==nil or n == #tab then\n    local res = {}\n    for i,k in ipairs(tab) do res[k.key] = k.value.value end\n    return {type='table',value=res,const=true,_dbg=t0.dbg}\n  elseif #tab == 1 and tab[1].value and tab[1].value.value == '...' then\n    return {type='varargstable',_dbg=t0.dbg}\n  else return {type='table',value=tab,_dbg=t0.dbg} end\nend\n\nlocal function isConst(t) return t.const and t.type or t.type=='t_name' and 'name' end\nlocal function isNum(t) return t.type=='num' end\n\nlocal foldConst = {}\nlocal ops = {\n  ['add']=function(a,b) return a+b end,\n  ['sub']=function(a,b) return a-b end,\n  ['mul']=function(a,b) return a*b end,\n  ['div']=function(a,b) return a/b end,\n}\nlocal foldConsts = mapT{'add','sub','mul','div'}\n\nlocal function foldConst(op,a,b)\n  if isNum(a) then\n    if isNum(b) then\n      return {type='num',value=ops[op](a.value,b.value),const=true,_dbg=mergeDbg(a,b)}\n    end\n    return {type='unop',op=op,a=a.value,exp=b,_dbg=b._dbg}\n  elseif isNum(b) then\n    --if op == 'div' then op,b.value = 'mul',1/b.value end\n    --if op == 'sub' then op,b.value = 'sub',-b.value end\n    return {type='unop',op=op,b=b.value,exp=a,_dbg=a._dbg}\n  end\n  return {type='binop',op=op,exp1=a,exp2=b,_dbg=b._dbg}\nend\n\nlocal simpBinops = mapT{'and','or'}\nlocal function simpBinop(op,a,b)\n  if b.type == 'binop' and b.op == op then\n    return {type='seqop',op=op,exprs={a,b.expr1,b.expr2},_dbg=mergeDbg(b.expr1,b.expr2)}\n  elseif b.type == 'seqop' and b.op == op then\n    table.insert(b.exprs,1,a)\n    return {type='seqop',op=op,exprs=b.exprs,_dbg=b._dbg}\n  end\n  return {type='seqop',op=op,exprs={a,b},_dbg=mergeDbg(a,b)}\nend\n\nlocal function isOperator(t) return t.opval end\nlocal function prio(op) return Opers[op].prio end\nlocal function applyOp(op,vals)\n  if Opers[op].unop then\n    local a = vals.pop()\n    if op == 'neg' and isNum(a) then \n      return {type='num',value=-a.value,const=true,_dbg=a._dbg} \n    else return {type='unop',op=op,exp=a,_dbg=a._dbg} end\n  else\n    local b,a = vals.pop(),vals.pop()\n    if foldConsts[op] then return foldConst(op,a,b)\n    elseif simpBinops[op] then return simpBinop(op,a,b)\n    else return {type='binop',op=op,exp1=a,exp2=b,_dbg=mergeDbg(a,b)} end\n  end\nend\n\nlocal function CMT(t)\n  return setmetatable(t,{__tostring=function(t) return fmt(\"%s:%s\",t.type,t.value) end})\nend\nlocal specOp = {}\nlocal parEnd = mapT{'t_rpar','t_eof'}\nlocal braEnd = mapT{'t_rbra','t_eof'}\nfunction specOp.t_lpar(t,vals,ops,tkns)\n  local e = expr(tkns,parEnd)\n  tkns.matcht('t_rpar',\"Expcted ) to close (...\")\n  e = prefixexpr(tkns,e)\n  vals.push(e)\nend\nfunction specOp.t_lbra(t,vals,ops,tkns)\n  local e = expr(tkns,braEnd)\n  tkns.matcht('t_rbra',\"Expected ]\")\n  ops.push(e) -- table index\n  vals.push(e)\nend\nfunction specOp.t_lcur(t,vals,ops,tkns)\n  local isExpr = inExpr\n  local tab = tablevalue(tkns)\n  if tkns.matchpt('t_ddot') then\n    local n = tkns.matcht('t_name',\"Expected property name after :\").value\n    vals.push({type='getprop',obj=tab,prop=n,expr=isExpr,_dbg=n.dbg})\n  else\n    vals.push(tab)\n  end\nend\nfunction specOp.t_nil(t,vals,ops,tkns) vals.push(CMT{type='const',value=nil,const=true,_dbg=t.dbg}) end\nfunction specOp.t_true(t,vals,ops,tkns) vals.push(CMT{type='const',value=true,const=true,_dbg=t.dbg}) end\nfunction specOp.t_false(t,vals,ops,tkns) vals.push(CMT{type='const',value=false,const=true,_dbg=t.dbg}) end\nfunction specOp.num(t,vals,ops,tkns)\n  if tkns.matchpt('t_ddot') then\n    local n = tkns.matcht('t_name',\"Expected property name after :\").value\n    vals.push({type='getprop',obj=t,prop=n,expr=inExpr,_dbg=t.dbg})\n  else\n    vals.push(CMT{type='num',value=t.value,const=true,_dbg=t.dbg})\n  end\nend\nfunction specOp.event(t,vals,ops,tkns)\n  local tab\n  if tkns.peek().type == 't_lcur' then\n    local tab = tablevalue(tkns)\n    tab.type = t.value\n  else tab = {type='table',value={type=t.value},const=true,_dbg=t.dbg} end\n  vals.push(tab)\nend\nfunction specOp.str(t,vals,ops,tkns) vals.push(CMT{type='str',value=t.value,const=true,_dbg=t.dbg}) end\nfunction specOp.t_name(t,vals,ops,tkns)\n  local v = prefixexpr(tkns,CMT{type='name',value=t.value,_dbg=t.dbg,vt=varType(t.value)})\n  vals.push(v) \nend\nfunction specOp.t_function(t,vals,ops,tkns)\n  local isExpr = inExpr\n  local f = funcbody(tkns)\n  local fun = {type='functionexpr',fun={type='func'..'tion',expr=isExpr,params=f.params,body=f.block},_dbg=t.dbg}\n  local v = prefixexpr(tkns,fun)\n  vals.push(v)\nend\n\nlocal unminBeg = mapT{\n  't_rpar','t_rbra','t_name','num','t_str','t_nil','t_true','t_false'\n}\nlocal exprEnd = mapT(merge(blockEnd,{}))\nfunction expr(tkns,ends)\n  local oldExpr = inExpr\n  inExpr = true\n  local ops,vals = Stack(),Stack()\n  while true do\n    local t = tkns.peek()\n    if (ends or exprEnd)[t.type] then break end\n    if specOp[t.type] then\n      tkns.next()\n      specOp[t.type](t,vals,ops,tkns)\n    elseif isOperator(t) then\n      if t.opval == 'sub' then\n        local last = tkns.last()\n        if not last or not unminBeg[last.type] then t.opval = 'neg' end\n      end\n      tkns.next()\n      local tprio = prio(t.opval)\n      while not ops.isEmpty() and prio(ops.peek().opval) > tprio do\n        vals.push(applyOp(ops.pop().opval,vals))\n      end\n      ops.push(t)\n    else\n      break -- end of expr?\n    end\n  end\n  while not ops.isEmpty() do\n    vals.push(applyOp(ops.pop().opval,vals))\n  end\n  inExpr=oldExpr\n  return vals.pop()\nend\n\nfunction retstat(tkns,ends)\n  local t = tkns.matcht('t_return')\n  local e\n  if not ends[tkns.peek().type] then\n    e = exprlist(tkns)\n  end\n  if tkns.matchpt('t_semi') then --[[ ignore --]] end\n  return {type='return',exp=e,_dbg=t.dbg}\nend\n\nlocal ruleEnd = mapT{'t_ruleend','t_eof'}\nfunction ER.parse(tkns)\n  Stack,Opers = ER.Stack,ER._opers1\n  scope,inExpr = Scope(),false\n  _perror,_source = ER.perror,tkns.src\n  tkns.error = matchError\n  local res\n  if tkns.matchpt('t_rulebegin') then\n    local head = expr(tkns,ruleEnd)\n    tkns.matcht('t_rule',\"Expected rule\")\n    local body = block(tkns,ruleEnd)\n    tkns.matcht('t_ruleend',\"Expected rule end\")\n    res = {type='ruledef',head=head,body=body,_dbg=head._dbg}             \n  else res = block(tkns,blockEnd) end\n  local rest = tkns.peek()\n  if rest.type ~= 't_eof' then\n    perror(\"Expected end of file but got \"..rest.type,tkns.peek())\n  end\n  res._src = tkns.src\n  return res\nend"},{"isMain":false,"isOpen":false,"name":"props","type":"lua","content":"fibaro.EventRunner = fibaro.EventRunner or { debugFlags = {} }\nlocal ER = fibaro.EventRunner\nlocal debugFlags = ER.debugFlags\nER.propFilters = {}\n\n-------------- builtin props -------------------------\n-- getProps helpers\nlocal function BN(x) if type(x)=='boolean' then return x and 1 or 0 else return tonumber(x) or 0 end end\nlocal function get(id,prop) return fibaro.get(id,prop) end\nlocal function getnum(id,prop) return tonumber((fibaro.get(id,prop))) or nil end\nlocal function on(id,prop) return BN(fibaro.get(id,prop)) > 0 end\nlocal function off(id,prop) return BN(fibaro.get(id,prop)) == 0 end\nlocal function call(id,cmd) fibaro.call(id,cmd); return true end\nlocal function toggle(id,prop) if on(id,prop) then fibaro.call(id,'turnOff') else fibaro.call(id,'turnOn') end return true end\nlocal function profile(id,_) return api.get(\"/profiles/\"..id) end\nlocal function child(id,_) return quickApp.childDevices[id] end\nlocal function last(id,prop) local _,t=fibaro.get(id,prop); local r = t and os.time()-t or 0; return r end\nlocal function cce(id,_,e) return e.type=='device' and e.property=='centralSceneEvent'and e.id==id and e.value or {} end\nlocal function ace(id,_,e) return e.type=='device' and e.property=='accessControlEvent' and e.id==id and e.value or {} end\nlocal function sae(id,_,e) return e.type=='device' and e.property=='sceneActivationEvent' and e.id==id and e.value.sceneId end\nlocal mapOr,mapAnd,mapF=table.mapOr,table.mapAnd,function(f,l,s) table.mapf(f,l,s); return true end\nlocal function partition(id) return api.get(\"/alarms/v1/partitions/\" .. id) or {} end\nlocal function armState(id) return id==0 and fibaro.getHomeArmState() or fibaro.getPartitionArmState(id) end\nlocal function arm(id,action)\n  if action=='arm' then \n    local _,res = fibaro.armPartition(id); return res == 200\n  else\n    local _,res = fibaro.unarmPartition(id); return res == 200\n  end\nend\nlocal function tryArm(id)\n  local data,res = fibaro.tryArmPartition(id)\n  if res ~= 200 then return false end\n  if type(data) == 'table' then\n    fibaro.post({type='alarm',id=id,action='tryArm',property='delayed',value=data})\n  end\n  return true\nend\nlocal helpers = { BN=BN, get=get, on=on, off=off, call=call, profile=profile, child=child, last=last, cce=cce, ace=ace, sae=sae, mapOr=mapOr, mapAnd=mapAnd, mapF=mapF }\n\nlocal getProps={}\nER.getProps = getProps\n-- { type, function to get prop, property name in sourceTrigger, reduce function, if props is a rule trigger }\ngetProps.value={'device',get,'value',nil,true}\ngetProps.state={'device',get,'state',nil,true}\ngetProps.bat={'device',getnum,'batteryLevel',nil,true}\ngetProps.power={'device',getnum,'power',nil,true}\ngetProps.isDead={'device',get,'dead',mapOr,true}\ngetProps.isOn={'device',on,'value',mapOr,true}\ngetProps.isOff={'device',off,'value',mapAnd,true}\ngetProps.isAllOn={'device',on,'value',mapAnd,true}\ngetProps.isAnyOff={'device',off,'value',mapOr,true}\ngetProps.last={'device',last,'value',nil,true}\n\ngetProps.armed={'alarm',function(id) return  armState(id)=='armed' end,'armed',mapOr,true}\ngetProps.tryArm={'alarm',tryArm,nil,'alarm',false}\ngetProps.isArmed={'alarm',function(id) return partition(id).armed end,'armed',mapOr,true}\ngetProps.isAllArmed={'alarm',function(id) return partition(id).armed end,'armed',mapAnd,true,true}\ngetProps.isDisarmed={'alarm',function(id) return partition(id).armed==false end,'armed',mapAnd,true}\ngetProps.isAnyDisarmed={'alarm',function(id) return partition(id).armed==false end,'armed',mapOr,true,false}\ngetProps.isAlarmBreached={'alarm',function(id) return partition(id).breached end,'breached',mapOr,true}\ngetProps.isAlarmSafe={'alarm',function(id) return partition(id).breached==false end,'breached',mapAnd,true}\ngetProps.isAllAlarmBreached={'alarm',function(id) return partition(id).breached end,'breached',mapAnd,true}\ngetProps.isAnyAlarmSafe={'alarm',function(id) return partition(id).breached==false end,'breached',mapOr,true,false}\n\ngetProps.child={'device',child,nil,nil,false}\ngetProps.parent={'device',function(id) return api.get(\"/devices/\"..id).parentId end,nil,nil,false}\ngetProps.profile={'device',profile,nil,nil,false}\ngetProps.scene={'device',sae,'sceneActivationEvent',nil,true}\ngetProps.access={'device',ace,'accessControlEvent',nil,true}\ngetProps.central={'device',cce,'centralSceneEvent',nil,true}\ngetProps.safe={'device',off,'value',mapAnd,true}\ngetProps.breached={'device',on,'value',mapOr,true}\ngetProps.isOpen={'device',on,'value',mapOr,true}\ngetProps.isClosed={'device',off,'value',mapAnd,true}\ngetProps.lux={'device',getnum,'value',nil,true}\ngetProps.volume={'device',get,'volume',nil,true}\ngetProps.position={'device',get,'position',nil,true}\ngetProps.temp={'device',get,'value',nil,true}\ngetProps.coolingThermostatSetpoint={'device',get,'coolingThermostatSetpoint',nil,true}\ngetProps.coolingThermostatSetpointCapabilitiesMax={'device',get,'coolingThermostatSetpointCapabilitiesMax',nil,true}\ngetProps.coolingThermostatSetpointCapabilitiesMin={'device',get,'coolingThermostatSetpointCapabilitiesMin',nil,true}\ngetProps.coolingThermostatSetpointFuture={'device',get,'coolingThermostatSetpointFuture',nil,true}\ngetProps.coolingThermostatSetpointStep={'device',get,'coolingThermostatSetpointStep',nil,true}\ngetProps.heatingThermostatSetpoint={'device',get,'heatingThermostatSetpoint',nil,true}\ngetProps.heatingThermostatSetpointCapabilitiesMax={'device',get,'heatingThermostatSetpointCapabilitiesMax',nil,true}\ngetProps.heatingThermostatSetpointCapabilitiesMin={'device',get,'heatingThermostatSetpointCapabilitiesMin',nil,true}\ngetProps.heatingThermostatSetpointFuture={'device',get,'heatingThermostatSetpointFuture',nil,true}\ngetProps.heatingThermostatSetpointStep={'device',get,'heatingThermostatSetpointStep',nil,true}\ngetProps.thermostatFanMode={'device',get,'thermostatFanMode',nil,true}\ngetProps.thermostatFanOff={'device',get,'thermostatFanOff',nil,true}\ngetProps.thermostatMode={'device',get,'thermostatMode',nil,true}\ngetProps.thermostatModeFuture={'device',get,'thermostatModeFuture',nil,true}\ngetProps.on={'device',call,'turnOn',mapF,true}\ngetProps.off={'device',call,'turnOff',mapF,true}\ngetProps.play={'device',call,'play',mapF,nil}\ngetProps.pause={'device',call,'pause',mapF,nil}\ngetProps.open={'device',call,'open',mapF,true}\ngetProps.close={'device',call,'close',mapF,true}\ngetProps.stop={'device',call,'stop',mapF,true}\ngetProps.secure={'device',call,'secure',mapF,false}\ngetProps.unsecure={'device',call,'unsecure',mapF,false}\ngetProps.isSecure={'device',on,'secured',mapAnd,true}\ngetProps.isUnsecure={'device',off,'secured',mapOr,true}\ngetProps.name={'device',function(id) return fibaro.getName(id) end,nil,nil,false}\ngetProps.partition={'alarm',function(id) return partition(id) end,nil,nil,false}\ngetProps.HTname={'device',function(id) return ER.reverseVar(id) end,nil,nil,false}\ngetProps.roomName={'device',function(id) return fibaro.getRoomNameByDeviceID(id) end,nil,nil,false}\ngetProps.trigger={'device',function() return true end,'value',nil,true}\ngetProps.time={'device',get,'time',nil,true}\ngetProps.manual={'device',function(id) return quickApp:lastManual(id) end,'value',nil,true}\ngetProps.start={'device',function(id) return fibaro.scene(\"execute\",{id}) end,\"\",mapF,false}\ngetProps.kill={'device',function(id) return fibaro.scene(\"kill\",{id}) end,\"\",mapF,false}\ngetProps.toggle={'device',toggle,'value',mapF,true}\ngetProps.wake={'device',call,'wakeUpDeadDevice',mapF,true}\ngetProps.removeSchedule={'device',call,'removeSchedule',mapF,true}\ngetProps.retryScheduleSynchronization={'device',call,'retryScheduleSynchronization',mapF,true}\ngetProps.setAllSchedules={'device',call,'setAllSchedules',mapF,true}\ngetProps.levelIncrease={'device',call,'startLevelIncrease',mapF,nil}\ngetProps.levelDecrease={'device',call,'startLevelDecrease',mapF,nil}\ngetProps.levelStop={'device',call,'stopLevelChange',mapF,nil}\ngetProps.type={'device',function(id) return ER.getDeviceInfo(id).type end,'type',mapF,nil}\n\n-- setProps helpers\nlocal function set(id,cmd,val) fibaro.call(id,cmd,val); return val end\nlocal function set2(id,cmd,val)\n  assert(type(val)=='table' and #val>=3,\"setColor expects a table with 3 values\")\n  fibaro.call(id,cmd,table.unpack(val)); \n  return val \nend\nlocal function setProfile(id,_,val) if val then fibaro.profile(\"activateProfile\",id) end return val end\nlocal function setState(id,_,val) fibaro.call(id,\"updateProperty\",\"state\",val); return val end\nlocal function setProps(id,cmd,val) fibaro.call(id,\"updateProperty\",cmd,val); return val end\nlocal function dim2(id,_,val) ER.utilities.dimLight(id,table.unpack(val)) end\nlocal function pushMsg(id,cmd,val) fibaro.alert(fibaro._pushMethod,{id},val); return val end\nlocal function setAlarm(id,cmd,val) arm(id,val and 'arm' or 'disarm') return val end\nhelpers.set, helpers.set2, helpers.setProfile, helpers.setState, helpers.setProps, helpers.dim2, helpers.pushMsg = set, set2, setProfile, setState, setProps, dim2, pushMsg\n\nlocal setProps = {}\nER.setProps = setProps\n-- { function to get prop, property name }\nsetProps.R={set,'setR'} -- Don't think the RGBs are valid anymore...\nsetProps.G={set,'setG'}\nsetProps.B={set,'setB'}\nsetProps.W={set,'setW'}\nsetProps.value={set,'setValue'}\nsetProps.state={setState,'setState'}\nsetProps.prop={function(id,_,val) fibaro.call(id,\"updateProperty\",table.unpack(val)) end,'upDateProp'}\n\nsetProps.armed={setAlarm,'setAlarm'}\n\nsetProps.profile={setProfile,'setProfile'}\nsetProps.time={set,'setTime'}\nsetProps.power={set,'setPower'}\nsetProps.targetLevel={set,'setTargetLevel'}\nsetProps.interval={set,'setInterval'}\nsetProps.mode={set,'setMode'}\nsetProps.setpointMode={set,'setSetpointMode'}\nsetProps.defaultPartyTime={set,'setDefaultPartyTime'}\nsetProps.scheduleState={set,'setScheduleState'}\nsetProps.color={set2,'setColor'}\nsetProps.volume={set,'setVolume'}\nsetProps.position={set,'setPosition'}\nsetProps.positions={setProps,'availablePositions'}\nsetProps.mute={set,'setMute'}\nsetProps.thermostatSetpoint={set2,'setThermostatSetpoint'}\nsetProps.thermostatMode={set,'setThermostatMode'}\nsetProps.heatingThermostatSetpoint={set,'setHeatingThermostatSetpoint'}\nsetProps.coolingThermostatSetpoint={set,'setCoolingThermostatSetpoint'}\nsetProps.thermostatFanMode={set,'setThermostatFanMode'}\nsetProps.schedule={set2,'setSchedule'}\nsetProps.dim={dim2,'dim'}\nfibaro._pushMethod = 'push'\nsetProps.msg={pushMsg,\"push\"}\nsetProps.defemail={set,'sendDefinedEmailNotification'}\nsetProps.btn={set,'pressButton'} -- ToDo: click button on QA?\nsetProps.email={function(id,_,val) local _,_ = val:match(\"(.-):(.*)\"); fibaro.alert('email',{id},val) return val end,\"\"}\nsetProps.start={function(id,_,val) \n  if isEvent(val) then \n    fibaro.postRemote(id,val) return true\n  else \n    fibaro.scene(\"execute\",{id}) return true\n  end\nend,\"\"}\nsetProps.sim_pressed={function(id,_,val) fibaro.post({type='device',id=id,property='centralSceneEvent',value={keyId=val,keyAttribute='Pressed'}}) end,\"push\"} -- For simulated button presses\nsetProps.sim_helddown={function(id,_,val) fibaro.post({type='device',id=id,property='centralSceneEvent',value={keyId=val,keyAttribute='HeldDown'}}) end,\"push\"}\nsetProps.sim_released={function(id,_,val) fibaro.post({type='device',id=id,property='centralSceneEvent',value={keyId=val,keyAttribute='Released'}}) end,\"push\"}\n\nsetProps.isCat={function(id,_,val) return ER.getDeviceInfo(id).categories[val]==true end,\"...\"}\nsetProps.isInterf={function(id,_,val) return ER.getDeviceInfo(id).interfaces[val]==true end,\"...\"}\n\nlocal filters = ER.propFilters\nER.propFilterTriggers = {}\nlocal function NB(x) if type(x)=='number' then return x~=0 and 1 or 0 else return x end end\nlocal function mapAnd(l) for _,v in ipairs(l) do if not NB(v) then return false end end return true end\nlocal function mapOr(l) for _,v in ipairs(l) do if NB(v) then return true end end return false end\nfunction filters.average(list) local s = 0; for _,v in ipairs(list) do s=s+BN(v) end return s/#list end\nfunction filters.sum(list) local s = 0; for _,v in ipairs(list) do s=s+BN(v) end return s end\nfunction filters.allFalse(list) return not mapOr(list) end\nfunction filters.someFalse(list) return not mapAnd(list)  end\nfunction filters.allTrue(list) return mapAnd(list) end\nfunction filters.someTrue(list) return mapOr(list)  end\nfunction filters.mostlyTrue(list) local s = 0; for _,v in ipairs(list) do s=s+(NB(v) and 1 or 0) end return s>#list/2 end\nfunction filters.mostlyFalse(list) local s = 0; for _,v in ipairs(list) do s=s+(NB(v) and 0 or 1) end return s>#list/2 end\nfunction filters.bin(list) local s={}; for _,v in ipairs(list) do s[#s+1]=NB(v) and 1 or 0 end return s end\nfunction filters.GV(list) local s={}; for _,v in ipairs(list) do s[#s+1]=GlobalV(v) end return s end\nER.propFilterTriggers.GV = true\nfunction filters.QV(list) local s={}; for _,v in ipairs(list) do s[#s+1]=QuickAppV(v) end return s end\nER.propFilterTriggers.QV = true\nfunction filters.id(list,ev) return next(ev) and ev.id or list end -- If we called from rule trigger collector we return whole list\nlocal function collect(t,m)\n  if type(t)=='table' then\n    for _,v in pairs(t) do collect(v,m) end\n  else m[t]=true end\nend\nfunction filters.leaf(tree)\n  local map,res = {},{}\n  collect(tree,map)\n  for e,_ in pairs(map) do res[#res+1]=e end\n  return res \nend\n\n----------------------------------------- PropObject handling --------------------------------------\n\nPropObject = {}\nclass 'PropObject'\nfunction PropObject:__init()\n  self._isPropObject = true\nend\n\nNumberPropObject = {}\nclass 'NumberPropObject'(PropObject)\nfunction NumberPropObject:__init(num)  PropObject.__init(self) self.id = num end\nfunction NumberPropObject:getProp(prop,env)\n  local gp = getProps[prop]\n  if not gp then return env.error(\"Unknown property: \"..tostring(prop)) end\n  local fun = gp[2]\n  local prop = gp[3]\n  local value = fun(self.id,prop)\n  return value\nend\nfunction NumberPropObject:setProp(prop,value)\n  local sp = setProps[prop]\n  if not sp then return nil,\"Unknown property: \"..tostring(prop) end\n  local fun = sp[1]\n  local cmd = sp[2]\n  local r = fun(self.id,cmd,value)\n  return true\nend\nfunction NumberPropObject:reduce(prop,value,env)\n  local gp = getProps[prop]\n  if not gp then return env.error(\"Unknown property: \"..tostring(prop)) end\n  local red = gp[4]\n  if red == nil then return value end\n  return red(value)\nend\n\nlocal numObjects = {}\nlocal function resolvePropObject(obj)\n  if type(obj) == 'userdata' and obj._isPropObject then return obj\n  elseif type(obj) == 'number' then \n    local po = numObjects[obj] or NumberPropObject(obj)\n    numObjects[obj] = po\n    return po\n  else return nil end\nend\n\nlocal function executeGetProp(obj,prop,env)\n  if type(obj) == 'table' then\n    if #obj == 0 then return env.error(\"Expected non-empty table, got empty table\") end\n    local r,fo = {},nil\n    for k,v in pairs(obj) do\n      local v = resolvePropObject(v)\n      fo = fo or v\n      if not v then return env.error(\"Not a prop object: \"..tostring(v)) end\n      r[k] = v:getProp(prop)\n    end\n    r = fo:reduce(prop,r)\n    return r\n  else\n    local v = resolvePropObject(obj)\n    if not v then return env.error(\"Not a prop object: \"..tostring(v)) end\n    return v:getProp(prop)\n  end\nend\n\nlocal function executeSetProp(obj,prop,value,env)\n  if type(obj) == 'table' then\n    if #obj == 0 then return env.error(\"Expected non-empty table, got empty table\") end\n    for _,v in pairs(obj) do\n      local v = resolvePropObject(v)\n      if not v then return env.error(\"Not a prop object: \"..tostring(v)) end\n      v:setProp(prop,value)\n    end\n  else\n    local v = resolvePropObject(obj)\n    if not v then return env.error(\"Not a prop object: \"..tostring(v)) end\n    v:setProp(prop,value)\n  end\nend\n\nER.executeGetProp = executeGetProp\nER.executeSetProp = executeSetProp"},{"isMain":false,"isOpen":false,"name":"utils","type":"lua","content":"fibaro.EventRunner = fibaro.EventRunner or { debugFlags = {} }\nlocal ER = fibaro.EventRunner\nlocal debugFlags = ER.debugFlags\n\nlocal fmt = string.format\n\ngetmetatable(\"\").__idiv = function(str,len) return (#str < len or #str < 4) and str or str:sub(1,len-2)..\"..\" end -- truncate strings\n\nlocal function copy(obj)\n  if type(obj) == 'table' then\n    local res = {} for k,v in pairs(obj) do res[k] = copy(v) end\n    return res\n  else return obj end\nend\n\nlocal function copyShallow(obj)\n  if type(obj) == 'table' then\n    local res = {} for k,v in pairs(obj) do res[k] = v end\n    return res\n  else return obj end\nend\n\nlocal function equal(e1,e2)\n  if e1==e2 then return true\n  else\n    if type(e1) ~= 'table' or type(e2) ~= 'table' then return false\n    else\n      for k1,v1 in pairs(e1) do if e2[k1] == nil or not equal(v1,e2[k1]) then return false end end\n      for k2,_  in pairs(e2) do if e1[k2] == nil then return false end end\n      return true\n    end\n  end\nend\n\ntable.copy = copy\ntable.copyShallow = copyShallow\ntable.equal = equal\n\nfunction string.split(str, sep)\n    local fields, s = {}, sep or \"%s\"\n    str:gsub(\"([^\" .. s .. \"]+)\", function(c)\n        fields[#fields + 1] = c\n    end)\n    return fields\nend\n\nif not table.maxn then \n  function table.maxn(tbl) local c=0 for i,_ in pairs(tbl) do c=i end return c end\nend\n\nfunction table.map(f,l,s) s = s or 1; local r,m={},table.maxn(l) for i=s,m do r[#r+1] = f(l[i]) end return r end\nfunction table.mapAnd(f,l,s) s = s or 1; local e=true for i=s,table.maxn(l) do e = f(l[i]) if not e then return false end end return e end \nfunction table.mapOr(f,l,s) s = s or 1; for i=s,table.maxn(l) do local e = f(l[i]) if e then return e end end return false end\nfunction table.reduce(f,l) local r = {}; for _,e in ipairs(l) do if f(e) then r[#r+1]=e end end; return r end\nfunction table.mapk(f,l) local r={}; for k,v in pairs(l) do r[k]=f(v) end; return r end\nfunction table.mapkv(f,l) local r={}; for k,v in pairs(l) do k,v=f(k,v) if k then r[k]=v end end; return r end\nfunction table.mapkl(f,l) local r={} for i,j in pairs(l) do r[#r+1]=f(i,j) end return r end\nfunction table.size(l) local n=0; for _,_ in pairs(l) do n=n+1 end return n end \n\n--------------- Time and Sun calc  functions -----------------------\nlocal function toSeconds(str)\n  __assert_type(str,\"string\" )\n  local sun = str:match(\"(sun%a+)\")\n  if sun then return toSeconds(str:gsub(sun,fibaro.getValue(1,sun..\"Hour\"))) end\n  local var = str:match(\"(%$[A-Za-z]+)\")\n  if var then return toSeconds(str:gsub(var,fibaro.getGlobalVariable(var:sub(2)))) end\n  local h,m,s,op,off=str:match(\"(%d%d):(%d%d):?(%d*)([+%-]*)([%d:]*)\")\n  off = off~=\"\" and (off:find(\":\") and toSeconds(off) or toSeconds(\"00:00:\"..off)) or 0\n  return 3600*h+60*m+(s~=\"\" and s or 0)+((op=='-' or op =='+-') and -1 or 1)*off\nend\n\n---@diagnostic disable-next-line: param-type-mismatch\nlocal function midnight() local t = os.date(\"*t\"); t.hour,t.min,t.sec = 0,0,0; return os.time(t) end\nlocal function getWeekNumber(tm) return tonumber(os.date(\"%V\",tm)) end\nlocal function now() return os.time()-midnight() end\n\nlocal function between(start,stop,optTime)\n  __assert_type(start,\"string\" )\n  __assert_type(stop,\"string\" )\n  start,stop,optTime=toSeconds(start),toSeconds(stop),optTime and toSeconds(optTime) or toSeconds(os.date(\"%H:%M\"))\n  stop = stop>=start and stop or stop+24*3600\n  optTime = optTime>=start and optTime or optTime+24*3600\n  return start <= optTime and optTime <= stop\nend\nlocal function time2str(t) return fmt(\"%02d:%02d:%02d\",math.floor(t/3600),math.floor((t%3600)/60),t%60) end\n\nlocal sunCalc \n\nlocal function hm2sec(hmstr,ns)\n  local offs,sun\n  sun,offs = hmstr:match(\"^(%a+)([+-]?%d*)\")\n  if sun and (sun == 'sunset' or sun == 'sunrise') then\n    if ns then\n      local sunrise,sunset = sunCalc(os.time()+24*3600)\n      hmstr,offs = sun=='sunrise' and sunrise or sunset, tonumber(offs) or 0\n    else\n      hmstr,offs = fibaro.getValue(1,sun..\"Hour\"), tonumber(offs) or 0\n    end\n  end\n  local sg,h,m,s = hmstr:match(\"^(%-?)(%d+):(%d+):?(%d*)\")\n  if not (h and m) then error(fmt(\"Bad hm2sec string %s\",hmstr)) end\n  return (sg == '-' and -1 or 1)*(tonumber(h)*3600+tonumber(m)*60+(tonumber(s) or 0)+(tonumber(offs or 0))*60)\nend\n\n-- toTime(\"10:00\")     -> 10*3600+0*60 secs\n-- toTime(\"10:00:05\")  -> 10*3600+0*60+5*1 secs\n-- toTime(\"t/10:00\")    -> (t)oday at 10:00. midnight+10*3600+0*60 secs\n-- toTime(\"n/10:00\")    -> (n)ext time. today at 10.00AM if called before (or at) 10.00AM else 10:00AM next day\n-- toTime(\"+/10:00\")    -> Plus time. os.time() + 10 hours\n-- toTime(\"+/00:01:22\") -> Plus time. os.time() + 1min and 22sec\n-- toTime(\"sunset\")     -> todays sunset in relative secs since midnight, E.g. sunset=\"05:10\", =>toTime(\"05:10\")\n-- toTime(\"sunrise\")    -> todays sunrise\n-- toTime(\"sunset+10\")  -> todays sunset + 10min. E.g. sunset=\"05:10\", =>toTime(\"05:10\")+10*60\n-- toTime(\"sunrise-5\")  -> todays sunrise - 5min\n-- toTime(\"t/sunset+10\")-> (t)oday at sunset in 'absolute' time. E.g. midnight+toTime(\"sunset+10\")\n\nlocal function toTime(time)\n  if type(time) == 'number' then return time end\n  local p = time:sub(1,2)\n  if p == '+/' then return hm2sec(time:sub(3))+os.time()\n  elseif p == 'n/' then\n    local t1,t2 = midnight()+hm2sec(time:sub(3),true),os.time()\n    return t1 > t2 and t1 or t1+24*60*60\n  elseif p == 't/' then return  hm2sec(time:sub(3))+midnight()\n  else return hm2sec(time) end\nend\n\nlocal function sunturnTime(date, rising, latitude, longitude, zenith, local_offset)\n  local rad,deg,floor = math.rad,math.deg,math.floor\n  local frac = function(n) return n - floor(n) end\n  local cos = function(d) return math.cos(rad(d)) end\n  local acos = function(d) return deg(math.acos(d)) end\n  local sin = function(d) return math.sin(rad(d)) end\n  local asin = function(d) return deg(math.asin(d)) end\n  local tan = function(d) return math.tan(rad(d)) end\n  local atan = function(d) return deg(math.atan(d)) end\n  \n  local function day_of_year(date2)\n    local n1 = floor(275 * date2.month / 9)\n    local n2 = floor((date2.month + 9) / 12)\n    local n3 = (1 + floor((date2.year - 4 * floor(date2.year / 4) + 2) / 3))\n    return n1 - (n2 * n3) + date2.day - 30\n  end\n  \n  local function fit_into_range(val, min, max)\n    local range,count = max - min,nil\n    if val < min then count = floor((min - val) / range) + 1; return val + count * range\n    elseif val >= max then count = floor((val - max) / range) + 1; return val - count * range\n    else return val end\n  end\n  \n  -- Convert the longitude to hour value and calculate an approximate time\n  local n,lng_hour,t =  day_of_year(date), longitude / 15,nil\n  if rising then t = n + ((6 - lng_hour) / 24) -- Rising time is desired\n  else t = n + ((18 - lng_hour) / 24) end -- Setting time is desired\n  local M = (0.9856 * t) - 3.289 -- Calculate the Sun^s mean anomaly\n  -- Calculate the Sun^s true longitude\n  local L = fit_into_range(M + (1.916 * sin(M)) + (0.020 * sin(2 * M)) + 282.634, 0, 360)\n  -- Calculate the Sun^s right ascension\n  local RA = fit_into_range(atan(0.91764 * tan(L)), 0, 360)\n  -- Right ascension value needs to be in the same quadrant as L\n  local Lquadrant = floor(L / 90) * 90\n  local RAquadrant = floor(RA / 90) * 90\n  RA = RA + Lquadrant - RAquadrant; RA = RA / 15 -- Right ascension value needs to be converted into hours\n  local sinDec = 0.39782 * sin(L) -- Calculate the Sun's declination\n  local cosDec = cos(asin(sinDec))\n  local cosH = (cos(zenith) - (sinDec * sin(latitude))) / (cosDec * cos(latitude)) -- Calculate the Sun^s local hour angle\n  if rising and cosH > 1 then return -1 --\"N/R\" -- The sun never rises on this location on the specified date\n  elseif cosH < -1 then return -1 end --\"N/S\" end -- The sun never sets on this location on the specified date\n  \n  local H -- Finish calculating H and convert into hours\n  if rising then H = 360 - acos(cosH)\n  else H = acos(cosH) end\n  H = H / 15\n  local T = H + RA - (0.06571 * t) - 6.622 -- Calculate local mean time of rising/setting\n  local UT = fit_into_range(T - lng_hour, 0, 24) -- Adjust back to UTC\n  local LT = UT + local_offset -- Convert UT value to local time zone of latitude/longitude\n  ---@diagnostic disable-next-line: missing-fields\n  return os.time({day = date.day,month = date.month,year = date.year,hour = floor(LT),min = math.modf(frac(LT) * 60)})\nend\n\n---@diagnostic disable-next-line: param-type-mismatch\nlocal function getTimezone() local now = os.time() return os.difftime(now, os.time(os.date(\"!*t\", now))) end\n\nfunction sunCalc(time)\n  local hc3Location = api.get(\"/settings/location\")\n  local lat = hc3Location.latitude or 0\n  local lon = hc3Location.longitude or 0\n  local utc = getTimezone() / 3600\n  local zenith,zenith_twilight = 90.83, 96.0 -- sunset/sunrise 90°50′, civil twilight 96°0′\n  \n  local date = os.date(\"*t\",time or os.time())\n  if date.isdst then utc = utc + 1 end\n  local rise_time = os.date(\"*t\", sunturnTime(date, true, lat, lon, zenith, utc))\n  local set_time = os.date(\"*t\", sunturnTime(date, false, lat, lon, zenith, utc))\n  local rise_time_t = os.date(\"*t\", sunturnTime(date, true, lat, lon, zenith_twilight, utc))\n  local set_time_t = os.date(\"*t\", sunturnTime(date, false, lat, lon, zenith_twilight, utc))\n  local sunrise = fmt(\"%.2d:%.2d\", rise_time.hour, rise_time.min)\n  local sunset = fmt(\"%.2d:%.2d\", set_time.hour, set_time.min)\n  local sunrise_t = fmt(\"%.2d:%.2d\", rise_time_t.hour, rise_time_t.min)\n  local sunset_t = fmt(\"%.2d:%.2d\", set_time_t.hour, set_time_t.min)\n  return sunrise, sunset, sunrise_t, sunset_t\nend\n\nlocal function dateTest(dateStr0)\n  local days = {sun=1,mon=2,tue=3,wed=4,thu=5,fri=6,sat=7}\n  local months = {jan=1,feb=2,mar=3,apr=4,may=5,jun=6,jul=7,aug=8,sep=9,oct=10,nov=11,dec=12}\n  local last,month = {31,28,31,30,31,30,31,31,30,31,30,31},nil\n  \n  local function seq2map(seq) local s = {} for _,v in ipairs(seq) do s[v] = true end return s; end\n  \n  local function flatten(seq,res) -- flattens a table of tables\n    res = res or {}\n    if type(seq) == 'table' then for _,v1 in ipairs(seq) do flatten(v1,res) end else res[#res+1] = seq end\n    return res\n  end\n  \n  local function _assert(test,msg,...) if not test then error(fmt(msg,...),3) end end\n  \n  local function expandDate(w1,md)\n    local function resolve(id)\n      local res\n      if id == 'last' then month = md res=last[md]\n      elseif id == 'lastw' then month = md res=last[md]-6\n      else res= type(id) == 'number' and id or days[id] or months[id] or tonumber(id) end\n      _assert(res,\"Bad date specifier '%s'\",id) return res\n    end\n    local step = tonumber(1)\n    local w,m = w1[1],w1[2]\n    local start,stop = w:match(\"(%w+)%p(%w+)\")\n    if (start == nil) then return resolve(w) end\n    start,stop = resolve(start), resolve(stop)\n    local res,res2 = {},{}\n    if w:find(\"/\") then\n      if not w:find(\"-\") then -- 10/2\n        step=stop; stop = m.max\n      else step=(w:match(\"/(%d+)\")) end\n    end\n    step = tonumber(step)\n    _assert(start>=m.min and start<=m.max and stop>=m.min and stop<=m.max,\"illegal date intervall\")\n    while (start ~= stop) do -- 10-2\n      res[#res+1] = start\n      start = start+1; if start>m.max then start=m.min end\n    end\n    res[#res+1] = stop\n    if step > 1 then for i=1,#res,step do res2[#res2+1]=res[i] end; res=res2 end\n    return res\n  end\n  \n  local function parseDateStr(dateStr) --,last)\n    local map = table.map\n    local seq = string.split(dateStr,\" \")   -- min,hour,day,month,wday\n    local lim = {{min=0,max=59},{min=0,max=23},{min=1,max=31},{min=1,max=12},{min=1,max=7},{min=2000,max=3000}}\n    for i=1,6 do if seq[i]=='*' or seq[i]==nil then seq[i]=tostring(lim[i].min)..\"-\"..lim[i].max end end\n    seq = map(function(w) return string.split(w,\",\") end, seq)   -- split sequences \"3,4\"\n    local month0 = os.date(\"*t\",os.time()).month\n    seq = map(function(t) \n      local m = table.remove(lim,1);\n      return flatten(map(function (g) return expandDate({g,m},month0) end, t)) \n    end, seq) -- expand intervalls \"3-5\"\n    return map(seq2map,seq)\n  end\n  local sun,offs,day,sunPatch = dateStr0:match(\"^(sun%a+) ([%+%-]?%d+)\")\n  if sun then\n    sun = sun..\"Hour\"\n    dateStr0=dateStr0:gsub(\"sun%a+ [%+%-]?%d+\",\"0 0\")\n    sunPatch=function(dateSeq)\n      local h,m = (fibaro.getValue(1,sun)):match(\"(%d%d):(%d%d)\")\n      dateSeq[1]={[(tonumber(h)*60+tonumber(m)+tonumber(offs))%60]=true}\n      dateSeq[2]={[math.floor((tonumber(h)*60+tonumber(m)+tonumber(offs))/60)]=true}\n    end\n  end\n  local dateSeq = parseDateStr(dateStr0)\n  return function() -- Pretty efficient way of testing dates...\n    local t = os.date(\"*t\",os.time())\n    if month and month~=t.month then dateSeq=parseDateStr(dateStr0) end -- Recalculate 'last' every month\n    if sunPatch and (month and month~=t.month or day~=t.day) then sunPatch(dateSeq) day=t.day end -- Recalculate sunset/sunrise\n    return\n    dateSeq[1][t.min] and    -- min     0-59\n    dateSeq[2][t.hour] and   -- hour    0-23\n    dateSeq[3][t.day] and    -- day     1-31\n    dateSeq[4][t.month] and  -- month   1-12\n    dateSeq[5][t.wday] or false      -- weekday 1-7, 1=sun, 7=sat\n  end\nend\n\n--------------- Event engine -------------------\nlocal EventMT = { \n  __tostring = function(ev)\n    local s = json.encodeFast(ev)\n    return fmt(\"#%s{%s}\",ev.type,s:match(\",(.*)}\") or \"\") \n  end\n}\nER.EventMT = EventMT\n\nlocal function createEventEngine()\n  local self = {}\n  local HANDLER = '%EVENTHANDLER%'\n  local BREAK = '%BREAK%'\n  self.BREAK = BREAK\n  local handlers = {}\n  local function isEvent(e) return type(e) == 'table' and type(e.type)=='string' end\n  \n  local function coerce(x,y) local x1 = tonumber(x) if x1 then return x1,tonumber(y) else return x,y end end\n  local constraints = {}\n  constraints['=='] = function(val) return function(x) x,val=coerce(x,val) return x == val end end\n  constraints['<>'] = function(val) return function(x) return tostring(x):match(val) end end\n  constraints['>='] = function(val) return function(x) x,val=coerce(x,val) return x >= val end end\n  constraints['<='] = function(val) return function(x) x,val=coerce(x,val) return x <= val end end\n  constraints['>'] = function(val) return function(x) x,val=coerce(x,val) return x > val end end\n  constraints['<'] = function(val) return function(x) x,val=coerce(x,val) return x < val end end\n  constraints['~='] = function(val) return function(x) x,val=coerce(x,val) return x ~= val end end\n  constraints[''] = function(_) return function(x) return x ~= nil end end\n  \n  local function compilePattern2(pattern)\n    if type(pattern) == 'table' then\n      if pattern._var_ then return end\n      for k,v in pairs(pattern) do\n        if type(v) == 'string' and v:sub(1,1) == '$' then\n          local var,op,val = v:match(\"$([%w_]*)([<>=~]*)(.*)\")\n          var = var ==\"\" and \"_\" or var\n          local c = constraints[op](tonumber(val) or val)\n          pattern[k] = {_var_=var, _constr=c, _str=v}\n        else compilePattern2(v) end\n      end\n    end\n    return pattern\n  end\n  \n  local function compilePattern(pattern)\n    pattern = compilePattern2(copy(pattern))\n    assert(pattern)\n    if pattern.type and type(pattern.id)=='table' and not pattern.id._constr then\n      local m = {}; for _,id in ipairs(pattern.id) do m[id]=true end\n      pattern.id = {_var_='_', _constr=function(val) return m[val] end, _str=pattern.id}\n    end\n    return pattern\n  end\n  self.compilePattern = compilePattern\n  \n  local function match(pattern0, expr0)\n    local matches = {}\n    local function unify(pattern,expr)\n      if pattern == expr then return true\n      elseif type(pattern) == 'table' then\n        if pattern._var_ then\n          local var, constr = pattern._var_, pattern._constr\n          if var == '_' then return constr(expr)\n          elseif matches[var] then return constr(expr) and unify(matches[var],expr) -- Hmm, equal?\n          else matches[var] = expr return constr(expr) end\n        end\n        if type(expr) ~= \"table\" then return false end\n        for k,v in pairs(pattern) do if not unify(v,expr[k]) then return false end end\n        return true\n      else return false end\n    end\n    return unify(pattern0,expr0) and matches or false\n  end\n  self.match = match\n  \n  local function invokeHandler(env)\n    local t = os.time()\n    env.last,env.rule.time = t-(env.rule.time or 0),t\n    local status, res = pcall(env.rule.action,env) -- call the associated action\n    if not status then\n      --if type(res)=='string' and not debugFlags.extendedErrors then res = res:gsub(\"(%[.-%]:%d+:)\",\"\") end\n      --fibaro.errorf(nil,\"in %s: %s\",env.rule.doc,res)\n      env.rule._disabled = true -- disable rule to not generate more errors\n      fibaro.error(__TAG,res)\n      --em.stats.errors=(em.stats.errors or 0)+1\n    else return res end\n  end\n  \n  local toTime = self.toTime\n  function self.post(ev,t,log,hook,customLog)\n    local now,isEv = os.time(),isEvent(ev)\n    t = type(t)=='string' and toTime(t) or t or 0\n    if t < 0 then return elseif t < now then t = t+now end\n    if debugFlags.post and (type(ev)=='function' or not ev._sh) then\n      if isEv and not getmetatable(ev) then setmetatable(ev,EventMT) end\n      (customLog or fibaro.trace)(__TAG,fmt(\"Posting %s at %s %s\",tostring(ev),os.date(\"%c\",t),type(log)=='string' and (\"(\"..log..\")\") or \"\"))\n    end\n    if type(ev) == 'function' then\n      return setTimeout(function() ev(ev) end,1000*(t-now)),t\n    elseif isEv then\n      if not getmetatable(ev) then setmetatable(ev,EventMT) end\n      return setTimeout(function() if hook then hook() end self.handleEvent(ev) end,1000*(t-now)),t\n    else\n      error(\"post(...) not event or fun;\"..tostring(ev))\n    end\n  end\n  \n  function self.cancel(id) clearTimeout(id) end\n  \n  local toHash,fromHash={},{}\n  fromHash['device'] = function(e) return {\"device\"..e.id..e.property,\"device\"..e.id,\"device\"..e.property,\"device\"} end\n  fromHash['global-variable'] = function(e) return {'global-variable'..e.name,'global-variable'} end\n  fromHash['quickvar'] = function(e) return {\"quickvar\"..e.id..e.name,\"quickvar\"..e.id,\"quickvar\"..e.name,\"quickvar\"} end\n  fromHash['profile'] = function(e) return {'profile'..e.property,'profile'} end\n  fromHash['weather'] = function(e) return {'weather'..e.property,'weather'} end\n  fromHash['custom-event'] = function(e) return {'custom-event'..e.name,'custom-event'} end\n  fromHash['deviceEvent'] = function(e) return {\"deviceEvent\"..e.id..e.value,\"deviceEvent\"..e.id,\"deviceEvent\"..e.value,\"deviceEvent\"} end\n  fromHash['sceneEvent'] = function(e) return {\"sceneEvent\"..e.id..e.value,\"sceneEvent\"..e.id,\"sceneEvent\"..e.value,\"sceneEvent\"} end\n  toHash['device'] = function(e) return \"device\"..(e.id or \"\")..(e.property or \"\") end\n  \n  toHash['global-variable'] = function(e) return 'global-variable'..(e.name or \"\") end\n  toHash['quickvar'] = function(e) return 'quickvar'..(e.id or \"\")..(e.name or \"\") end\n  toHash['profile'] = function(e) return 'profile'..(e.property or \"\") end\n  toHash['weather'] = function(e) return 'weather'..(e.property or \"\") end\n  toHash['custom-event'] = function(e) return 'custom-event'..(e.name or \"\") end\n  toHash['deviceEvent'] = function(e) return 'deviceEvent'..(e.id or \"\")..(e.value or \"\") end\n  toHash['sceneEvent'] = function(e) return 'sceneEvent'..(e.id or \"\")..(e.value or \"\") end\n  \n  \n  local MTrule = { __tostring = function(self) return fmt(\"SourceTriggerSub:%s\",self.event.type) end }\n  function self.addEventHandler(pattern,fun,doc)\n    if not isEvent(pattern) then error(\"Bad event pattern, needs .type field\") end\n    assert(type(fun)=='func'..'tion', \"Second argument must be Lua func\")\n    local cpattern = compilePattern(pattern)\n    local rule,hashKeys = {[HANDLER]=cpattern, event=pattern, action=fun, doc=doc},{}\n    if toHash[pattern.type] and pattern.id and type(pattern.id) == 'table' then\n      local oldid=pattern.id\n      for _,id in ipairs(pattern.id) do\n        pattern.id = id\n        hashKeys[#hashKeys+1] = toHash[pattern.type](pattern)\n        pattern.id = oldid\n      end\n    else hashKeys = {toHash[pattern.type] and toHash[pattern.type](pattern) or pattern.type} end\n    for _,hashKey in ipairs(hashKeys) do\n      handlers[hashKey] = handlers[hashKey] or {}\n      local rules,fn = handlers[hashKey],true\n      for _,rs in ipairs(rules) do -- Collect handlers with identical patterns. {{e1,e2,e3},{e1,e2,e3}}\n        if equal(cpattern,rs[1].event) then\n          rs[#rs+1] = rule\n          fn = false break\n        end\n      end\n      if fn then rules[#rules+1] = {rule} end\n    end\n    rule.enable = function() rule._disabled = nil return rule end\n    rule.disable = function() rule._disabled = true return rule end\n    return rule\n  end\n  \n  function self.removeEventHandler(rule)\n    local pattern,fun = rule.event,rule.action\n    local hashKey = toHash[pattern.type] and toHash[pattern.type](pattern) or pattern.type\n    local rules,i,j= handlers[hashKey] or {},1,1\n    while j <= #rules do\n      local rs = rules[j]\n      while i <= #rs do\n        if rs[i].action==fun then\n          table.remove(rs,i)\n        else i=i+i end\n      end\n      if #rs==0 then table.remove(rules,j) else j=j+1 end\n    end\n  end\n  \n  local callbacks = {}\n  function self.registerCallback(fun) callbacks[#callbacks+1] = fun end\n  \n  function self.handleEvent(ev,firingTime)\n    for _,cb in ipairs(callbacks) do cb(ev) end\n    \n    local hasKeys = fromHash[ev.type] and fromHash[ev.type](ev) or {ev.type}\n    for _,hashKey in ipairs(hasKeys) do\n      for _,rules in ipairs(handlers[hashKey] or {}) do -- Check all rules of 'type'\n        local i,m=1,nil\n        for j=1,#rules do\n          if not rules[j]._disabled then    -- find first enabled rule, among rules with same head\n            m = match(rules[i][HANDLER],ev) -- and match against that rule\n            break\n          end\n        end\n        if m then                           -- we have a match\n          for j=i,#rules do                 -- executes all rules with same head\n            local rule=rules[j]\n            if not rule._disabled then\n              if invokeHandler({event = ev, time = firingTime, p=m, rule=rule}) == BREAK then return end\n            end\n          end\n        end\n      end\n    end\n  end\n  \n  -- This can be used to \"post\" an event into this QA... Ex. fibaro.call(ID,'RECIEVE_EVENT',{type='myEvent'})\n  function QuickApp.RECIEVE_EVENT(_,ev)\n    assert(isEvent(ev),\"Bad argument to remote event\")\n    local time = ev.ev._time\n    ev,ev.ev._time = ev.ev,nil\n    setmetatable(ev,EventMT)\n    if time and time+5 < os.time() then fibaro.warning(__TAG,fmt(\"Slow events %s, %ss\",tostring(ev),os.time()-time)) end\n    self.post(ev)\n  end\n  \n  function self.postRemote(uuid,id,ev)\n    if ev == nil then\n      id,ev = uuid,id\n      assert(tonumber(id) and isEvent(ev),\"Bad argument to postRemote\")\n      ev._from,ev._time = plugin.mainDeviceId,os.time()\n      fibaro.call(id,'RECIEVE_EVENT',{type='EVENT',ev=ev}) -- We need this as the system converts \"99\" to 99 and other \"helpful\" conversions\n    else\n      -- post to slave box in the future\n    end\n  end\n  \n  return self\nend -- createEventEngine\n\nlocal function quickVarEvent(d,_,post)\n  local old={}; for _,v in ipairs(d.oldValue) do old[v.name] = v.value end\n  for _,v in ipairs(d.newValue) do\n    if not equal(v.value,old[v.name]) then\n      post({type='quickvar', id=d.id, name=v.name, value=v.value, old=old[v.name]})\n    end\n  end\nend\n\n-- There are more, but these are what I seen so far...\n\nlocal EventTypes = {\n  AlarmPartitionArmedEvent = function(d,_,post) post({type='alarm', property='armed', id = d.partitionId, value=d.armed}) end,\n  AlarmPartitionBreachedEvent = function(d,_,post) post({type='alarm', property='breached', id = d.partitionId, value=d.breached}) end,\n  AlarmPartitionModifiedEvent = function(d,_,post) print(json.encode(d)) end,\n  HomeArmStateChangedEvent = function(d,_,post) post({type='alarm', property='homeArmed', value=d.newValue}) end,\n  HomeDisarmStateChangedEvent = function(d,_,post) post({type='alarm', property='homeArmed', value=not d.newValue}) end,\n  HomeBreachedEvent = function(d,_,post) post({type='alarm', property='homeBreached', value=d.breached}) end,\n  WeatherChangedEvent = function(d,_,post) post({type='weather',property=d.change, value=d.newValue, old=d.oldValue}) end,\n  GlobalVariableChangedEvent = function(d,_,post) post({type='global-variable', name=d.variableName, value=d.newValue, old=d.oldValue}) end,\n  GlobalVariableAddedEvent = function(d,_,post) post({type='global-variable', name=d.variableName, value=d.value, old=nil}) end,\n  DevicePropertyUpdatedEvent = function(d,_,post)\n    if d.property=='quickAppVariables' then quickVarEvent(d,_,post)\n    else\n      post({type='device', id=d.id or d.deviceId, property=d.property, value=d.newValue, old=d.oldValue})\n    end\n  end,\n  CentralSceneEvent = function(d,_,post)\n    d.id,d.icon = d.id or d.deviceId,nil\n    post({type='device', property='centralSceneEvent', id=d.id, value={keyId=d.keyId, keyAttribute=d.keyAttribute}})\n  end,\n  SceneActivationEvent = function(d,_,post)\n    d.id = d.id or d.deviceId\n    post({type='device', property='sceneActivationEvent', id=d.id, value={sceneId=d.sceneId}})\n  end,\n  AccessControlEvent = function(d,_,post)\n    post({type='device', property='accessControlEvent', id=d.id, value=d})\n  end,\n  CustomEvent = function(d,_,post)\n    local value = api.get(\"/customEvents/\"..d.name)\n    post({type='custom-event', name=d.name, value=value and value.userDescription})\n  end,\n  PluginChangedViewEvent = function(d,_,post) post({type='PluginChangedViewEvent', value=d}) end,\n  WizardStepStateChangedEvent = function(d,_,post) post({type='WizardStepStateChangedEvent', value=d})  end,\n  UpdateReadyEvent = function(d,_,post) post({type='updateReadyEvent', value=d}) end,\n  DeviceRemovedEvent = function(d,_,post)  post({type='deviceEvent', id=d.id, value='removed'}) end,\n  DeviceChangedRoomEvent = function(d,_,post)  post({type='deviceEvent', id=d.id, value='changedRoom'}) end,\n  DeviceCreatedEvent = function(d,_,post)  post({type='deviceEvent', id=d.id, value='created'}) end,\n  DeviceModifiedEvent = function(d,_,post) post({type='deviceEvent', id=d.id, value='modified'}) end,\n  PluginProcessCrashedEvent = function(d,_,post) post({type='deviceEvent', id=d.deviceId, value='crashed', error=d.error}) end,\n  SceneStartedEvent = function(d,_,post)   post({type='sceneEvent', id=d.id, value='started'}) end,\n  SceneFinishedEvent = function(d,_,post)  post({type='sceneEvent', id=d.id, value='finished'})end,\n  SceneRunningInstancesEvent = function(d,_,post) post({type='sceneEvent', id=d.id, value='instance', instance=d}) end,\n  SceneRemovedEvent = function(d,_,post)  post({type='sceneEvent', id=d.id, value='removed'}) end,\n  SceneModifiedEvent = function(d,_,post)  post({type='sceneEvent', id=d.id, value='modified'}) end,\n  SceneCreatedEvent = function(d,_,post)  post({type='sceneEvent', id=d.id, value='created'}) end,\n  OnlineStatusUpdatedEvent = function(d,_,post) post({type='onlineEvent', value=d.online}) end,\n  ActiveProfileChangedEvent = function(d,_,post)\n    post({type='profile',property='activeProfile',value=d.newActiveProfile, old=d.oldActiveProfile})\n  end,\n  ClimateZoneChangedEvent = function(d,_,post) --ClimateZoneChangedEvent\n    if d.changes and type(d.changes)=='table' then\n      for _,c in ipairs(d.changes) do\n        c.type,c.id='ClimateZone',d.id\n        post(c)\n      end\n    end\n  end,\n  ClimateZoneSetpointChangedEvent = function(d,_,post) d.type = 'ClimateZoneSetpoint' post(d,_,post) end,\n  NotificationCreatedEvent = function(d,_,post) post({type='notification', id=d.id, value='created'}) end,\n  NotificationRemovedEvent = function(d,_,post) post({type='notification', id=d.id, value='removed'}) end,\n  NotificationUpdatedEvent = function(d,_,post) post({type='notification', id=d.id, value='updated'}) end,\n  RoomCreatedEvent = function(d,_,post) post({type='room', id=d.id, value='created'}) end,\n  RoomRemovedEvent = function(d,_,post) post({type='room', id=d.id, value='removed'}) end,\n  RoomModifiedEvent = function(d,_,post) post({type='room', id=d.id, value='modified'}) end,\n  SectionCreatedEvent = function(d,_,post) post({type='section', id=d.id, value='created'}) end,\n  SectionRemovedEvent = function(d,_,post) post({type='section', id=d.id, value='removed'}) end,\n  SectionModifiedEvent = function(d,_,post) post({type='section', id=d.id, value='modified'}) end,\n  QuickAppFilesChangedEvent = function(_) end,\n  ZwaveDeviceParametersChangedEvent = function(_) end,\n  ZwaveNodeAddedEvent = function(_) end,\n  RefreshRequiredEvent = function(_) end,\n  DeviceFirmwareUpdateEvent = function(_) end,\n  GeofenceEvent = function(d,_,post) post({type='location',id=d.userId,property=d.locationId,value=d.geofenceAction,timestamp=d.timestamp}) end,\n  DeviceActionRanEvent = function(d,e,post)\n    if e.sourceType=='user' then\n      post({type='user',id=e.sourceId,value='action',data=d})\n    elseif e.sourceType=='system' then\n      post({type='system',value='action',data=d})\n    end\n  end,\n}\n\nlocal aEventEngine = nil\n\nSourceTrigger = {}\nclass 'SourceTrigger'\nfunction SourceTrigger:__init()\n  self.refresh = RefreshStateSubscriber()\n  self.eventEngine = createEventEngine()\n  aEventEngine = self.eventEngine\n  local function post(event,firingTime)\n    setmetatable(event,EventMT)\n    if debugFlags.sourceTrigger then fibaro.trace(__TAG,fmt(\"SourceTrigger: %s\",tostring(event) // (debugFlags.truncLog or 80))) end\n    self.eventEngine.handleEvent(event,firingTime)\n  end\n  local function filter(ev)\n    if debugFlags.refreshEvents then\n      fibaro.trace(__TAG,fmt(\"RefreshEvent: %s:%s\",ev.type,json.encodeFast(ev.data)) // (debugFlags.truncLog or 80))\n    end\n    return true\n  end\n  local function handler(ev)\n    if EventTypes[ev.type] then\n      EventTypes[ev.type](ev.data,ev,post)\n    end\n  end\n  self.refresh:subscribe(filter,handler)\nend\nfunction SourceTrigger:run() self.refresh:run() end\nfunction SourceTrigger:subscribe(event,handler) --> subscription\n  return self.eventEngine.addEventHandler(event,handler)\nend\nfunction SourceTrigger:unsubscribe(subscription)\n  self.eventEngine.removeEventHandler(subscription)\nend\nfunction SourceTrigger:enableSubscription(subscription)\n  subscription.enable()\nend\nfunction SourceTrigger:disableSubscription(subscription)\n  subscription.disable()\nend\nfunction SourceTrigger:post(event,time,log,hook,customLog)\n  return self.eventEngine.post(event,time,log,hook,customLog)\nend\nfunction SourceTrigger:registerCallback(fun)\n  return self.eventEngine.registerCallback(fun)\nend\nfunction SourceTrigger:cancel(ref)\n  return self.eventEngine.cancel(ref)\nend\nfunction SourceTrigger:postRemote(id,event)\n  return self.eventEngine.postRemote(id,event)\nend\n\nER.toSeconds = toSeconds\nER.midnight = midnight\nER.getWeekNumber = getWeekNumber\nER.now = now\nER.between = between\nER.hm2sec = hm2sec\nER.toTime = toTime\nER.sunCalc = sunCalc\nER.dateTest = dateTest"},{"isMain":true,"isOpen":false,"name":"main","type":"lua","content":"--%%name:EventRunner6\n--%% offline:true\n--%%headers:include.txt\n--%%save:EventRunner6.fqa\n\nfunction QuickApp:main(er)\n  local rule,var = er.rule,er.variables\n  er.opts = { started = true, check = true, result = false, listTriggers=true}\n  \n  var.HT = {\n    kitchen = {\n      light = {\n        roof = 66,\n        window =  67,\n      },\n      sensor = {\n        roof = 68,\n      }\n    }\n  }\n\n  rule(\"HT.kitchen.sensor.roof:breached => HT.kitchen.light.roof:on\")\nend\n\nfunction QuickApp:onInit()\n  local er = fibaro.EventRunner(self)\n  self:debug(er)\n  er.start()\nend"},{"isMain":false,"isOpen":false,"name":"compiler","type":"lua","content":"fibaro.EventRunner = fibaro.EventRunner or { debugFlags = {} }\nlocal ER = fibaro.EventRunner\nlocal debugFlags = ER.debugFlags\n\nlocal fmt = string.format\n\nlocal FUNCSTR = \"funct\"..\"ion\"\n\nlocal function docify(c)\n  if type(c) ~= 'table' then return c end\n  if c.__doc then \n    return docify(c.__doc)\n  else\n    local r = {}\n    for k,v in pairs(c) do r[k] = docify(v) end\n    return r\n  end\nend\n\nlocal function CONTFUN(fun) \n  return setmetatable({ __continuationFun =true },{\n    __call = function(t,...) return fun(...) end\n  })\nend\n\nlocal function CONT(cont,doc) \n  return setmetatable({ __continuation = true, __doc = doc },{\n    __call = function(t,...) return cont(...) end,\n    __tostring = function(t) return (doc and json.encodeFast(docify(doc)) or \"\") end\n  })\nend\n\nlocal function isContFun(obj) return type(obj) == 'table' and obj.__continuationFun end\nlocal function isCont(obj) return type(obj) == 'table' and obj.__continuation end\n\nlocal function IF(test, t, f)\n  return CONT(function(cont,env)\n    test(function(res)\n      if res then\n        t(cont, env)\n      else\n        if f then f(cont, env) else cont(false) end\n      end\n    end, env)\n  end,{'if', test, t, f})\nend\n\nlocal function IFA(args)\n  return CONT(function(cont,env)\n    local function doTest(i)\n      if i > #args then\n        cont(true)\n        return\n      end\n      local test = args[i]\n      if not test.cond then test.body(cont, env)\n      else\n        test.cond(function(res)\n          if res then\n            test.body(cont, env)\n          else\n            doTest(i + 1)\n          end\n        end, env)\n      end\n      \n    end\n    doTest(1)\n  end,{'ifa',args})\nend\n\nlocal function AND(...)\n  local tests = {...}\n  return CONT(function(cont, env)\n    local function nextTest(index, res)\n      if index > #tests then\n        cont(res)\n      else\n        local test = tests[index]\n        if isCont(test) or type(test) == FUNCSTR then\n          test(function(res)\n            if res then\n              nextTest(index + 1, res)\n            else\n              cont(false)\n            end\n          end, env)\n        elseif test then \n          nextTest(index + 1, test)\n        else\n          cont(test)\n        end\n      end\n    end\n    nextTest(1, false)\n  end,{'and',tests})\nend\n\nlocal function OR(...)\n  local tests = {...}\n  return CONT(function(cont, env)\n    local function nextTest(index, res)\n      if index > #tests then\n        cont(res)\n      else\n        local test = tests[index]\n        if isCont(test) or type(test) == FUNCSTR then\n          test(function(res)\n            if res then \n              cont(res)\n            else\n              nextTest(index + 1, res)\n            end\n          end, env)\n        elseif test then \n          cont(test) \n        else\n          nextTest(index + 1, test)\n        end\n      end\n    end\n    nextTest(1, false)\n  end,{'or',tests})\nend\n\nlocal function WHILE(cond,body)\n  return CONT(function(cont, env)\n    local function loop()\n      cond(function(res)\n        if res then \n          body(function() setTimeout(loop,0) end,env)\n        else\n          cont(true) -- Exit the loop\n        end\n      end, env)\n    end\n    loop()\n  end,{'while',cond,body})\nend\n\nlocal function REPEAT(cond,body)\n  return CONT(function(cont, env)\n    local function loop()\n      body(function()\n        cond(function(res)\n          if not res then setTimeout(loop, 0)\n          else cont(true) end\n        end, env)\n      end,env)\n    end\n    loop()\n  end,{'repeat',cond,body})\nend\n\nlocal function LOOP(body) -- loop forever - needs break/return\n  return CONT(function(cont, env)\n    local function loop()\n      body(function() setTimeout(loop,0) end, env)\n    end\n    loop()\n  end,{'loop',body})\nend\n\nlocal function WAIT(time)\n  return CONT(function(cont, env)\n    if isCont(time) or type(time) == FUNCSTR then\n      time(function(t)\n        if type(t) ~= 'number' then env.error(\"Expected number, got: \"..tostring(t)) end\n        setTimeout(function()\n          cont(true)\n        end, t*1000)\n      end, env)\n      return\n    elseif tonumber(time) then\n      time = tonumber(time)\n    else\n      env.error(\"Expected number, got: \"..tostring(time))\n      return\n    end\n    setTimeout(function()\n      cont(true)\n    end, time*1000)\n  end,{'wait',time})\nend\n\nlocal function evalArgs(args, cont, env)\n  if #args == 0 then\n    cont({})\n  else\n    local results = {}\n    local function nextArg(index)\n      local arg = args[index]\n      if type(arg) == FUNCSTR or isCont(arg) then\n        arg(function(arg1,...)\n          if index == #args then\n            results[index] = arg1\n            for _,a in ipairs({...}) do \n              results[#results+1] = a\n            end\n            cont(results)\n          else\n            results[index] = arg1\n            nextArg(index + 1)\n          end\n        end, env)\n      else\n        results[index] = arg\n        nextArg(index + 1)\n      end\n    end\n\n    nextArg(1)\n  end\nend\n\nlocal function FRAME(expr)\n  return CONT(function(cont, env)\n    local __cont = function(...) env:popEnv() cont(...) end\n    env:pushEnv({__cont = {__cont}})\n    expr(__cont, env)\n  end,{'frame',expr})\nend\n\nlocal function BREAK()\n  return CONT(function(cont, env)\n    local frameCont = env:getVariable('__cont')\n    setTimeout(function() frameCont(true) end, 0)\n  end, {'break'})\nend\n\nlocal function PROGN(...)\n  local statements = {...}\n  return CONT(function(cont,env)\n    evalArgs(statements, function(values)\n      local val = true\n      if #values > 0 then val = values[#values] end\n      cont(val)\n    end,env)\n  end,{'progn',statements})\nend\n\nlocal function TABLE(args)\n  return CONT(function(cont, env)\n    local tbl = {}\n    local function nextVal(i)\n      if i > #args then\n        cont(tbl)\n      else\n        args[i].expr(function(key)\n          args[i].value(function(val)\n            tbl[key]=val\n            nextVal(i + 1)\n          end,env)\n        end,env)\n      end\n    end\n    nextVal(1)\n  end, {'table', args})\nend\n\nlocal function checkArgs(a,t1,b,t2,env)\n  if type(a) ~= t1 then env.error(\"Expected \"..t1..\", got: \"..tostring(a)) end\n  if type(b) ~= t2 then env.error(\"Expected \"..t2..\", got: \"..tostring(b)) end\nend\n\nlocal opFuns = {\n  ['add'] = function(a,b,env) checkArgs(a,'number',b,'number',env) return a + b end,\n  ['sub'] = function(a,b,env) checkArgs(a,'number',b,'number',env)return a - b end,\n  ['mul'] = function(a,b,env) checkArgs(a,'number',b,'number',env) return a * b end,\n  ['div'] = function(a,b,env) checkArgs(a,'number',b,'number',env) return a / b end,\n  ['mod'] = function(a,b,env) checkArgs(a,'number',b,'number',env )return a % b end,\n  ['pow'] = function(a,b,env) checkArgs(a,'number',b,'number',env) return a ^ b end,\n  ['eq'] = function(a,b,env) return a == b end,\n  ['neq'] = function(a,b,env) return a ~= b end,\n  ['lt'] = function(a,b,env) return a < b end,\n  ['lte'] = function(a,b,env) return a <= b end,\n  ['gt'] = function(a,b,env) return a > b end,\n  ['gte'] = function(a,b,env) return a >= b end,\n  ['betw'] = function(a,b,env) \n    checkArgs(a,'number',b,'number',env) \n    local ts = os.date(\"*t\")\n    local t = ts.hour*3600 + ts.min*60 + ts.sec\n    b = b >= a and b or b + 24*3600\n    t = t >= a and t or t + 24*3600\n    return a <= t and t <= b\n  end\n}\n\nlocal function BINOP(op,exp1,exp2)\n  return CONT(function(cont, env)\n    exp1(function(v1)\n      exp2(function(v2)\n        if opFuns[op] then\n          local res = opFuns[op](v1, v2, env)\n          cont(res)\n        else\n          env.error(\"Unknown operator: \" .. tostring(op))\n        end\n      end, env)\n    end, env)\n  end, {'binop', op, exp1, exp2})\nend\n\nlocal unOpFuns = {\n  add = function(v,a,b,env) return v+(a or b) end,\n  neg = function(v,a,b,env) return - v end,\n  sub = function(v,a,b,env) return a and a-v or v-b end,\n  mul = function(v,a,b,env) return v*(a or b) end,\n  div = function(v,a,b,env) return a and a/v or v/b  end,\n  daily = function(v,a,b,env)\n    local e = env.trigger\n    if not e then return env.error(\"No trigger in environment\") end\n    return e.type == 'Daily'  -- False if not a daily event triggering\n  end,\n  interv = function(v,a,b,env)\n    local e = env.trigger\n    if not e then return env.error(\"No trigger in environment\") end\n    return e.type == 'Interval'  -- False if not a daily event triggering\n  end,\n}\n\n\nlocal function UNOP(op, expr, v1, v2)\n  return CONT(function(cont, env)\n    expr(function(val)\n      if unOpFuns[op] then\n        local res = unOpFuns[op](val,v1,v2,env)\n        cont(res)\n      else\n        env.error(\"Unknown operator: \" .. tostring(op))\n      end\n    end, env)\n  end, {'unop', op, expr, v1, v2})\nend\n\n\nlocal function TIME() return function(c,_) c(os.date(\"%H:%M\")) end end\nlocal function CONST(n) \n  local c\n  c = CONT(function(cont,env) \n    if c.evalHook then c.evalHook(c,cont,env)\n    else cont(n) end\n  end, {'const', n})\n  return c\nend\n\nlocal function EVENT(ev)\n  return function(cont,env)\n    if type(ev) ~= 'table' then env.error(\"Bad type\") end\n    local vars = env.vars\n    if vars.trigger and vars.trigger.type == ev.type then\n      cont(true)\n    else\n      cont(false)\n    end\n  end\nend\n\nlocal function CALL(fun,...)\n  local args = {...}\n  return CONT(function(cont,env) -- Return value out of expr\n    fun(function(fval)\n      local isCont = isContFun(fval)\n      if isCont or type(fval) == FUNCSTR then\n        evalArgs(args, function(exprs)\n          if isCont then -- continuation\n            fval(cont,env,table.unpack(exprs)) \n          else\n            local res = {fval(table.unpack(exprs))}\n            cont(table.unpack(res))\n          end\n        end,env)\n      else env.error(fmt(\"%s: Expected function, got: %s\", fun, tostring(fval))) end\n    end, env)\n  end, {'call', fun, args})\nend\n\nlocal function GETPROP(prop,obj)\n  return CONT(function(cont,env)\n    obj(function(o)\n      local res = ER.executeGetProp(o,prop,env)\n      cont(res)\n    end,env)\n  end, {'getprop', prop, obj})\nend\n\nlocal function AREF(tab,key)\n  return CONT(function(cont,env) -- Return value out of expr\n    tab(function(t)\n      if type(t) == 'table' then\n        key(function(k)\n          cont(t[k])\n        end,env)\n      else env.error(\"Expected table, got: \"..tostring(t)) end\n    end,env)\n  end, {'aref', tab, key})\nend\n\nlocal function VAR(name) \n  return CONT(function(cont,env) \n    local val = env:getVariable(name)\n    cont(val)\n  end, {'var', name})\nend\n\nlocal function ASSIGNM(vars,exprs)\n  return CONT(function(cont,env) -- Return value out of expr\n    evalArgs(exprs, function(values)\n      local function nextAssign(i)\n        if i > #vars then cont(true)\n        else \n          vars[i](env,values[i],nextAssign,i+1)\n        end\n      end\n      nextAssign(1)\n    end,env)\n  end,{'assignm',vars,exprs})\nend\n\nlocal function LOCAL(vars,exprs)\n  return CONT(function(cont,env)\n    evalArgs(exprs, function(values)\n      for i,var in ipairs(vars) do\n        env:pushVariable(var, values[i])\n      end\n      cont(true)\n    end,env)\n  end, {'local', vars, exprs})\nend\n\nlocal function INCVAR(name, op, value)\n  return CONT(function(cont, env)\n    value(function(val)\n      local var = env:getVariable(name)\n      if tonumber(var)==nil then return env.error(\"Not a number: \"..tostring(name)) end\n      local newValue = opFuns[op](var,val)\n      env:setVariable(name, newValue)\n      cont(newValue)\n    end,env)\n  end, {'incvar', name, op, value})\nend\n\nlocal function VARARGSTABLE(name)\n  return CONT(function(cont, env)\n    local var = env:getVariable('...')\n    if type(var) == 'table' then\n      cont(var)\n    else\n      env.error(\"Expected table for varargs, got: \" .. tostring(var))\n    end\n  end, {'varargs', name})\nend\n\nlocal function cleanVars(t)\n  local vs = {}\n  while t do\n    local c = {}\n    for k,v in pairs(t) do\n      if k:sub(1,2) ~= '__' then c[k] = v[1] end\n    end\n    vs[#vs+1] = c\n    t = t.__parent\n  end\n  return vs\nend\n\nlocal function ASYNCFUN(fun) --- fun(cb,...)\n  return CONTFUN(function(cont, env, ...)\n    local timedout,ref = false,nil\n    local cb = function(...) clearTimeout(ref); if not timedout then cont(...) end end\n    local timeout = fun(cb,...)\n    timeout = tonumber(timeout) or 3000\n    ref = setTimeout(function() \n      timedout = true\n      env.error(\"Async function timeout after \"..timeout..\" ms\")\n    end, timeout)\n  end)\nend\n\nlocal function FUNC(params, body)\n  return CONT(function(cont,env) -- Return value out of expr\n    cont(CONTFUN(function(cont,env,...)\n      local __cont = function(...) \n         env:popEnv() cont(...)\n      end\n      env:pushEnv({__cont = {__cont}, __return = {__cont}})\n      local args = {...}\n      for i=1,#params-1 do\n        local param = params[i]\n        local value = args[i]\n        env:pushVariable(param,value)\n      end\n      local param = params[#params]\n      if param == '...' then\n        local vararg = {}\n        for i=#params,#args do vararg[#vararg+1] = args[i] end\n        env:pushVariable(param, vararg)\n      else\n        local value = args[#params]\n        env:pushVariable(param,value)\n      end\n      --print(json.encode(args),json.encodeFast(cleanVars(env.vars)))\n      body(__cont,env)\n    end))\n  end,{'func',params,body})\nend\n\nlocal function RETURN(...)\n  local args = {...}\n  return CONT(function(cont,env) -- Return value out of expr\n    local ret = env:getVariable('__return') or env.cont or cont\n    evalArgs(args, function(exprs)\n      --print(\"RET\", ret==cont, json.encodeFast(exprs),tostring(ret))\n      ret(table.unpack(exprs))\n    end, env)\n  end, {'return', args})\nend\n\nlocal function args2str(...) local r = {} for i,v in ipairs({...}) do r[i] =type(v)=='table' and json.encodeFast(v) or tostring(v) end return table.unpack(r) end\nER.args2str = args2str\n\nlocal function findVar(name,vars)\n  local lastEnv = vars\n  while vars do\n    local v = vars[name]\n    if v then return v else lastEnv = vars; vars = vars.__parent end\n  end\n  return nil,lastEnv\nend\nlocal function createEnv(cont,err,opts)\n  local env = { vars = opts.env or {}, error = err, cont = cont }\n  local globalEnv = opts.env\n  function env:pushVariable(name,value) local v = self.vars[name] if v then v[1]=value else self.vars[name] = {value} end end\n  function env:setVariable(name,val,global)\n    if global then \n      local v = globalEnv[name]\n      if v then v[1]=val else globalEnv[name] = {val} end\n    end\n    local v,last = findVar(name,self.vars) \n    if v then v[1]=val else last[name] = {val} end \n  end\n  function env:getVariable(name) \n    local v = findVar(name,self.vars)  \n    if v then return v[1] else return _G[name] end \n  end\n  function env:pushEnv(e) e = e or {} e.__parent = self.vars; self.vars = e end\n  function env:popEnv() self.vars = self.vars.__parent or {} end\n  return env\nend\nER.createEnv = createEnv\n\nlocal function RULE(expr,opts) return function() return ER.defRule(expr,opts) end end\nlocal function RULECHECK(rule) return \n  CONT(function(cont,env) \n    rule(function(...)\n      if env.check then env.check(env.rule,...) end\n      cont(...)\n    end,env) \n  end,{'rulecheck',rule}) \nend\n\nlocal function EXPR(expr,opts)\n  return function()\n    opts = opts or {}\n    local res = {}\n    local cont = opts.cont or function(...) \n      res = {...} \n      if not opts.nolog then print(args2str(...)) end \n    end\n    local src = opts.src or \"<expr>\"\n    local err = opts.err or function(str) print(fmt(\"❌ '%s': %s\", src // 80,str)) end\n    local env = createEnv(cont, err, opts)\n    env.src = src\n    expr(cont, env)\n    return table.unpack(res)\n  end\nend\n\nlocal funs = {\n  IF = IF,\n  AND = AND,\n  OR = OR,\n  WAIT = WAIT,\n  PROGN = PROGN,\n  TIME = TIME,\n  CONST = CONST,\n  AREF = AREF,\n  BINOP = BINOP,\n  CALL = CALL,\n  EVENT = EVENT,\n  RULE = RULE\n}\n\nlocal compa, comp = function(_) end, {}\n\nlocal function compileList(list) local r = {} for _,e in ipairs(list) do r[#r+1] = compa(e) end return r end\n\nfunction comp.table(expr)\n  if expr.const then return CONST(expr.value) end\n  local args = {}\n  for _,v in ipairs(expr.value) do\n    local key = v.key and {type='const',value=v.key} or v.expr\n    args[#args+1] = { expr = compa(key), value = compa(v.value) }\n  end\n  return TABLE(args)\nend\n\nlocals = {}\nlocal function pushLocals(ls) ls.__parent = locals; locals = ls end\nlocal function popLocals() locals = locals.__parent end\nlocal function isLocal(name) return locals and locals[name] end\n\nfunction comp.block(expr,noframe)\n  if expr.locals then pushLocals(expr.locals) end\n  local args = compileList(expr.statements)\n  if expr.locals then popLocals() end\n  noframe = noframe or not expr.scope\n  if #args == 1 then return noframe and args[1] or FRAME(args[1]) end\n  return noframe and PROGN(table.unpack(args)) or FRAME(PROGN(table.unpack(args)))\nend\n\nfunction comp.binop(expr)\n  local exp1 = compa(expr.exp1)\n  local exp2 = compa(expr.exp2)\n  return BINOP(expr.op, exp1, exp2)\nend\n\nfunction comp.seqop(expr)\n  local args = compileList(expr.exprs)\n  if expr.op == 'or' then return OR(table.unpack(args))\n  elseif expr.op == 'and' then return AND(table.unpack(args))\n  else error(\"Unknown seqop: \"..tostring(expr.op)) \n  end\nend\n\nfunction comp.unop(expr)\n  return UNOP(expr.op, compa(expr.exp), expr.a, expr.b)\nend\n\nlocal builtin = { wait = 'WAIT' }\nlocal BUILTIN = function(name)\n  if builtin[name] then return funs[builtin[name]] end\n  return nil\nend\n\ncomp['break'] = function(expr)\n  return BREAK()\nend\n\ncomp['breakif'] = function(expr)\n  return IF(compa(expr.cond), BREAK())\nend\n\nfunction comp.call(expr)\n  local args = compileList(expr.args)\n  local fun = expr.fun.type == 'name' and BUILTIN(expr.fun.value) \n  if fun then return fun(table.unpack(args))\n  else\n    fun = compa(expr.fun)\n    return CALL(fun, table.unpack(args))\n  end\nend\n\nfunction comp.name(expr) \n  return VAR(expr.value) \nend\n\ncomp['return'] = function(expr)\n  local args = compileList(expr.exp)\n  return RETURN(table.unpack(args))\nend\n\n\ncomp['if'] = function(expr)\n  local args = {}\n  for _,c in ipairs(expr.args) do\n    args[#args+1] = { cond = c.cond and compa(c.cond) or nil, body = compa(c.body) }\n  end\n  return IFA(args)\nend\n\nlocal function condFRAME(frame,expr)\n  return frame and FRAME(expr) or expr\nend\n\ncomp['while'] = function(expr)\n  local frame,locals = expr.body.scope,expr.body.locals; expr.body.scope = nil\n  return condFRAME(frame,WHILE(compa(expr.cond), compa(expr.body)))\nend\ncomp['repeat'] = function(expr)\n  local frame,locals = expr.body.scope,expr.body.locals; expr.body.scope = nil\n  return condFRAME(frame,REPEAT(compa(expr.cond), compa(expr.body)))\nend\n\ncomp['loop'] = function(expr)\n  local args = compileList(expr.statements)\n  if #args == 1 then return LOOP(args[1]) end\n  return LOOP(PROGN(table.unpack(args)))\nend\n\nfunction comp.num(expr) return CONST(expr.value) end\nfunction comp.const(expr) return CONST(expr.value) end\nfunction comp.str(expr) return CONST(expr.value) end\n\nfunction comp.aref(expr)\n  local table = compa(expr.tab)\n  \n  local key = compa({type='num',value=expr.idx})\n  return AREF(table, key)\nend\n\ncomp['local'] = function(expr)\n  return LOCAL(expr.names,compileList(expr.exprs or {}))\nend\n\nfunction comp.assign(expr)\n  local exprs = compileList(expr.exprs)\n  local vars = {}\n  for _,v in ipairs(expr.vars) do\n    if v.type == 'name' then\n      local var = v.value\n      vars[#vars+1] = function(env,val,cont,i) env:setVariable(var,val,not isLocal(var)) cont(i) end--{type='var',value=v.value}\n    elseif v.type == 'aref' then\n      local var = {tab=compa(v.tab), idx=v.idx}\n      vars[#vars+1] = function(env,val,cont,i) --{type='aref',tab=compa(v.tab), idx=v.idx}\n        var.tab(function(tab)\n          tab[v.idx] = val\n          cont(i)\n        end,env)\n      end\n    elseif v.type == 'getprop' then\n      local var = {obj=compa(v.obj), prop=v.prop}\n      vars[#vars+1] = function(env,val,cont,i)\n        var.obj(function(obj)\n          ER.executeSetProp(obj,var.prop,val,env)\n          cont(i)\n        end,env)\n      end\n    else\n      error(\"Not supported assignment: \"..tostring(v.type))\n    end\n  end\n  return ASSIGNM(vars, exprs)\nend\n\nfunction comp.incvar(expr) return INCVAR(expr.name,expr.op,compa(expr.value)) end\n\nfunction comp.getprop(expr) return GETPROP(expr.prop,compa(expr.obj)) end\n\nlocal function makeVarAssign(var) return function(env,val,cont,i) env:setVariable(var,val) cont(i) end end\n\nfunction comp.functiondef(expr)\n  local fun = compa(expr.fun)\n  return ASSIGNM({makeVarAssign(expr.name[1])},{fun})\nend\n\ncomp['function'] = function(expr)\n  local fun = compa(expr.body)\n  return FRAME(FUNC(expr.params, fun))\nend\n\ncomp['functionexpr'] = function(expr) return compa(expr.fun) end\n\ncomp['varargstable'] = function(expr) return VARARGSTABLE() end\n\nfunction compa(expr)\n  if comp[expr.type] then return comp[expr.type](expr)\n  else error(\"Not implemented:\"..tostring(expr.type)) end\nend\n\nfunction compile(ast)\n  if ast.type == 'block' then\n    return comp.block(ast,true)\n  elseif ast.type == 'ruledef' then\n    local head = ast.head\n    local body = ast.body\n    local h = compa(head)\n    local b = compa(body)\n    return IF(RULECHECK(h),b)\n  else error(\"Not implemented:\"..tostring(ast.type)) end\nend\n\nlocal function idfun() end\n\nlocal function eval(str,opts)\n  assert(type(str) == \"string\",\"Expected string\")\n  opts = opts or {}\n  local isRule = false\n  local stat,ast = xpcall(function()\n    local tkns = ER.tokenize(str)\n    if opts.tkns then tkns.dump() end\n    if tkns.containsType('t_rule') then\n      table.insert(tkns.stream,1,{type='t_rulebegin',dbg={from=0,to=0}})\n      table.insert(tkns.stream,{type='t_ruleend',dbg={from=0,to=0}})\n      isRule = true\n    end\n    ast,j,k = ER.parse(tkns)\n    return ast\n  end,function(e)\n    local info = debug.getinfo(2)\n    dbg = debug.traceback()\n    return e\n  end)\n  if not stat then print(ast) return idfun end\n  if opts.tree then print(json.encodeFormated(ast)) end\n  locals = nil\n  local cont = compile(ast)\n  opts.src = ast._src\n  return isRule and RULE(cont,opts) or EXPR(cont,opts)\nend\n\nER.compile = compile\nER.eval = eval\nER.ASYNCFUN = ASYNCFUN"},{"isMain":false,"isOpen":false,"name":"rule","type":"lua","content":"local version = \"1.0.0\"\n\nfibaro.EventRunner = fibaro.EventRunner or { debugFlags = {} }\nlocal ER = fibaro.EventRunner\nlocal debugFlags = ER.debugFlags\nlocal sourceTrigger\n\nlocal fmt  = string.format\nlocal function printf(...) print(string.format(...)) end\nlocal findTriggers, evalArg\nlocal Rules,RuleEnv = {},{}\nlocal catch = math.huge\nlocal idFun = function() end\nER.rules = Rules\n\nlocal function INFO(...) fibaro.debug(__TAG,fmt(...)) end\nlocal function ERROR(...) fibaro.error(__TAG,fmt(...)) end\nlocal function WARNING(...) fibaro.warning(__TAG,fmt(...)) end\n\nlocal emoji = {\n  high_voltage = \"⚡\",\n  clock = \"🕒\",\n  check = \"✅\",\n  clip_board = \"📋\",\n  clapper_board = \"🎬\",\n  start_flag = \"🚦\",\n  stop_flag = \"🛑\",\n  checkered_flag = \"🏁\",\n  no_entry = \"⛔\",\n  thumbs_up = \"👍\",\n  thumbs_down = \"👎\"\n}\n\nlocal function mkEvent(ev) return setmetatable(ev, ER.EventMT) end\n\nlocal RuleMT = {\n  __tostring = function(r) return fmt(\"[Rule:%d]\", r.id) end,\n}\n\nlocal function started_rule(self, event) INFO(\"🎬 %s: %s\", self, tostring(event)) end\nlocal function check_rule(rule, arg, ...) \n  if arg then INFO(\"👍 %s\", rule) else INFO(\"👎 %s\", rule) end\nend\nlocal function result_rule(rule, ...) \n  local res = {ER.args2str(...)}\n  local rstr = #res>0 and table.concat(res,\", \") or \"<nil>\"\n  INFO(\"📋 %s: %s\", rule, rstr) \nend\n\nlocal function createRule(expr, data, opts)\n  local self = { id = data.id, triggers = data.triggers, daily = data.daily, interval = data.interval }\n  local opts = opts or {}\n  opts = table.copyShallow(opts)\n  opts.env = RuleEnv\n\n  if opts.started and type(opts.started) == 'boolean' then opts.started = started_rule end\n  if opts.check and type(opts.check) == 'boolean' then opts.check = check_rule end\n  if opts.result and type(opts.result) == 'boolean' then opts.result = result_rule end\n\n  opts.cont = function(...) if opts.result then opts.result(self,...) end end\n  opts.err = opts.err or function(str) ERROR(\"%s: %s\", self, str) end\n  self.env = ER.createEnv(opts.cont,opts.err,opts)\n  self.env.check = opts.check\n  self.env.rule = self\n\n  local dailyEvent = mkEvent({ type = 'Daily', id = self.id })\n  local intervalEvent = mkEvent({ type = 'Interval', id = self.id })\n  \n  if self.daily then\n    sourceTrigger:subscribe(dailyEvent,function(event) \n      self:start(event.event) \n      self:setupDaily(false,1) -- Every time we run/trigger we setup our daily triggers\n    end)\n  end\n  \n  if self.interval then\n    sourceTrigger:subscribe(intervalEvent,function(event) \n      self:start(event.event)\n    end)\n  end\n  \n  for _,t in ipairs(self.triggers) do\n    if t.type ~= 'Daily' and t.type ~= 'Interval' then\n      sourceTrigger:subscribe(t,function(event) \n        self:start(event.event)\n      end)\n    end\n  end\n  \n  function self:dumpTriggers()\n    printf(\"Rule %d triggers:\",self.id)\n    for i,t in ipairs(self.triggers) do print(fmt(\"⚡ %s\", json.encodeFast(t))) end\n    if self.daily then \n      evalArg(function(values)\n        for i,t in ipairs(values) do printf(\"🕒 %02d:%02d\",t//3600,t%3600//60) end\n      end, self.env, table.unpack(self.daily))\n    end\n  end\n  \n  if opts.listTriggers then self:dumpTriggers() end\n\n  local dailyTimers = {}\n  local function clearDailyTimers() for t,_ in ipairs(dailyTimers) do sourceTrigger:cancel(t) end; dailyTimers = {} end\n  \n  function self:setupDaily(start,skew)\n    local skew = skew or 0\n    clearDailyTimers()\n    if self.daily then\n      evalArg(function(values)\n        local now = ER.now()\n        if type(values) ~= 'table' then values = {values} end\n        if opts.log then INFO(\"Setting up daily trigger for rule %d at %s\", self.id, json.encodeFast(values)) end\n        local catchFlag,n = false,0\n        for _,t in ipairs(values) do n=n+1 if t == catch then catchFlag = true; break end end\n        for _,t in ipairs(values) do\n          if t ~= catch then\n            local torg = t\n            if type(t) ~= 'number' then return self.env.error(\"Invalid daily time: \"..tostring(t)) end\n            if t < now+skew then \n              t = t + 24*3600\n              if catchFlag and start then setTimeout(function() self:start(dailyEvent) end,0) end -- Catch up, run immediately\n            end\n            dailyTimers[(sourceTrigger:post({type='Daily',id=self.id,time=fmt(\"%02d:%02d\",torg//3600,torg%3600//60)},t-now))]=true\n          end\n        end\n      end, self.env, table.unpack(self.daily))\n    end\n  end\n  \n  local intervalTimer\n  function self:setupInterval()\n    if intervalTimer then sourceTrigger:cancel(intervalTimer); intervalTimer = nil end\n    if self.interval then\n      self.interval(function(value)\n        if type(value) ~= 'number' then return self.env.error(\"Invalid interval time: \"..tostring(value)) end\n        local delay = 0\n        if value < 0 then value=-value delay = (os.time() // value + 1)*value - os.time() end\n        local nextTime = os.time() + delay\n        local function loop()\n          self:start(intervalEvent)\n          nextTime = nextTime + value\n          intervalTimer = setTimeout(loop, (nextTime-os.time())*1000)\n        end\n        intervalTimer = setTimeout(loop, (nextTime-os.time())*1000)\n      end, self.env)\n    end\n  end\n  \n  function self:start(event)\n    if opts.started then opts.started(self,event) end\n    local env = table.copyShallow(self.env)\n    env.trigger = event\n    expr(opts.cont,env)\n  end\n  \n  return setmetatable(self, RuleMT)\nend\n\nlocal function defRule(expr, opts)\n  local head = expr.__doc[2]\n  \n  local id = #Rules+1\n  local env = ER.createEnv(idFun,idFun,opts)\n  for k,v in pairs({\n    id = id,\n    triggers = {},\n    daily = nil,\n    interval = nil,\n    error = function(str) print(fmt(\"Error in rule %d: %s\", id, str)) os.exit() end,\n  }) do env[k] = v end\n  \n  local function cont()\n    triggers = env.triggers\n  end\n  \n  local function err(str) print(\"Error in rule header:\", str) end\n\n  findTriggers(head, cont, env)\n  -- return function(trigger)\n  --   local function cont(t) print(t and \"Rule was run\" or \"Rule was not run\") end\n  --   local function err(str) print(\"Error in rule:\", str) end\n  --   local env = createEnv(cont, err, opts) \n  --   env.vars.trigger = trigger\n  \n  --   expr(cont,env,opts)\n  -- end\n  if env.interval and env.daily then env.error(\"Only one @daily or @@interval per rule\") end\n  if env.daily then table.insert(env.triggers,{type='Daily',id=env.id}) end\n  \n  local rule = createRule(expr, env, opts)\n  rule:setupDaily(true)\n  rule:setupInterval()\n  Rules[#Rules+1] = rule\n  printf(\"✅ %s\",rule)\n  return rule\nend\n\nlocal function etype(c) return c.__doc[1] end\nlocal function earg(c,i) return c.__doc[1+i] end\nlocal function eargs(c) return table.unpack(c.__doc,2) end\n\nlocal function scanArg(cont, env, arg, ...)\n  local rest = {...}\n  findTriggers(arg,function() \n    if #rest > 0 then scanArg(cont, env, table.unpack(rest)) else cont() end\n  end, env)\nend\n\nlocal function evalArgAux(vals, cont, env, arg, ...)\n  local rest = {...}\n  arg(function(...) \n    for _,v in ipairs({...}) do vals[#vals+1] = v end\n    if #rest > 0 then evalArgAux(vals, cont, env, table.unpack(rest)) else cont(vals) end\n  end, env)\nend\nfunction evalArg(cont, env, ...) evalArgAux({}, cont, env, ...) end\n\nfunction findTriggers(c, cont, env)\n  local typ = etype(c)\n  if typ == 'unop' then\n    local op,arg = earg(c,1), earg(c,2)\n    if op == 'daily' then\n      if env.seenDaily then env.error(\"Only one @daily per rule\") end\n      env.seenDaily = true\n      evalArg(function(values) \n        if type(values) ~= 'table' then values={values} end\n        if env.daily == nil then env.daily = values\n        else\n          for _,v in ipairs(values) do table.insert(env.daily,v) end\n        end\n      end, env, arg)\n    elseif op == 'interv' then\n      table.insert(env.triggers,{type='Interval',id=env.id})\n      if env.interval then env.error(\"Only one @interv per rule\") end\n      env.interval = arg \n    end\n    scanArg(cont, env, arg)\n  elseif typ == 'and' or typ == 'or' then \n    scanArg(cont, env, table.unpack(eargs(c)))\n  elseif typ == 'getprop' then\n    local prop = earg(c,1)\n    local pv = ER.getProps[prop]\n    assert(pv, \"Unknown property in getprop trigger: \"..prop)\n    if not pv[5] then return cont() end\n    local obj = earg(c,2)\n    obj(function(value)\n      if tonumber(value) then\n        table.insert(env.triggers,{type=pv[1],id=value,property=pv[3]})\n      elseif type(value) == 'table' then\n        for _,id in ipairs(value) do\n          table.insert(env.triggers,{type=pv[1],id=id,property=pv[3]})\n        end\n      else\n        env.error(\"Invalid object in getprop trigger: \"..json.encodeFast(value))\n      end\n      cont()\n    end,env)\n  elseif typ == 'const' then\n    local t = earg(c,1)\n    if type(t) == 'table' and type(t.type) == 'string' then\n      c.evalHook = function(c,cont,env) \n        if not env.trigger then return cont(false) end\n        cont(table.equal(env.trigger,t))\n      end\n      table.insert(env.triggers,t)\n    end\n    cont()\n  elseif typ == 'binop' then\n    local op,a1,a2 = earg(c,1), earg(c,2), earg(c,3) -- ToDo: Add 1 to a2\n    if op == 'betw' then\n      if env.daily == nil then env.daily = {a1,a2}\n      else \n        for _,v in ipairs({a1,a2}) do table.insert(env.daily,v) end\n      end\n    end\n    scanArg(cont, env ,a1, a2)\n  elseif typ == 'rulecheck' then\n    scanArg(cont, env, earg(c,1))\n  else\n    print(\"Unsupported trigger type:\", etype(c), json.encodeFast(c))\n  end\nend\n\nER.defRule = defRule\n\nlocal _er\nfunction createER(qa)\n  if _er then return _er end\n  _er = { qa = qa }\n  ER._er = _er\n  sourceTrigger = SourceTrigger()\n  sourceTrigger:run()\n  \n  local env = {catch = catch}\n  for k,v in pairs(env) do RuleEnv[k] = {v} end\n  for k,v in pairs(ER.builtin) do RuleEnv[k] = {v} end\n\n  local async = setmetatable({},{\n    __index = function(t,k) local v = RuleEnv[k] return v and v[1] or nil end,\n    __newindex = function(t,k,f) local var = RuleEnv[k] if var then var[1] = ER.ASYNCFUN(f) else RuleEnv[k] = {ER.ASYNCFUN(f)} end end,\n  })\n\n  _er.variables = setmetatable({ async = async },{\n    __index = function(t,k) local v = RuleEnv[k] return v and v[1] or nil end,\n    __newindex = function(t,k,v) local var = RuleEnv[k] if var then var[1] = v else RuleEnv[k] = {v} end end,\n  })\n\n  function _er.rule(str,opts) \n    opts = opts or _er.opts or {} \n    opts.env = opts.env or RuleEnv\n    return ER.eval(str,opts)() \n  end\n  function _er.start() \n    print(\"=========== Loading rules ================\")\n    local t0 = os.clock()\n    _er.qa:main(_er) \n    printf(\"=========== Load time: %.3fs ============\",os.clock()-t0)\n  end\n  function _er.speed(time) return ER.speedTime(time,_er.start) end\n  function _er.post(event,time) return sourceTrigger:post(event,time) end\n  function _er.cancel(ref) return sourceTrigger:cancel(ref) end\n  _er.loadSimDevice = ER.loadSimDev\n  _er.eval = _er.rule -- alias\n  setmetatable(_er,{\n    __tostring = function() return fmt(\"EventRunner6 v%s\",version) end,\n  })\n  return _er\nend\n\nsetmetatable(ER,{\n  __tostring = function() return fmt(\"EventRunner6 v%s\",version) end,\n  __call = function(_,qa) return createER(qa) end\n})\n"},{"isMain":false,"isOpen":false,"name":"sim","type":"lua","content":"fibaro.EventRunner = fibaro.EventRunner or { debugFlags = {} }\nlocal ER = fibaro.EventRunner\nlocal debugFlags = ER.debugFlags\n\nlocal speed = {}\nlocal timeOffset = os.time() \nlocal fibdebug = fibaro.debug\nfunction speed.debug(...) \n  fibdebug(os.date(\"%Y-%m-%d %H:%M:%S\",speed.userTime()),...) \nend\nlocal _setTimeout,_clearTimeout,_setInterval,_clearInterval = setTimeout,clearTimeout,setInterval,clearInterval\nlocal _time,_date = os.time,os.date\n\nlocal orgTime,orgDate,timeOffset = os.time,os.date,0\n\nlocal function round(x) return math.floor(x+0.5) end\nfunction speed.userTime(a) \n  return a == nil and round(_time() + timeOffset) or _time(a) \nend\nlocal function userMilli() return _time() + timeOffset end\nfunction speed.userDate(a, b) \n  return b == nil and orgDate(a, speed.userTime()) or _date(a, round(b)) \nend\n\nlocal function getTimeOffset() return timeOffset end\nlocal function setTimeOffset(offs) timeOffset = offs end\n\nlocal function createQueue()\n  local self = {}\n  local times = nil -- linked list of sorted timers\n  \n  function self:add(t,fun,id)\n    local v = nil\n    v = {time=t,fun=fun,id=id}\n    if not times then times = v return v end\n    if t < times.time then\n      times.prev = v\n      v.next = times\n      times = v\n      return v\n    end\n    local p = times\n    while p.next and p.next.time < t do p = p.next end\n    v.next = p.next\n    if p.next then p.next.prev = v end\n    p.next = v\n    v.prev = p\n    return v\n  end\n  \n  function self:remove(v)\n    if v and not v.dead then\n      v.dead = true\n      if v.prev == nil then\n        times = v.next\n        if times then times.prev = nil end\n      elseif v.next == nil then\n        v.prev.next = nil\n      else\n        v.prev.next = v.next\n        v.next.prev = v.prev\n      end\n    end\n  end\n  \n  function self:pop() local t = times; if times then times.dead=true  times = times.next end return t end\n  function self:peek() return times end\n  return self\nend\n\nlocal timers = createQueue()\nlocal timerID = 0\nlocal timerIDs = {}\n\nfunction speed.setTimeout(fun,ms)\n  timerID = timerID + 1\n  local v = timers:add(speed.userTime()+ms/1000,fun,timerID)\n  timerIDs[timerID] = v\n  return timerID\nend\n\nfunction speed.clearTimeout(ref)\n  if timerIDs[ref] then\n    timers:remove(timerIDs[ref])\n    timerIDs[ref] = nil\n  end\nend\n\nlocal intervID = 0\nlocal intervIDs = {}\n\nfunction speed.setInterval(fun,ms)\n  local function loop()\n    if not intervIDs[intervID] then return end\n    fun()\n    if not intervIDs[intervID] then return end\n    intervIDs[intervID] = speed.setTimeout(loop,ms)\n  end\n  intervID = intervID + 1\n  intervIDs[intervID] = speed.setTimeout(loop,ms)\n  return intervID\nend\n\nfunction speed.clearInterval(ref)\n  if intervIDs[ref] then\n    speed.clearTimout(intervIDs[ref])\n    intervIDs[ref] = nil\n  end\nend\n\nlocal running = false\nfunction speed.loop()\n  if running then return end\n  running = true\n  while speed.userTime() <= speed.stopTime do\n    local t = timers:pop()\n    if not t then break end\n    local offs = t.time - _time()\n    setTimeOffset(offs)\n    t.fun()\n  end\nend\n\nlocal id = 10000\nlocal function createDevice(path)\n  local code = fibaro.plua.lib.readFile(path)\n  local d = fibaro.plua.lib.loadQAString(code,{headers={\"desktop:false\"}})\n  return d.device.id\nend\n\nER.loadSimDev = createDevice\n\nfunction ER.speedTime(speedTime,fun)\n  speed.stopTime = os.time() + speedTime*3600\n  fibaro.debug = speed.debug\n  setTimeout = speed.setTimeout\n  clearTimeout = speed.clearTimeout\n  setInterval = speed.setInterval\n  clearInterval = speed.clearInterval\n  os.time = speed.userTime\n  os.date = speed.userDate\n  setTimeout(fun,0)\n  speed.loop()\nend"}],"apiVersion":"1.3","name":"EventRunner6","type":"com.fibaro.binarySwitch","initialInterfaces":{}}