{"type":"com.fibaro.genericDevice","name":"EventRunner6","apiVersion":"1.3","files":[{"type":"lua","name":"main","content":"--%%name:EventRunner6
--%%headers:src/include.txt
--%%u:{label='info', text='EventRunnner 6'}
--%%save:dist/EventRunner6.fqa
--%%offline:true

function QuickApp:main(er)
  local rule,var = er.rule,er.variables
  er.opts = { started = true, check = true, result = false, triggers=true}
  
  var.HT = {
    kitchen = {
      light = { roof = 66, window =  67, },
      sensor = { roof = 68, },
    },
  }

  rule(\"HT.kitchen.sensor.roof:breached => log('Roof sensor breached!'); HT.kitchen.light.roof:on\")
  rule(\"@@00:00:05 => log('Ding!')\")
end

function QuickApp:onInit()
  local er = fibaro.EventRunner(self)
  self:debug(er) 
  self:updateView('info','text',tostring(er))
  er.start()
end","isMain":true,"isOpen":false},{"type":"lua","name":"sim","content":"fibaro.EventRunner = fibaro.EventRunner or { debugFlags = {} }
local ER = fibaro.EventRunner
local debugFlags = ER.debugFlags

local speed = {}
local timeOffset = os.time() 
local fibdebug = fibaro.debug
function speed.debug(tag,...) 
  fibdebug(tag,os.date(\"%Y-%m-%d %H:%M:%S\",speed.userTime()),...) 
end
local _setTimeout,_clearTimeout,_setInterval,_clearInterval = setTimeout,clearTimeout,setInterval,clearInterval
local _time,_date = os.time,os.date

local orgTime,orgDate,timeOffset = os.time,os.date,0

local function round(x) return math.floor(x+0.5) end
function speed.userTime(a) 
  return a == nil and round(_time() + timeOffset) or _time(a) 
end
local function userMilli() return _time() + timeOffset end
function speed.userDate(a, b) 
  return b == nil and orgDate(a, speed.userTime()) or _date(a, round(b)) 
end

local function getTimeOffset() return timeOffset end
local function setTimeOffset(offs) timeOffset = offs end

local function createQueue()
  local self = {}
  local times = nil -- linked list of sorted timers
  
  function self:add(t,fun,id)
    local v = nil
    v = {time=t,fun=fun,id=id}
    if not times then times = v return v end
    if t < times.time then
      times.prev = v
      v.next = times
      times = v
      return v
    end
    local p = times
    while p.next and p.next.time < t do p = p.next end
    v.next = p.next
    if p.next then p.next.prev = v end
    p.next = v
    v.prev = p
    return v
  end
  
  function self:remove(v)
    if v and not v.dead then
      v.dead = true
      if v.prev == nil then
        times = v.next
        if times then times.prev = nil end
      elseif v.next == nil then
        v.prev.next = nil
      else
        v.prev.next = v.next
        v.next.prev = v.prev
      end
    end
  end
  
  function self:pop() local t = times; if times then times.dead=true  times = times.next end return t end
  function self:peek() return times end
  return self
end

local timers = createQueue()
local timerID = 0
local timerIDs = {}

function speed.setTimeout(fun,ms)
  timerID = timerID + 1
  local v = timers:add(speed.userTime()+ms/1000,fun,timerID)
  timerIDs[timerID] = v
  return timerID
end

function speed.clearTimeout(ref)
  if timerIDs[ref] then
    timers:remove(timerIDs[ref])
    timerIDs[ref] = nil
  end
end

local intervID = 0
local intervIDs = {}

function speed.setInterval(fun,ms)
  local function loop()
    if not intervIDs[intervID] then return end
    fun()
    if not intervIDs[intervID] then return end
    intervIDs[intervID] = speed.setTimeout(loop,ms)
  end
  intervID = intervID + 1
  intervIDs[intervID] = speed.setTimeout(loop,ms)
  return intervID
end

function speed.clearInterval(ref)
  if intervIDs[ref] then
    speed.clearTimout(intervIDs[ref])
    intervIDs[ref] = nil
  end
end

local running = false
function speed.loop()
  if running then return end
  running = true
  while speed.userTime() <= speed.stopTime do
    local t = timers:pop()
    if not t then break end
    local offs = t.time - _time()
    setTimeOffset(offs)
    --print(os.date(\"%Y-%m-%d %H:%M:%S\",speed.userTime()),\" Timer:\",t.id)
    t.fun()
  end
end

if fibaro.plua then
  local id = 10000
  local function createDevice(path)
    local p = os.getenv(\"DEVICELIB\") or \"\"
    local code = fibaro.plua.lib.readFile(p..path)
    local d = fibaro.plua.lib.loadQAString(code,{headers={\"desktop:false\"}})
    return d.device.id
  end
  ER.loadSimDev = createDevice
end
  
function ER.speedTime(speedTime,fun)
  speed.stopTime = os.time() + speedTime*3600
  fibaro.debug = speed.debug
  setTimeout = speed.setTimeout
  clearTimeout = speed.clearTimeout
  setInterval = speed.setInterval
  clearInterval = speed.clearInterval
  os.time = speed.userTime
  os.date = speed.userDate
  setTimeout(fun,0)
  speed.loop()
end","isMain":false,"isOpen":false},{"type":"lua","name":"parser","content":"
fibaro.EventRunner = fibaro.EventRunner or { debugFlags = {} }
local ER = fibaro.EventRunner 
local debugFlags = ER.debugFlags

local fmt = string.format
local patterns = {}

ER._opers = {
  ['%neg']={op=false, prio=14, unop=true, trans='neg'},        -- unary minus
  ['t/']  ={op=true,  prio=14, unop=true, trans='today'},      -- today time constant, t/10:00
  ['n/']  ={op=true,  prio=14, unop=true, trans='next'},       -- next today time constant, n/10:00
  ['+/']  ={op=true,  prio=14, unop=true, trans='plus'},       -- from today time constant, +/10:00
  ['$']   ={op=true,  prio=14, unop=true, trans='gv'},         -- global variable, $var
  ['$$']  ={op=true,  prio=14, unop=true, trans='qv'},         -- quickApp variable, $var
  ['$$$']  ={op=true,  prio=14,unop=true, trans='pv'},         -- Persistent variable, $var
  ['..']  ={op=true,  prio=9,             trans='betw'},       -- between operator, 10:00..11:00
  ['...'] ={op=true,  prio=9,             trans='betwo'},  
  ['@']   ={op=true,  prio=9,  unop=true, trans='daily'},      -- day rule, @10:00
  ['@@']  ={op=true,  prio=9,  unop=true, trans='interv'},     -- interval rule, @@00:05
  ['+']   ={op=true, prio=11,             trans='add'},
  ['-']   ={op=true, prio=11,             trans='sub'},
  ['*']   ={op=true, prio=12,             trans='mul'},
  ['/']   ={op=true, prio=12,             trans='div'},
  ['++']  ={op=true, prio=10,             trans='conc'},         -- string concatenation
  ['==='] ={op=true, prio=9,              trans='match'},        -- string match
  ['%']   ={op=true, prio=12,             trans='mod'},          -- modulo
  ['^']   ={op=true, prio=12,             trans='pow'},          -- power
  ['==']  ={op=true, prio=6,              trans='eq'},           -- equal
  ['<=']  ={op=true, prio=6,              trans='lte'},
  ['>=']  ={op=true, prio=6,              trans='gte'},
  ['~=']  ={op=true, prio=6,              trans='neq'},          -- not equal
  ['>']   ={op=true, prio=6,              trans='gt'},
  ['<']   ={op=true, prio=6,              trans='lt'},
  ['&']   ={op=true, prio=5,              trans='and'},        -- logical and
  ['|']   ={op=true, prio=4,              trans='or'},         -- logical or
  ['??']  ={op=true, prio=4,              trans='nilco'},      -- nil coalescing
  ['!']   ={op=true, prio=5.1, unop=true, trans='not'},        -- logical not
--  ['in']  ={op=true, prio=0.1,            trans='in'},
  ['=']   ={op=true, prio=0,              trans='assign'},       -- assignment
}
local keyword={
  ['if']='t_if',['then']='t_then',['else']='t_else',['elseif']='t_elseif',['end']='t_end',['while']='t_while',
  ['repeat']='t_repeat',['do']='t_do',['until']='t_until',['return']='t_return',['for']='t_for',['fun'..'ction']='t_function',
  ['local']='t_local',['break']='t_break',['in']='t_in',['||']='t_||', ['>>']='t_>>',['case']='t_case',
  ['+=']='t_addinc',['-=']='t_subinc',['*=']='t_mulinc',['/=']='t_divinc',
  ['=>']='t_rule',
  ['true']='t_true',['false']='t_false',['nil']='t_nil',
  [';'] = 't_semi',[',']='t_comma',['.']='t_dot',[':']='t_ddot',
  [')'] = 't_rpar',['(']='t_lpar',['}']='t_rcur',['{']='t_lcur',['[']='t_lbra',[']']='t_rbra',
}
local opers0 = ER._opers
local opers1 = {} for k,v in pairs(opers0) do opers1[v.trans] = v end
ER._opers1 = opers1

local function calcLineOffs(lines, pos)
  local line,offs,llength = 1,0,0
  for i, l in ipairs(lines) do
    local len = #l + 1
    if pos <= offs + len then
      line = i; llength = #l
      break
    end
    offs = offs + len
  end
  return line, pos - offs, llength
end

local TKMT = {__tostring = function (err) 
  if type(err) == 'string' then return err end
  local src = err.src or \"\"
  local lines,buff = {},{}
  for line in src:gmatch(\"([^\\n]*)\\n?\") do lines[#lines+1]=line end
  local startline,startoffs,startLength = calcLineOffs(lines, err.from)
  local endline,endoffs,endLength = calcLineOffs(lines, err.to)
  if startline == endline then
    local line = lines[startline] or \"\"
    local ptr = string.rep('&nbsp;',startoffs-1)..fmt(\"<font color='orange'>%s</font>\",string.rep('^',endoffs-startoffs+1))
    buff[#buff+1] = fmt(\"%s: %s at pos %d\",err.type,err.msg,err.from)
    if startline > 1 then buff[#buff+1] = lines[1] end
    buff[#buff+1] = line
    buff[#buff+1] = ptr
    return table.concat(buff,\"<br>\")
  end
end}

local function createError(typ,msg,from,to,src,mt)
  return setmetatable({type=typ, msg=msg, from=from, to=to, src=src, _err=true},mt or TKMT)
end
local function perror(typ,msg,from,to,src,mt) error(createError(typ,msg,from,to,src,mt)) end
ER.createParseError = createError
ER.perror = perror

local function stream(tab,src)
  local p,self=0,{ stream=tab, eof={type='t_eof', value='', dbg={from=tab[#tab].dbg.from, to=tab[#tab].dbg.to}} }
  self.src = src
  function self.getP() return p end
  function self.setP(np) p=np end
  function self.next() p=p+1 local r = p<=#tab and tab[p] or self.eof; return r end
  function self.last() return tab[p] or self.eof end
  function self.prev() return tab[p-1] or self.eof end
  function self.matchp(t,v) 
    local t2 = self.peek()
    if t2[t]==v then self.next() return t2 end 
  end
  function self.pushBack() p=p-1 end
  function self.matchpt(v) return self.matchp('type',v) end
  function self.match(t,v,m)
    local r = self.matchp(t,v)
    if r then return r end
    if self.error then self.error(self,self.peek(),m or fmt('expected %s (got %s)',v,self.peek().type)) end
    error(m or fmt('expected %s (got %s)',v,self.peek()[t]),2) 
  end 
  function self.matcht(v,m) return self.match('type',v,m) end 
  function self.peek(n) return tab[p+(n or 1)] or self.eof end
  function self.containsOp(op) for _,t in ipairs(tab) do if t.opval == op then return true end end end
  function self.containsType(typ) for _,t in ipairs(tab) do if t.type == typ then return true end end end
  function self.dump(env) 
    local pr = env and env.print or print 
    for _,t in ipairs(tab) do pr(json.encode(t)) end 
  end
  return self
end

local GCTX
local function toTimeDate(str)
  local y,m,d,h,min,s=str:match(\"(%d?%d?%d?%d?)/?(%d+)/(%d+)/(%d%d):(%d%d):?(%d?%d?)\")
  local stat,res = pcall(function()
    local t = os.date(\"*t\")
    return os.time{year=y~=\"\" and y or t.year,month=m,day=d,hour=h,min=min,sec=s~=\"\" and s or 0}
  end)
  if stat then return res else perror('Tokenizer',\"Bad long time format\",GCTX.from,GCTX.to,GCTX.source) end
end
local function toTime(str)
  local h,m,s = str:match(\"(%d%d):(%d%d):?(%d*)\")
  return 3600*h+60*m+(s and s~=\"\" and s or 0)
end

local tokenMetatable = {
  __tostring = function (t) return fmt(\"%s:%s/%s/%s\",t.type,t.value or t.opval,t.dbg.from,t.dbg.to) end
}

local function token(prefix, pattern, createFn)
  pattern = \"^(\" .. pattern .. \")\"
  local function fn(ctx)
    local sta, len, res, group = string.find(ctx.source, pattern)
    if len then
      if createFn then
        ctx.to = ctx.cursor + len
        ctx.from = ctx.cursor + sta
        local tokenv,t2,len2 = createFn(group or res, ctx.source)
        if tokenv == '%break' then return end
        if tokenv == '%extend%' then
          tokenv = t2
          len = len2
        end
        tokenv.dbg = {from=ctx.cursor+1, to=ctx.cursor+len}
        table.insert(ctx.tokens, tokenv)
        setmetatable(tokenv, tokenMetatable)
      end
      ctx.source = string.sub(ctx.source, len+1)
      ctx.cursor = ctx.cursor + len
      return true
    end
  end
  for c in prefix:gmatch\".\" do
    patterns[c] = patterns[c] or {}
    table.insert(patterns[c], fn)
  end
end

local function trans(op) return opers0[op] and opers0[op].trans or op end

local function tknError(msg) error(msg) end
token(\" \\t\\n\\r\",\"[%s%c]+\")
--2019/3/30/20:30
token(\"/0123456789\",\"%d?%d?%d?%d?/?%d+/%d+/%d%d:%d%d:?%d?%d?\",function (t) return {type=\"num\", const=true, value=toTimeDate(t)} end)
token(\"0123456789\",\"%d%d:%d%d:?%d?%d?\",function (t) 
  return {type='num', const=true, value=toTime(t)} 
end)
token(\"0123456789\",\"%d+:%d+\",function (w) 
  if #w>5 then tknError('Bad time constant '..w) else return \"%break\" end 
end)
token(\"t+n\",\"[t+n][/]\", function (op) return {type=\"op\", opval=trans(op)} end)
token(\"#\",\"#[A-Za-z_][%w_%-]*\",function (w) return {type=\"event\", value=w:sub(2)} end)
token(\"$\",\"%$+[_0-9a-zA-Z\\xC3\\xA5\\xA4\\xB6\\x85\\x84\\x96]*\",
function (w) return {type='t_name', value=w} end)
token(\"_abcdefghijklmnopqrstuvwxyzåäöABCDEFGHIJKLMNOPQRSTUVWXYZÅÄÖ\\xC3\\xA5\\xA4\\xB6\\x85\\x84\\x96\",\"[_a-zA-Z\\xC3\\xA5\\xA4\\xB6\\x85\\x84\\x96][_0-9a-zA-Z\\xC3\\xA5\\xA4\\xB6\\x85\\x84\\x96]*\", 
function (w) return opers0[w] and {type='op', opval=trans(w)} or keyword[w] and {type=keyword[w], keyw=true} or {type='t_name', value=w} end)
token(\"0123456789\",\"%d+%.%d+\", function (d) return {type=\"num\", const=true, value=tonumber(d)} end)
token(\"0123456789\",\"%d+\", function (d) return {type=\"num\", const=true, value=tonumber(d)} end)
local cmap = {['n']='\\n',['r']='\\r',['t']='\\t'}
local function getString(s,e)
  local i,n = 2,s:len()
  local r = {}
  while i <= n do
    local c = s:sub(i,i)
    if c == '\\\\' then
      i = i + 1
      c = s:sub(i,i)
      r[#r+1]=cmap[c] or c
    elseif c == e then
      return table.concat(r),i
    else r[#r+1]=c end
    i=i+1
  end
end
token('\"','\"', function (s,src)
  local str,i = getString(src,'\"')
  if not str then tknError('unfinished string starting with \"...') end
  return '%extend%', {type=\"str\", const=true, value=str}, i
end)
token(\"'\",\"'\", function (s,src)
  local str,i = getString(src,\"'\")
  if not str then tknError(\"unfinished string starting with '...\") end
  return '%extend%', {type=\"str\", const=true, value=str}, i
end)
token(\"-\",\"%-%-.-\\n\")
token(\"-\",\"%-%-.*\")
token(\"=\",\"===\",function (op) return {type=\"op\", opval=trans(op)} end)    
token(\".\",\"%.%.%.\",function (op) return {type=\"t_name\", value='...'} end)
token(\".\",\"%.%.\",function (op) return {type=\"op\", opval=trans('..')} end)
token(\"$\",\"%$%$%$?\", function (op) return {type=\"op\", opval=trans(op)} end)
token(\"@$=<>!+-*&|/^~:?\",\"[@%$=<>!+%-*&|/%^~;:%?][%+@=<>&|:%.%?]?\", 
function (w) return 
  keyword[w] and {type=keyword[w], keyw=true} or 
  opers0[w] and {type='op', opval=trans(w)} 
  or tknError(\"Bad token '\"..w..\"'\")
end)
token(\"{}(),[]#%;.\",\"[%.{}%(%),%[%]#%%;]\", 
function (w) return 
  keyword[w] and {type=keyword[w], keyw=true} or 
  opers0[w] and {type='op', opval=trans(w)} 
  or tknError(\"Bad token '\"..w..\"'\") 
end)

local function dispatch(c,ctx) 
  for _,m in ipairs(patterns[c] or {}) do
    if m(ctx) then return true end
  end
end

local function tokenize(src)
  local ctx = { source = src, tokens = {}, cursor = 0 }
  GCTX = ctx
  local stat,res = pcall(function()
    while #ctx.source>0 and dispatch(ctx.source:sub(1,1),ctx) do end
    if #ctx.source > 0 then 
      tknError(fmt(\"tokenizer failed at %s in %s\",ctx.source,src))
    end
  end)
  if not stat then
    if type(res) == 'table' and res._err then 
      return error(res)
    else 
      perror('Tokenizer',res or \"\",ctx.from,ctx.to,src)
    end
  end
  return ctx.tokens
end

function ER.tokenize(str)
  return stream(tokenize(str),str)
end


----------------------------- Parser ------------------------------------------------------------
--[[
chunk ::= block
block ::= {stat} [retstat]
stat ::=  ‘;’ | 
varlist ‘=’ exprlist | 
functioncall | 
label |          -- NOT IMPLEMENTED
break | 
goto Name |      -- NOT IMPLEMENTED
do block end | 
while exp do block end | 
repeat block until exp | 
if exp then block {elseif exp then block} [else block] end | 
for Name ‘=’ exp ‘,’ exp [‘,’ exp] do block end | 
for namelist in exprlist do block end | 
function funcname funcbody | 
  local function Name funcbody | 
    local namelist [‘=’ exprlist] 
    -- start: ;, name, break, do, while, repeat, if, for, function, local
    
    retstat ::= return [exprlist] [‘;’]
    label ::= ‘::’ Name ‘::’
    funcname ::= Name {‘.’ Name} [‘:’ Name]
    varlist ::= var {‘,’ var}
    var ::=  Name | prefixexp ‘[’ exp ‘]’ | prefixexp ‘.’ Name 
    namelist ::= Name {‘,’ Name}
    exprlist ::= exp {‘,’ exp}
    exp ::=  nil | false | true | Numeral | LiteralString | ‘...’ | functiondef | 
    prefixexp | tableconstructor | exp binop exp | unop exp 
    -- start: nil, false, true, num, string, ..., function, name,
    --        {, (, -, not, #, ~
    
    prefixexp ::= var | functioncall | ‘(’ exp ‘)’
    functioncall ::=  prefixexp args | prefixexp ‘:’ Name args 
    args ::=  ‘(’ [exprlist] ‘)’ | tableconstructor | LiteralString 
    functiondef ::= function funcbody
      funcbody ::= ‘(’ [parlist] ‘)’ block end
      parlist ::= namelist [‘,’ ‘...’] | ‘...’
      tableconstructor ::= ‘{’ [fieldlist] ‘}’ 
      fieldlist ::= field {fieldsep field} [fieldsep]
      field ::= ‘[’ exp ‘]’ ‘=’ exp | Name ‘=’ exp | exp
      fieldsep ::= ‘,’ | ‘;’
      binop ::=  ‘+’ | ‘-’ | ‘*’ | ‘/’ | ‘//’ | ‘^’ | ‘%’ | 
      ‘&’ | ‘~’ | ‘|’ | ‘>>’ | ‘<<’ | ‘..’ | 
      ‘<’ | ‘<=’ | ‘>’ | ‘>=’ | ‘==’ | ‘~=’ | 
      and | or
      unop ::= ‘-’ | not | ‘#’ | ‘~’
      
      -- My rewrite of the rules...
      afterpref ::= '.' prefixexp
      afterpref ::= '[' exp ']' afterpref
      afterpref ::= '(' args ')' afterpref
      afterpref ::= null
      
      prefixexp ::= Name
      prefixexp ::= Name . prefixexp
      prefixexp ::= Name [ exp ] [ afterpref ]
      prefixexp ::= Name ( args ) [ afterpref ]
      prefixexp ::= Name : Obj ( args ) [ afterpref ]
      prefixexp ::= ( exp ) [ afterpref ]
    end
  end
end
¨--]]

function ER.Stack()
  local p,px,st,self=0,0,{},{}
  function self.push(v) p=p+1 st[p]=v px=p end
  function self.pushx(v) px=px+1 st[px]=v end
  function self.getx(i) if px>p then return st[p+i] end end
  function self.pop(n) n = n or 1; p=p-n; px=p local r= st[p+n] st[p+n]=nil return r end
  function self.pushMultiRes(res)
    if #res == 0 then self.push(nil) return end
    self.push(res[1])
    for i=2,#res do self.pushx(res[i]) end 
  end
  function self.popm(n)
    local pxx = px
    p = p-n; px = p
    return table.unpack(st,p+1,pxx)
  end
  function self.popmpack(n)
    p = p-n
    local res = {table.unpack(st,p+1,px)}
    px = p
    return res
  end
  function self.peek(n) return st[p-(n or 0)] end
  function self.size() return p end
  function self.isEmpty() return p <= 0 end
  function self.dump(env) 
    local pr = env and env.print or print 
    for i=1,p do pr(string.format(\"S%02d: %s\",i,json.encode(st[i]))) end 
  end
  function self.clear() p,px,st=0,0,{} end
  return self
end

local chunk,block,stat,retstat,label,funcname,varlist,var,namelist,exprlist,expr
local prefixexpr,functioncall,args,functiondef,funcbody,parlist,tablevalue
local function mapT(args) local r={} for _,v in ipairs(args) do r[v]=true end return r end
local function copy(t) local r={} for k,v in pairs(t) do r[k]=v end return r end
local function merge(t1,t2) local t0 = copy(t1) for k,v in pairs(t2) do t0[k] = v end return t0 end
local Stack,Opers
local fmt = string.format

local _perror,_source
local function perror(msg,tkn)
  _perror('Parser',msg,tkn.dbg.from,tkn.dbg.to,_source)
end

local function matchError(tkns,t,msg)
  perror(msg,t)
end

local function mergeDbg(...)
  local dbg = {...}
  return {from=(dbg[1]._dbg or dbg[1].dbg).from,to=(dbg[#dbg]._dbg or dbg[#dbg].dbg).to}
end

local function Scope()
  local self,frame = {},{}
  function self.push() local f = {_next=frame} frame = f end
  function self.pop() frame=frame._next end
  function self.setBreak() frame.breaks = true end
  function self.addLocal(name) frame.locals = frame.locals or {} frame.locals[name] = true end
  function self.hasBreaks() return frame.breaks end
  function self.hasLocals(name) return frame.locals end
  return self
end

local scope = Scope()
local inExpr = false 

local blockEnd = mapT{'t_return','t_eof','t_ruleend'}
function block(tkns,ends) -- OK
  scope.push()
  local stats,ends = {},ends or blockEnd
  local t = tkns.peek()
  local fp = t
  while not (ends[t.type] or t.type=='t_return') do
    local saveP = tkns.getP()
    local stat,err = pcall(function()
      local s = stat(tkns,ends)
      if s then stats[#stats+1] = s end
      t = tkns.peek()
    end)
    if not stat then -- We got an error
      tkns.setP(saveP)
      local ep = tkns.peek()
      local stat2,err2 = pcall(expr,tkns,ends) -- Try to parse expression
      if stat2 then perror(\"Expected statement but got expression\",ep) -- If so, give better error
      else error(err) end -- No an expression either, just error
    end
  end
  local ep = tkns.peek()
  if ep.type == 't_return' then
    local r = retstat(tkns,ends)
    if r then stats[#stats+1] = r end
    ep = tkns.peek()
  end
  local bs = scope.hasBreaks() or scope.hasLocals()
  local locals = scope.hasLocals()
  scope.pop()
  return {type='block', statements=stats, scope = bs, locals = locals, dbg=mergeDbg(fp,ep)}
end

local varTypes={[\"\"]='ev',[\"$\"]='gv',[\"$$\"]='qv',[\"$$$\"]='sv'}
local function varType(name) return varTypes[name:match(\"^[%$]*\")] end

local doEnd = mapT{'t_end','t_eof','t_ruleend'}
local whileEnd = mapT{'t_do','t_eof','t_ruleend'}
local untilEnd = mapT{'t_until','t_eof','t_ruleend'}
local exprEnd = mapT{'t_semi','t_comma','t_eof','t_if','t_do','t_while','t_repeat','t_return','t_break','t_ruleend'}
local thenEnd = mapT{'t_end','t_else','t_elseif','t_eof','t_ruleend'}
local endEnd = mapT{'t_end','t_eof','t_ruleend'}
local braEnd = merge(mapT{'t_rbra','t_eof','t_ruleend'},exprEnd)
local incsMap = mapT{'t_addinc','t_subinc','t_mulinc','t_divinc'}
local caseExpr = mapT{'t_>>'}
local caseEnd = mapT{'t_end','t_||','t_eof','t_ruleend'}

function stat(tkns,ends)
  ends = ends or {}
  local pt = tkns.peek().type
  if tkns.matchpt('t_semi') or ends[pt] then return end
  local stp = tkns.peek()
  
  if tkns.peek().type == 't_name' then 
    local stp = tkns.peek()
    local n = tkns.matcht('t_name')
    local v = prefixexpr(tkns,{type='name',value=n.value,_dbg=n.dbg,vt=varType(n.value)})
    if v.type=='call' or v.type == 'objcall' then 
      return v   -- OK. functioncall
    elseif incsMap[tkns.peek().type]  then -- OK. var += exp
      --local v = tkns.matcht('t_name',\"Expected variable name\").value
      local op = tkns.next()
      local val = expr(tkns,exprEnd)
      return {type='incvar',name=v.value,op=op.type:sub(3,-4),value=val,_dbg=op.dbg}
    elseif v.type=='getprop' and not (tkns.peek().opval=='assign' or tkns.matchpt('t_comma')) then
      return v
    else -- OK. varlist ‘=’ exprlist
      local vl = varlist(tkns,v)
      --local t = tkns.match('opval','assign',\"Expected '=' in assignment\")
      local t = tkns.peek()
      if not tkns.matchp('opval','assign') then 
        perror(\"Expected '=' in assignment\",stp) 
      end
      local e = exprlist(tkns)
      return {type='assign',vars=vl,exprs=e,_dbg=t.dbg}
    end
  end
  --label |          -- NOT IMPLEMENTED
  if tkns.matchpt('t_break') then -- OK.
    scope.setBreak()
    return {type='break',_dbg=pt.dbg}
  end
  -- go to Name |      -- NOT IMPLEMENTED
  if tkns.matchpt('t_do') then  -- OK. _do_block_end
    local bl = block(tkns,doEnd)
    tkns.matcht('t_end',\"Expected END for DO block\")
    return bl
  end
  if tkns.matchpt('t_while') then -- OK. _while_exp_do_block_end
    local e = expr(tkns,whileEnd)
    tkns.matcht('t_do',\"Expected DO in WHILE loop\")
    local b = block(tkns,doEnd)
    tkns.matcht('t_end',\"Expected END in WHILE loop\")
    return {type='while',cond=e,body=b,_dbg=pt.dbg}
  end 
  if tkns.matchpt('t_repeat') then -- OK. _repeat_block_until_exp_
    local b = block(tkns,untilEnd)
    tkns.matcht('t_until',\"Expected UNTIL in REPEAT block\")
    local e = expr(tkns,exprEnd)
    return {type='rep'..'eat',body=b,cond=e,_dbg=pt.dbg}
  end
  
  if tkns.matchpt('t_if') then -- OK. _if_exp_then_block_{elseif_exp_then_block} [else_block]_end 
    local e = expr(tkns)
    tkns.matcht('t_then',\"Expected THEN in IF statement\")
    local b = block(tkns,thenEnd)
    local ifs = {{cond=e,body=b}}
    while tkns.matchpt('t_elseif') do
      local e = expr(tkns,thenEnd)
      tkns.matcht('t_then',\"Expected THEN in ELSEIF statement\")
      local b = block(tkns,thenEnd)
      ifs[#ifs+1] = {cond=e,body=b}
    end
    if tkns.matchpt('t_else') then
      local b = block(tkns,endEnd)
      ifs[#ifs+1] = {body=b}
    end
    tkns.matcht('t_end',\"Expected END in IF statement\")
    return {type='if', args=ifs,_dbg=pt.dbg}
  end
  
  -- OK. case ... end
  if tkns.matchpt('t_case') then 
    local args = {}
    while tkns.matchpt('t_||') do
      local e = expr(tkns,caseExpr)
      tkns.matcht('t_>>',\"Expected >> after expression in CASE statement\")
      local b = block(tkns,caseEnd)
      args[#args+1] = {cond=e,body=b}
    end
    tkns.matcht('t_end',\"Expected END in CASE statement\")
    return {type='if', args=args,_dbg=pt.dbg}
  end
  
  if tkns.matchpt('t_for') then
    -- OK. for Name ‘=’ exp ‘,’ exp [‘,’ exp] do block end
    if tkns.peek(2).opval == 'assign' then 
      local name = tkns.matcht('t_name',\"Expected loop variable name\")
      local var = {type='name',value=name.value,_dbg=name.dbg,vt=varType(name.value)}
      tkns.match('opval','assign',\"Expected '=' in FOR loop\")
      local start = expr(tkns)
      tkns.matcht('t_comma',\"Expected ',' in FOR loop\")
      local stop = expr(tkns,{'t_comma','t_do','t_eof'})
      local step
      if tkns.matchpt('t_comma') then
        step = expr(tkns,{'t_comma','t_do','t_eof'})
      else 
        step = {type='num',value=1,const=true,_dbg=tkns.peek().dbg} 
      end
      tkns.matcht('t_do',\"Expected DO in FOR loop\")
      local body = block(tkns,endEnd)
      tkns.matcht('t_end',\"Expected END in FOR loop\")
      body.scope = nil -- we always have outer scope for loop var...
      local d = {type='block',scope=true,statements={
        {type='assign',vars={var},exprs={start},_dbg=name.dbg},
        {type='loop',statements={
          {type='breakif',
          cond={type='binop',op='gt',exp1=var,exp2=stop,_dbg=name.dbg},
          _dbg=body._dbg
        },
        body,
        {type='incvar',name=name.value,op='add',value=step,_dbg=step._dbg}
      }}}}
      return d
    else -- for namelist in exprlist do block_end
      local n = namelist(tkns)
      if #n < 1 or #n > 2 then perror(\"Expected 1 or 2 variables in FOR in loop\",tkns.peek()) end
      if #n == 1 then n[2] = '_' end
      tkns.matcht('t_in',\"Expected 'in' in FOR loop\")
      local e = exprlist(tkns)
      tkns.matcht('t_do',\"Expected DO in FOR loop\")
      local b = block(tkns,endEnd)
      tkns.matcht('t_end',\"Expected END in FOR loop\")
      return {type='forin',names=n,exp=e,body=b,_dbg=pt.dbg} 
    end
  end
  
  if tkns.matchpt('t_function') then -- OK. function funcname funcbody
    local n = funcname(tkns)
    local b = funcbody(tkns)
    return {type='functiondef',name=n,fun={type='func'..'tion',params=b.params,body=b.block,_dbg=pt.dbg}}
  end
  if tkns.matchpt('t_local') then
    if tkns.matchpt('t_function') then -- local function Name funcbody
      local n = tkns.matcht('t_name',\"Expected FUNCTION name\")
      scope.addLocal(n.value)
      local b = funcbody(tkns)
      return {type='localfunction',name=n,body=b,_dbg=pt.dbg}
    else -- OK. local namelist [‘=’ exprlist]
      local n = namelist(tkns)
      for _,name in ipairs(n) do scope.addLocal(name) end
      local e
      if tkns.matchp('opval','assign') then
        e = exprlist(tkns)
      end
      return {type='local',names=n,exprs=e,_dbg=pt.dbg}
    end
  end
  if tkns.matchpt('t_lcur') then -- OK. tableconstructor
    local tab = tablevalue(tkns)
    tkns.matcht('t_ddot',\": expected for table property call\")
    local n = tkns.matcht('t_name',\"Expected property name after ':'\").value
    local pt = tkns.peek()
    if tkns.peek().opval == 'assign' then
      tkns.next()
      local val = expr(tkns,exprEnd)
      return {type='assign',vars={{type='getprop',prop=n,obj=tab,_dbg=pt.dbg}},exprs={val},_dbg=pt.dbg}
    end
    return {type='getprop',prop=n,obj=tab,_dbg=pt.dbg}
  end
  if tkns.peek().type=='num' then
    local pt = tkns.peek()
    local num = tkns.matcht('num')
    if tkns.peek().type ~= 't_ddot' then 
      perror(\"Expected ':' for number property call\",pt) 
    end
    local v = prefixexpr(tkns,{type='num',value=num.value,_dbg=num.dbg,const=true})
    if v.type=='call' or v.type == 'objcall' then 
      perror(\"Expected ':' for number property call\",pt)
    elseif v.type=='getprop' and not (tkns.peek().opval=='assign' or tkns.matchpt('t_comma')) then
      return v
    else -- OK. varlist ‘=’ exprlist
      local vl = varlist(tkns,v)
      --local t = tkns.match('opval','assign',\"Expected '=' in assignment\")
      local t = tkns.peek()
      if not tkns.matchp('opval','assign') then 
        perror(\"Expected '=' in assignment\",stp) 
      end
      local e = exprlist(tkns)
      return {type='assign',vars=vl,exprs=e,_dbg=t.dbg}
    end
  end
  local tp = tkns.peek()
  perror(fmt(\"unexpected token '%s'\",tp.opval or tp.value or tp.type),tkns.peek())
end

function namelist(tkns)
  local names = {tkns.matcht('t_name',\"Expected variable name\").value}
  while tkns.matchpt('t_comma') do
    names[#names+1] = tkns.matcht('t_name',\"Expected variable name\").value
  end
  return names
end

function funcname(tkns)
  local n = {tkns.matcht('t_name',\"Expected FUNCTION name\").value}
  while tkns.matchpt('t_dot') do
    n[#n+1] = tkns.matcht('t_name',\"Expected FUNCTION name\").value
  end
  if tkns.matchpt('t_ddot') then
    n[#n+1] = tkns.matcht('t_name').value
  end
  return n
end

function funcbody(tkns)
  tkns.matcht('t_lpar',\"Expected '(' in FUNCTION definition\")
  local p = parlist(tkns)
  tkns.matcht('t_rpar',\"Expected ')' in FUNCTION definition\")
  local b = block(tkns,endEnd)
  tkns.matcht('t_end',\"Expected 'end' in FUNCTION definition\")
  return {params=p,block=b}
end

local function args(tkns)
  tkns.matcht('t_lpar',\"Expected '(' in FUNCTION call\")
  local exprs = exprlist(tkns)
  tkns.matcht('t_rpar',\"Expected ')' in FUNCTION call\")
  return exprs
end

function prefixexpr(tkns,r)
  local t = tkns.peek()
  if t.type == 't_dot' then
    tkns.next()
    local n = tkns.matcht('t_name',\"Expected name after '.'\")
    return prefixexpr(tkns,{type='aref',tab=r,idx=n.value,_dbg=t.dbg})
  elseif t.type == 't_lbra' then
    tkns.next()
    local e = expr(tkns,braEnd)
    if e.const then e = e.value end
    tkns.matcht('t_rbra',\"Expected ']' to end table access\")
    return prefixexpr(tkns,{type='aref',tab=r,idx=e,_dbg=t.dbg})
  elseif t.type == 't_lcur' then -- ToDo
    error(\"Not implemented yet\")
  elseif t.type == 't_lpar' then
    local isExpr = inExpr
    local args = args(tkns)
    return prefixexpr(tkns,{type='call',fun=r,args=args,expr=isExpr,_dbg=t.dbg}) 
  elseif t.type == 't_ddot' then
    tkns.next()
    local n = tkns.matcht('t_name',\"Expected name after ':'\").value
    local pt = tkns.peek()
    if tkns.peek().type == 't_lpar' then -- method call
      local isExpr = inExpr
      local args = args(tkns)
      return prefixexpr(tkns,{type='objcall',obj=r,fun=n,args=args,expr=isExpr,_dbg=t.dbg})
    else
      if tkns.peek().type == 't_dot' or tkns.peek().type =='t_ddot' then
        return prefixexpr(tkns,{type='getprop',obj=r,prop=n,_dbg=t.dbg}) -- property access
      end 
      return {type='getprop',obj=r,prop=n,expr=inExpr,_dbg=t.dbg} -- property access
    end
  else return r end
end

function parlist(tkns)
  local n = namelist(tkns)
  if tkns.matchpt('...') then
    n[#n+1] = '...'
  end
  return n
end

function varlist(tkns,var)
  local v = {var}
  while tkns.matchpt('t_comma') do
    local p = tkns.peek()
    local n = tkns.matcht('t_name',\"Expected variable name\")
    v[#v+1] = prefixexpr(tkns,{type='name',value=n.value,_dbg=p.dbg,vt=varType(n.value)})
    local e = v[#v]
    if not(e.type == 'name' or e.type == 'aref' or e.type == 'getprop') then 
      perror(fmt(\"expected variable or table assignment\"),p)
    end
  end
  return v
end

function exprlist(tkns)
  local e = {expr(tkns,exprEnd)}
  while tkns.matchpt('t_comma') do
    e[#e+1] = expr(tkns,exprEnd)
  end
  return e
end

local curlEnd = merge(mapT{'t_rbra','t_rcurl,t_comma'},exprEnd)
function tablevalue(tkns)
  local tab,idx,n = {},1,0
  local t0 = tkns.peek()
  while tkns.peek().type ~= 't_rcur' do
    local t = tkns.peek()
    if t.type == 't_lbra' then --[expr] = ...
      tkns.next()
      local k = expr(tkns,curlEnd)
      tkns.matcht('t_rbra',\"Expected ']' in table constructor\")
      tkns.match('opval','assign',\"Expected '=' in table constructor\")
      local v = expr(tkns,curlEnd)
      if k.const then k = k.value 
        tab[#tab+1] = {key=k.value,value=v}; n = n + (v.const and 1 or 0)
      else tab[#tab+1] = {expr=k,value=v} end
    elseif t.type == 't_name' and tkns.peek(2).opval == 'assign' then  -- name = expr
      local name = t.value
      tkns.next()
      tkns.match('opval','assign',\"Expected '=' in table constructor\")
      local v = expr(tkns,curlEnd)
      tab[#tab+1] = {key=name,value=v}; n = n + (v.const and 1 or 0)
    else
      local v = expr(tkns,curlEnd)
      tab[#tab+1] = {key=idx,value=v}; idx=idx+1; n = n + (v.const and 1 or 0)
    end
    if not tkns.matchpt('t_comma') then break end
  end 
  tkns.matcht('t_rcur')
  if next(tab)==nil or n == #tab then
    local res = {}
    for i,k in ipairs(tab) do res[k.key] = k.value.value end
    return {type='table',value=res,const=true,_dbg=t0.dbg}
  elseif #tab == 1 and tab[1].value and tab[1].value.value == '...' then
    return {type='varargstable',_dbg=t0.dbg}
  else return {type='table',value=tab,_dbg=t0.dbg} end
end

local function isConst(t) return t.const and t.type or t.type=='t_name' and 'name' end
local function isNum(t) return t.type=='num' end

local foldConst = {}
local ops = {
  ['add']=function(a,b) return a+b end,
  ['sub']=function(a,b) return a-b end,
  ['mul']=function(a,b) return a*b end,
  ['div']=function(a,b) return a/b end,
}
local foldConsts = mapT{'add','sub','mul','div'}

local function foldConst(op,a,b)
  if isNum(a) then
    if isNum(b) then
      return {type='num',value=ops[op](a.value,b.value),const=true,_dbg=mergeDbg(a,b)}
    end
    return {type='unop',op=op,a=a.value,exp=b,_dbg=b._dbg}
  elseif isNum(b) then
    --if op == 'div' then op,b.value = 'mul',1/b.value end
    --if op == 'sub' then op,b.value = 'sub',-b.value end
    return {type='unop',op=op,b=b.value,exp=a,_dbg=a._dbg}
  end
  return {type='binop',op=op,exp1=a,exp2=b,_dbg=mergeDbg(a,b)}
end

local simpBinops = mapT{'and','or'}
local function simpBinop(op,a,b)
  if b.type == 'binop' and b.op == op then
    return {type='seqop',op=op,exprs={a,b.expr1,b.expr2},_dbg=mergeDbg(b.expr1,b.expr2)}
  elseif b.type == 'seqop' and b.op == op then
    table.insert(b.exprs,1,a)
    return {type='seqop',op=op,exprs=b.exprs,_dbg=b._dbg}
  end
  return {type='seqop',op=op,exprs={a,b},_dbg=mergeDbg(a,b)}
end

local function isOperator(t) return t.opval end
local function prio(op) return Opers[op].prio end
local function applyOp(op,vals)
  if Opers[op].unop then
    local a = vals.pop()
    if op == 'neg' and isNum(a) then 
      return {type='num',value=-a.value,const=true,_dbg=a._dbg} 
    else return {type='unop',op=op,exp=a,_dbg=a._dbg} end
  else
    local b,a = vals.pop(),vals.pop()
    if foldConsts[op] then return foldConst(op,a,b)
    elseif simpBinops[op] then return simpBinop(op,a,b)
    else return {type='binop',op=op,exp1=a,exp2=b,_dbg=mergeDbg(a,b)} end
  end
end

local function CMT(t)
  return setmetatable(t,{__tostring=function(t) return fmt(\"%s:%s\",t.type,t.value) end})
end
local specOp = {}
local parEnd = mapT{'t_rpar','t_eof'}
local braEnd = mapT{'t_rbra','t_eof'}
function specOp.t_lpar(t,vals,ops,tkns)
  local e = expr(tkns,parEnd)
  tkns.matcht('t_rpar',\"Expcted ) to close (...\")
  e = prefixexpr(tkns,e)
  vals.push(e)
end
function specOp.t_lbra(t,vals,ops,tkns)
  local e = expr(tkns,braEnd)
  tkns.matcht('t_rbra',\"Expected ]\")
  ops.push(e) -- table index
  vals.push(e)
end
function specOp.t_lcur(t,vals,ops,tkns)
  local isExpr = inExpr
  local tab = tablevalue(tkns)
  if tkns.matchpt('t_ddot') then
    local nt = tkns.peek()
    local n = tkns.matcht('t_name',\"Expected property name after :\").value
    if tkns.peek().type=='t_ddot' then
      vals.push(prefixexpr(tkns,{type='getprop',obj=tab,prop=n,_dbg=t.dbg})) -- property access
    else
      vals.push({type='getprop',obj=tab,prop=n,expr=isExpr,_dbg=nt.dbg})
    end
  else
    vals.push(tab)
  end
end
function specOp.t_nil(t,vals,ops,tkns) vals.push(CMT{type='const',value=nil,const=true,_dbg=t.dbg}) end
function specOp.t_true(t,vals,ops,tkns) vals.push(CMT{type='const',value=true,const=true,_dbg=t.dbg}) end
function specOp.t_false(t,vals,ops,tkns) vals.push(CMT{type='const',value=false,const=true,_dbg=t.dbg}) end
function specOp.num(t,vals,ops,tkns)
  if tkns.matchpt('t_ddot') then
    local n = tkns.matcht('t_name',\"Expected property name after :\").value
    vals.push({type='getprop',obj=t,prop=n,expr=inExpr,_dbg=t.dbg})
  else
    vals.push(CMT{type='num',value=t.value,const=true,_dbg=t.dbg})
  end
end
function specOp.event(t,vals,ops,tkns)
  local tab
  if tkns.peek().type == 't_lcur' then
    tkns.next()
    local val = tablevalue(tkns)
    if val.const then
      val.value.type=t.value
    elseif val.type == 'table' then
      table.insert(val.value,1,{key='type',value={type='const',value=t.value}})
    else perror(\"Expected table constructor or ... after event{\",tkns.peek()) end
    tab = val
  else tab = {type='table',value={type=t.value},const=true,_dbg=t.dbg} end
  vals.push(tab)
end
function specOp.str(t,vals,ops,tkns) vals.push(CMT{type='str',value=t.value,const=true,_dbg=t.dbg}) end
function specOp.t_name(t,vals,ops,tkns)
  local v = prefixexpr(tkns,CMT{type='name',value=t.value,_dbg=t.dbg,vt=varType(t.value)})
  vals.push(v) 
end
function specOp.t_function(t,vals,ops,tkns)
  local isExpr = inExpr
  local f = funcbody(tkns)
  local fun = {type='functionexpr',fun={type='func'..'tion',expr=isExpr,params=f.params,body=f.block},_dbg=t.dbg}
  local v = prefixexpr(tkns,fun)
  vals.push(v)
end

local unminBeg = mapT{
  't_rpar','t_rbra','t_name','num','t_str','t_nil','t_true','t_false'
}
local exprEnd = mapT(merge(blockEnd,{}))
function expr(tkns,ends)
  local oldExpr = inExpr
  inExpr = true
  local ops,vals = Stack(),Stack()
  while true do
    local t = tkns.peek()
    if (ends or exprEnd)[t.type] then break end
    if specOp[t.type] then
      tkns.next()
      specOp[t.type](t,vals,ops,tkns)
    elseif isOperator(t) then
      if t.opval == 'sub' then
        local last = tkns.last()
        if not last or not unminBeg[last.type] then t.opval = 'neg' end
      end
      tkns.next()
      local tprio = prio(t.opval)
      while not ops.isEmpty() and prio(ops.peek().opval) > tprio do
        vals.push(applyOp(ops.pop().opval,vals))
      end
      ops.push(t)
    else
      break -- end of expr?
    end
  end
  while not ops.isEmpty() do
    vals.push(applyOp(ops.pop().opval,vals))
  end
  inExpr=oldExpr
  return vals.pop()
end

function retstat(tkns,ends)
  local t = tkns.matcht('t_return')
  local e
  if not ends[tkns.peek().type] then
    e = exprlist(tkns)
  end
  if tkns.matchpt('t_semi') then --[[ ignore --]] end
  return {type='return',exp=e,_dbg=t.dbg}
end

local ruleEnd = mapT{'t_ruleend','t_eof'}
function ER.parse(tkns)
  Stack,Opers = ER.Stack,ER._opers1
  scope,inExpr = Scope(),false
  _perror,_source = ER.perror,tkns.src
  tkns.error = matchError
  local res
  if tkns.matchpt('t_rulebegin') then
    local head = expr(tkns,ruleEnd)
    tkns.matcht('t_rule',\"Expected rule\")
    local body = block(tkns,ruleEnd)
    tkns.matcht('t_ruleend',\"Expected rule end\")
    res = {type='ruledef',head=head,body=body,_dbg=head._dbg}             
  else res = block(tkns,blockEnd) end
  local rest = tkns.peek()
  if rest.type ~= 't_eof' then
    perror(\"Expected end of file but got \"..rest.type,tkns.peek())
  end
  res._src = tkns.src
  return res
end","isMain":false,"isOpen":false},{"type":"lua","name":"compiler","content":"fibaro.EventRunner = fibaro.EventRunner or { debugFlags = {} }
local ER = fibaro.EventRunner
local debugFlags = ER.debugFlags
local isHead,currentSrc = false,\"\" 

local fmt = string.format
local function idfun() end

local FUNCSTR = \"funct\"..\"ion\"

local function docify(c)
  if type(c) ~= 'table' then return c end
  if c.__doc then 
    return docify(c.__doc)
  else
    local r = {}
    for k,v in pairs(c) do r[k] = docify(v) end
    return r
  end
end

local function CONTFUN(fun) 
  return setmetatable({ __continuationFun =true },{
    __call = function(t,...) return fun(...) end
  })
end

local function CONT(cont,doc) 
  return setmetatable({ __continuation = true, __doc = doc },{
    __call = function(t,...) return cont(...) end,
    __tostring = function(t) return (doc and json.encodeFast(docify(doc)) or \"\") end
  })
end

local function isContFun(obj) return type(obj) == 'table' and obj.__continuationFun end
local function isCont(obj) return type(obj) == 'table' and obj.__continuation end

local function IF(test, t, f)
  return CONT(function(cont,env)
    test(function(res)
      if res then
        t(cont, env)
      else
        if f then f(cont, env) else cont(false) end
      end
    end, env)
  end,{'if', test, t, f})
end

local function IFA(args)
  return CONT(function(cont,env)
    local function doTest(i)
      if i > #args then
        cont(true)
        return
      end
      local test = args[i]
      if not test.cond then test.body(cont, env)
      else
        test.cond(function(res)
          if res then
            test.body(cont, env)
          else
            doTest(i + 1)
          end
        end, env)
      end
      
    end
    doTest(1)
  end,{'ifa',args})
end

local function AND(...)
  local tests = {...}
  return CONT(function(cont, env)
    local function nextTest(index, res)
      if index > #tests then
        cont(res)
      else
        local test = tests[index]
        if isCont(test) or type(test) == FUNCSTR then
          test(function(res)
            if res then
              nextTest(index + 1, res)
            else
              cont(false)
            end
          end, env)
        elseif test then 
          nextTest(index + 1, test)
        else
          cont(test)
        end
      end
    end
    nextTest(1, false)
  end,{'and',tests})
end

local function OR(...)
  local tests = {...}
  return CONT(function(cont, env)
    local function nextTest(index, res)
      if index > #tests then
        cont(res)
      else
        local test = tests[index]
        if isCont(test) or type(test) == FUNCSTR then
          test(function(res)
            if res then 
              cont(res)
            else
              nextTest(index + 1, res)
            end
          end, env)
        elseif test then 
          cont(test) 
        else
          nextTest(index + 1, test)
        end
      end
    end
    nextTest(1, false)
  end,{'or',tests})
end

local function WHILE(cond,body)
  return CONT(function(cont, env)
    local function loop()
      cond(function(res)
        if res then 
          body(function() env:setTimeout(loop,0) end,env)
        else
          cont(true) -- Exit the loop
        end
      end, env)
    end
    loop()
  end,{'while',cond,body})
end

local function REPEAT(cond,body)
  return CONT(function(cont, env)
    local function loop()
      body(function()
        cond(function(res)
          if not res then env:setTimeout(loop, 0)
          else cont(true) end
        end, env)
      end,env)
    end
    loop()
  end,{'repeat',cond,body})
end

local function LOOP(body) -- loop forever - needs break/return
  return CONT(function(cont, env)
    local function loop()
      body(function() env:setTimeout(loop,0) end, env)
    end
    loop()
  end,{'loop',body})
end

local function FRAME(expr)
  return CONT(function(cont, env)
    local __cont = function(...) env:popEnv() cont(...) end
    env:pushEnv({__cont = {__cont}})
    expr(__cont, env)
  end,{'frame',expr})
end

--[[
local function mfor(vars, expr, body)
  local f,t,i = expr()
  kn ,vn = vars[1],vars[2]
  vars[kn] = i
  while true do
    vars[kn], vars[vn] = f(t,vars[kn])
    if vars[kn] == nil then break end
    body()
  end
end
--]]

local function FORIN(vars,expr,body)
  return FRAME(function(cont,env)
    local kn,vn = table.unpack(vars)
    env:pushVariable(kn,nil)
    env:pushVariable(vn,nil)
    expr(function(f,t,i)
      local k,v = i,nil
      local function loop()
        k,v = f(t,k)
        env:setVariable(kn,k)
        env:setVariable(vn,v)
        if not k then return cont(true) end
        body(function() env:setTimeout(loop,0) end, env)
      end
      loop()
    end,env)
  end),{'forin',vars,expr,body}
end

local function evalArgs(args, cont, env)
  if #args == 0 then
    cont({})
  else
    local results = {}
    local function nextArg(index)
      local arg = args[index]
      if type(arg) == FUNCSTR or isCont(arg) then
        arg(function(arg1,...)
          if index == #args then
            results[index] = arg1
            for _,a in ipairs({...}) do 
              results[#results+1] = a
            end
            cont(results)
          else
            results[index] = arg1
            nextArg(index + 1)
          end
        end, env)
      else
        results[index] = arg
        nextArg(index + 1)
      end
    end

    nextArg(1)
  end
end

local function BREAK()
  return CONT(function(cont, env)
    local frameCont = env:getVariable('__cont')
    env:setTimeout(function() frameCont(true) end, 0)
  end, {'break'})
end

local function PROGN(...)
  local statements = {...}
  return CONT(function(cont,env)
    evalArgs(statements, function(values)
      local val = true
      if #values > 0 then val = values[#statements] end
      cont(val)
    end,env)
  end,{'progn',statements})
end

local function TABLE(args)
  return CONT(function(cont, env)
    local tbl = {}
    local function nextVal(i)
      if i > #args then
        cont(tbl)
      else
        args[i].expr(function(key)
          args[i].value(function(val)
            tbl[key]=val
            nextVal(i + 1)
          end,env)
        end,env)
      end
    end
    nextVal(1)
  end, {'table', args})
end

local function checkArgs(a,t1,b,t2,env,e1,e2)
  if type(a) ~= t1 then env.error(fmt(\"%s: Expected %s, got: %s\",e1,t1,a))  end
  if type(b) ~= t2 then env.error(fmt(\"%s: Expected %s, got: %s\",e2,t2,b))  end
end

local T2020 = os.time{year=2020, month=1, day=1, hour=0}
local function coerce(a) if type(a) == 'table' then local mt=getmetatable(a) if mt and mt.__tostring then return mt.__tostring(a) end end return a end

local opFuns = {
  ['add'] = function(arg1,arg2,env,e1,e2) checkArgs(arg1,'number',arg2,'number',env,e1,e2) return arg1 + arg2 end,
  ['sub'] = function(arg1,arg2,env,e1,e2) checkArgs(arg1,'number',arg2,'number',env,e1,e2) return arg1 - arg2 end,
  ['mul'] = function(arg1,arg2,env,e1,e2) checkArgs(arg1,'number',arg2,'number',env,e1,e2) return arg1 * arg2 end,
  ['div'] = function(arg1,arg2,env,e1,e2) checkArgs(arg1,'number',arg2,'number',env,e1,e2) return arg1 / arg2 end,
  ['mod'] = function(arg1,arg2,env,e1,e2) checkArgs(arg1,'number',arg2,'number',env,e1,e2) return arg1 % arg2 end,
  ['pow'] = function(arg1,arg2,env,e1,e2) checkArgs(arg1,'number',arg2,'number',env,e1,e2) return arg1 ^ arg2 end,
  ['eq'] = function(arg1,arg2,env,e1,e2) arg1,arg2 = coerce(arg1),coerce(arg2) return arg1 == arg2 end,
  ['neq'] = function(arg1,arg2,env,e1,e2) arg1,arg2 = coerce(arg1),coerce(arg2) return arg1 ~= arg2 end,
  ['lt'] = function(arg1,arg2,env,e1,e2) arg1,arg2 = coerce(arg1),coerce(arg2) return arg1 < arg2 end,
  ['lte'] = function(arg1,arg2,env,e1,e2) arg1,arg2 = coerce(arg1),coerce(arg2) return arg1 <= arg2 end,
  ['gt'] = function(arg1,arg2,env,e1,e2) arg1,arg2 = coerce(arg1),coerce(arg2) return arg1 > arg2 end,
  ['gte'] = function(arg1,arg2,env,e1,e2) arg1,arg2 = coerce(arg1),coerce(arg2) return arg1 >= arg2 end,
  ['betw'] = function(arg1,arg2,env,e1,e2)
    checkArgs(arg1,'number',arg2,'number',env,e1,e2)
    if arg1 > T2020 then
      local tn = os.time()
      return arg1 <= tn and tn <= arg2
    else
      local ts = os.date(\"*t\")
      local t = ts.hour*3600 + ts.min*60 + ts.sec
      arg2 = arg2 >= arg1 and arg2 or arg2 + 24*3600
      t = t >= arg1 and t or t + 24*3600
      return arg1 <= t and t <= arg2
    end
  end,
  ['nilco'] = function(arg1,arg2,env,e1,e2) if arg1 ~= nil then return arg1 else return arg2 end end,
}

local function BINOP(op,exp1,exp2)
  return CONT(function(cont, env)
    exp1(function(v1)
      exp2(function(v2)
        if opFuns[op] then
          local stat,err = pcall(function()
            local res = opFuns[op](v1, v2, env, exp1, exp2)
            cont(res)
          end)
          if not stat then
            env.error(fmt(\"%s: %s %s %s\",(err or \"\"):match(\"%d+:%s*(.*)\") or err, op, exp1, exp2))
          end
        else
          env.error(\"Unknown operator: \" .. tostring(op))
        end
      end, env)
    end, env)
  end, {'binop', op, exp1, exp2})
end

local function checkArg1(a,t1,b,t2,env,e)
  if type(a) ~= t1 then env.error(fmt(\"%s: Expected %s, got: %s\",e,t1,a))
  elseif type(b) ~= t2 then env.error(fmt(\"%s: Expected %s, got: %s\",e,t2,b)) 
  else return true end
end

local unOpFuns = {
  plus = function(v,a,b,e,env) return ER.toTime(\"+/\"..v) end,
  next = function(v,a,b,e,env) return ER.toTime(\"n/\"..v) end,
  today = function(v,a,b,e,env) return ER.toTime(\"t/\"..v) end,
  add = function(v,a,b,e,env) if checkArg1(v,'number',a or b,'number',env,e) then return v+(a or b) end end,
  neg = function(v,a,b,e,env) return - v end,
  sub = function(v,a,b,e,env) if checkArg1(v,'number',a or b,'number',env,e) then return a and a-v or v-b end end,
  mul = function(v,a,b,e,env) if checkArg1(v,'number',a or b,'number',env,e) then return v*(a or b) end end,
  div = function(v,a,b,e,env) if checkArg1(v,'number',a or b,'number',env,e) then return a and a/v or v/b  end end,
  ['not'] = function(v,a,b,e,env) return not v  end,
  daily = function(v,a,b,e,env)
    local e = env.trigger
    if not e then return env.error(\"No trigger in environment\") end
    return e.type == 'Daily'  -- False if not a daily event triggering
  end,
  interv = function(v,a,b,e,env)
    local e = env.trigger
    if not e then return env.error(\"No trigger in environment\") end
    return e.type == 'Interval'  -- False if not a daily event triggering
  end,
}


local function UNOP(op, expr, v1, v2) --UNOP('add', expr, 1) end
  return CONT(function(cont, env)
    expr(function(val)
      if unOpFuns[op] then
        local res = unOpFuns[op](val,v1,v2,expr,env)
        cont(res)
      else
        env.error(\"Unknown operator: \" .. tostring(op))
      end
    end, env)
  end, {'unop', op, expr, v1, v2})
end

local function CONST(n) 
  local c
  c = CONT(function(cont,env) 
    if c.evalHook then c.evalHook(c,cont,env)
    else cont(n) end
  end, {'const', n})
  return c
end

local function CALL(fun,...)
  local args = {...}
  return CONT(function(cont,env) -- Return value out of expr
    fun(function(fval)
      local isCont = isContFun(fval)
      if isCont or type(fval) == FUNCSTR then
        evalArgs(args, function(exprs)
          if isCont then -- continuation
            fval(cont,env,table.unpack(exprs)) 
          else
            local res = {fval(table.unpack(exprs))}
            cont(table.unpack(res))
          end
        end,env)
      else env.error(fmt(\"%s: Expected function, got: %s\", tostring(fun), tostring(fval))) end
    end, env)
  end, {'call', fun, args})
end

local function CALLOBJ(obj, fun, ...)
  local args = {...}
  return CONT(function(cont,env) -- Return value out of expr
    obj(function(objval)
      if type(objval) ~= 'table' then
        return env.error(fmt(\"%s: Expected table for :call, got: %s - %s\", tostring(fun), tostring(objval), tostring(obj)))
      end
      local fval = objval[fun]
      local isCont = isContFun(fval)
      if isCont or type(fval) == FUNCSTR then
        evalArgs(args, function(exprs)
          if isCont then -- continuation
            fval(cont,env,objval,table.unpack(exprs)) 
          else
            local res = {fval(objval,table.unpack(exprs))}
            cont(table.unpack(res))
          end
        end,env)
      else env.error(fmt(\"%s: Expected function, got: %s - %s\", tostring(fun), tostring(fval), tostring(fun))) end
    end, env)
  end, {'call', fun, args})
end

local function GETPROP(prop,obj)
  return CONT(function(cont,env)
    obj(function(o)
      if o == nil then return env.error(\"Not a prop object: \"..tostring(obj)) end
      local res = ER.executeGetProp(o,prop,env)
      cont(res)
    end,env)
  end, {'getprop', prop, obj})
end

local function AREF(tab,key)
  return CONT(function(cont,env) -- Return value out of expr
    tab(function(t)
      if type(t) == 'table' then
        key(function(k)
          cont(t[k])
        end,env)
      else env.error(fmt(\"Expected table, got: %s - %s.%s\",tostring(t),tostring(tab),tostring(key))) end
    end,env)
  end, {'aref', tab, key})
end

local function VAR(name,cvar) 
  return CONT(function(cont,env) 
    if cvar then cont(ER.computedVar[name]()) else cont(env:getVariable(name)) end
  end, {'var', name})
end

local function GVAR(name)
  return CONT(function(cont,env)
    local val,err = fibaro.getGlobalVariable(name)
    if val == nil then 
      fibaro.warning(__TAG,\"Global variable not found: \"..tostring(name))
    end
    cont(ER.marshallFrom(val)) 
  end, {'gvar', name}) 
end
local function QVAR(name) return CONT(function(cont,env) cont(quickApp:getVariable(name)) end, {'qvar', name}) end
local function IVAR(name) return CONT(function(cont,env) cont(quickApp:internalStorageGet(name)) end, {'ivar', name}) end

local function ASSIGNM(vars,exprs)
  return CONT(function(cont,env) -- Return value out of expr
    evalArgs(exprs, function(values)
      local function nextAssign(i)
        if i > #vars then cont(true)
        else 
          vars[i](env,values[i],nextAssign,i+1)
        end
      end
      nextAssign(1)
    end,env)
  end,{'assignm',vars,exprs})
end

local function LOCAL(vars,exprs)
  return CONT(function(cont,env)
    evalArgs(exprs, function(values)
      for i,var in ipairs(vars) do
        env:pushVariable(var, values[i])
      end
      cont(true)
    end,env)
  end, {'local', vars, exprs})
end

local function INCVAR(name, op, value)
  return CONT(function(cont, env)
    value(function(val)
      local var = env:getVariable(name)
      if tonumber(var)==nil then return env.error(\"Not a number: \"..tostring(name)) end
      local newValue = opFuns[op](var,val)
      env:setVariable(name, newValue)
      cont(newValue)
    end,env)
  end, {'incvar', name, op, value})
end

local function VARARGSTABLE(name)
  return CONT(function(cont, env)
    local var = env:getVariable('...')
    if type(var) == 'table' then
      cont(var)
    else
      env.error(\"Expected table for varargs, got: \" .. tostring(var))
    end
  end, {'varargs', name})
end

local function ASYNCFUN(fun) --- fun(cb,...)
  return CONTFUN(function(cont, env, ...)
    local timedout,ref = false,nil
    local cb = function(...) if ref then env:clearTimeout(ref) end; if not timedout then cont(...) end end
    local acb = setmetatable({env = env} , { __call = function(t,...) return cb(...) end })
    local timeout = fun(acb,...)
    timeout = tonumber(timeout) or 3000
    if timeout >= 0 then
      ref = env:setTimeout(function() 
        timedout = true
        env.error(fmt(\"%s: Async function timeout after %s ms\", tostring(fun), tostring(timeout)))
      end, timeout)
    end
  end)
end

local function FUNC(params, body)
  return CONT(function(cont,env) -- Return value out of expr
    cont(CONTFUN(function(cont,env,...)
      local __cont = function(...) 
         env:popEnv() cont(...)
      end
      env:pushEnv({__cont = {__cont}, __return = {__cont}})
      local args = {...}
      for i=1,#params-1 do
        local param = params[i]
        local value = args[i]
        env:pushVariable(param,value)
      end
      local param = params[#params]
      if param == '...' then
        local vararg = {}
        for i=#params,#args do vararg[#vararg+1] = args[i] end
        env:pushVariable(param, vararg)
      else
        local value = args[#params]
        env:pushVariable(param,value)
      end
      --print(json.encode(args),json.encodeFast(cleanVars(env.vars)))
      body(__cont,env)
    end))
  end,{'func',params,body})
end

local function RETURN(...)
  local args = {...}
  return CONT(function(cont,env) -- Return value out of expr
    local ret = env:getVariable('__return') or env.cont or cont
    evalArgs(args, function(exprs)
      --print(\"RET\", ret==cont, json.encodeFast(exprs),tostring(ret))
      ret(table.unpack(exprs))
    end, env)
  end, {'return', args})
end

local function args2str(...) local r = {} for i,v in ipairs({...}) do r[i] =type(v)=='table' and json.encodeFast(v) or tostring(v) end return table.unpack(r) end
ER.args2str = args2str

local function findVar(name,vars)
  local lastEnv = vars
  while vars do
    local v = vars[name]
    if v then return v else lastEnv = vars; vars = vars.__parent end
  end
  return nil,lastEnv
end
local function createEnv(cont,err,opts)
  local env = { vars = opts.env or {}, error = err, cont = cont }
  local globalEnv = opts.env
  function env:pushVariable(name,value) local v = self.vars[name] if v then v[1]=value else self.vars[name] = {value} end end
  function env:setVariable(name,val,global)
    if global then 
      local v = globalEnv[name]
      if v then v[1]=val else globalEnv[name] = {val} end
    end
    local v,last = findVar(name,self.vars) 
    if v then v[1]=val else last[name] = {val} end 
  end
  function env:getVariable(name) 
    local v = findVar(name,self.vars)  
    if v then return v[1] else return _G[name] end 
  end
  function env:pushEnv(e) e = e or {} e.__parent = self.vars; self.vars = e end
  function env:popEnv() self.vars = self.vars.__parent or {} end
  local cst,cct = opts.setTimeout or setTimeout,opts.clearTimeout or clearTimeout
  function env:setTimeout(f,t) return cst(f,t) end
  function env:clearTimeout(ref) return cct(ref) end
  return env
end
ER.createEnv = createEnv

local function RULE(expr,opts) return function() return ER.defRule(expr,opts) end end
local function RULECHECK(rule) return 
  CONT(function(cont,env) 
    if env.locals then
      for k,v in pairs(env.locals) do env:pushVariable(k,v) end
    end
    rule(function(...)
      if env.check then env.check(env.rule,env,...) end
      cont(...)
    end,env) 
  end,{'rulecheck',rule}) 
end

local function EXPR(expr,opts)
  return function()
    opts = opts or {}
    local res = {}
    local cont = opts.cont or function(...) 
      res = {...} 
      if not opts.no_expr_result then print(args2str(...)) end 
    end
    local src = opts.src or \"<expr>\"
    local err = opts.err or function(str) print(fmt(\"❌ '%s': %s\", src // 80,str)) end
    local env = createEnv(cont, err, opts)
    env.src = src
    env.env = opts.env or ER.ruleEnv
    expr(cont, env)
    return table.unpack(res)
  end
end

local funs = {
  IF = IF,
  IFA = IFA,
  AND = AND,
  OR = OR,
  WHILE = WHILE,
  REPEAT = REPEAT,
  FORIN = FORIN,
  LOOP = LOOP,
  PROGN = PROGN,
  CONST = CONST,
  AREF = AREF,
  BINOP = BINOP,
  UNOP = UNOP,
  CALL = CALL,
  CALLOBJ = CALLOBJ,
  GETPROP = GETPROP,
  FUNC = FUNC,
  EXPR = EXPR,
  RULE = RULE
}


local function compError(str,expr) 
  local dbg = expr._dbg or { to = 1, from = 1}
  local from,to = dbg.from,dbg.to
  ER.perror('Compiler',str,from,to,currentSrc,nil)
end

local compa, comp = function(_) end, {}

local function compileList(list) local r = {} for _,e in ipairs(list) do r[#r+1] = compa(e) end return r end

function comp.table(expr)
  if expr.const then return CONST(expr.value) end
  local args = {}
  for _,v in ipairs(expr.value) do
    local key = v.key and {type='const',value=v.key} or v.expr
    args[#args+1] = { expr = compa(key), value = compa(v.value) }
  end
  return TABLE(args)
end

locals = {}
local function pushLocals(ls) ls.__parent = locals; locals = ls end
local function popLocals() locals = locals.__parent end
local function isLocal(name) return locals and locals[name] end

function comp.block(expr,noframe)
  if expr.locals then pushLocals(expr.locals) end
  local args = compileList(expr.statements)
  if expr.locals then popLocals() end
  noframe = noframe or not expr.scope
  if #args == 1 then return noframe and args[1] or FRAME(args[1]) end
  return noframe and PROGN(table.unpack(args)) or FRAME(PROGN(table.unpack(args)))
end

function comp.binop(expr)
  if expr.op == 'assign' then compError(fmt(\"'assign' not allowed in%s expression\",(isHead and \" trigger\" or \"\")),expr) end
  local exp1 = compa(expr.exp1)
  local exp2 = compa(expr.exp2)
  return BINOP(expr.op, exp1, exp2)
end

function comp.seqop(expr)
  local args = compileList(expr.exprs)
  if expr.op == 'or' then return OR(table.unpack(args))
  elseif expr.op == 'and' then return AND(table.unpack(args))
  else error(\"Unknown seqop: \"..tostring(expr.op)) 
  end
end

function comp.unop(expr)
  return UNOP(expr.op, compa(expr.exp), expr.a, expr.b)
end

local builtin = {}
local BUILTIN = function(name)
  if builtin[name] then return funs[builtin[name]] end
  return nil
end

comp['break'] = function(expr)
  if isHead then compError(\"'break' not allowed in trigger expression\",expr) end
  return BREAK()
end

comp['breakif'] = function(expr)
  return IF(compa(expr.cond), BREAK())
end

function comp.call(expr)
  local args = compileList(expr.args)
  local fun = expr.fun.type == 'name' and BUILTIN(expr.fun.value) 
  if fun then return fun(table.unpack(args))
  else
    fun = compa(expr.fun)
    return CALL(fun, table.unpack(args))
  end
end

function comp.objcall(expr)
  local args = compileList(expr.args)
  local obj = compa(expr.obj)
  local fun = expr.fun
  return CALLOBJ(obj, fun, table.unpack(args))
end

function comp.name(expr) 
  if expr.vt == 'ev' then
    local cvar = ER.computedVar[expr.value]
    return VAR(expr.value,cvar) 
  elseif expr.vt == 'gv' then return GVAR(expr.value:sub(2)) 
  elseif expr.vt == 'qv' then return QVAR(expr.value:sub(3)) 
  elseif expr.vt == 'sv' then return IVAR(expr.value:sub(4)) 
  else error(\"Not implemented:\"..tostring(expr.vt)) end
end

comp['return'] = function(expr)
  if isHead then compError(\"'return' not allowed in trigger expression\",expr) end
  local args = compileList(expr.exp)
  return RETURN(table.unpack(args))
end


comp['if'] = function(expr)
  if isHead then compError(\"'if/case' not allowed in trigger expression\",expr) end
  local args = {}
  for _,c in ipairs(expr.args) do
    args[#args+1] = { cond = c.cond and compa(c.cond) or nil, body = compa(c.body) }
  end
  return IFA(args)
end

local function condFRAME(frame,expr) return frame and FRAME(expr) or expr end

comp['while'] = function(expr)
  if isHead then compError(\"'while' not allowed in trigger expression\",expr) end
  local frame,locals = expr.body.scope,expr.body.locals; expr.body.scope = nil
  return condFRAME(frame,WHILE(compa(expr.cond), compa(expr.body)))
end
comp['repeat'] = function(expr)
  if isHead then compError(\"'repeat' not allowed in trigger expression\",expr) end
  local frame,locals = expr.body.scope,expr.body.locals; expr.body.scope = nil
  return condFRAME(frame,REPEAT(compa(expr.cond), compa(expr.body)))
end

comp['loop'] = function(expr)
  if isHead then compError(\"'loop' not allowed in trigger expression\",expr) end
  local args = compileList(expr.statements)
  if #args == 1 then return LOOP(args[1]) end
  return LOOP(PROGN(table.unpack(args)))
end

comp['forin'] = function(expr)
  if isHead then compError(\"'for' not allowed in trigger expression\",expr) end
  return FORIN(expr.names,compa(expr.exp[1]),compa(expr.body))
end

function comp.num(expr) return CONST(expr.value) end
function comp.const(expr) return CONST(expr.value) end
function comp.str(expr) return CONST(expr.value) end

function comp.aref(expr)
  local table = compa(expr.tab)
  local key = compa({type='num',value=expr.idx})
  return AREF(table, key)
end

comp['local'] = function(expr)
  return LOCAL(expr.names,compileList(expr.exprs or {}))
end

function comp.assign(expr)
  if isHead then compError(\"'assign' not allowed in trigger expression\",expr) end
  local exprs = compileList(expr.exprs)
  local vars = {}
  for _,v in ipairs(expr.vars) do
    if v.type == 'name' then
      if v.vt == 'ev' then
      local var = v.value
      vars[#vars+1] = function(env,val,cont,i)
        if ER.triggerVars[var] then
          local oldValue = env:getVariable(var)
          if oldValue ~= val then
            ER.sourceTrigger:post({type='trigger-variable',name=var},0)
          end
        end
        env:setVariable(var,val,not isLocal(var)) 
        cont(i)
      end
    elseif v.vt == 'gv' then
      local var = v.value:sub(2)
      vars[#vars+1] = function(env,val,cont,i) 
        fibaro.setGlobalVariable(var,type(val)=='string' and val or json.encodeFast(val))
        cont(i)
      end
    elseif v.vt == 'qv' then
      local var = v.value:sub(3)
      vars[#vars+1] = function(env,val,cont,i) 
        quickApp:setVariable(var,val)
        cont(i)
      end
    elseif v.vt == 'sv' then
      local var = v.value:sub(4)
      vars[#vars+1] = function(env,val,cont,i) 
        quickApp:internalStorageSet(var,val)
        cont(i)
      end
    else
      error(\"Not implemented: \"..tostring(v.vt))
    end
    elseif v.type == 'aref' then
      local var = {tab=compa(v.tab), idx=v.idx}
      if type(var.idx) == 'table' then var.idx = compa(v.idx) end
      vars[#vars+1] = function(env,val,cont,i) --{type='aref',tab=compa(v.tab), idx=v.idx}
        var.tab(function(tab)
          if isCont(var.idx) then
            var.idx(function(idx)
              tab[idx] = val
              cont(i)
            end,env)
          else
            tab[v.idx] = val
            cont(i)
          end
        end,env)
      end
    elseif v.type == 'getprop' then
      local var = {obj=compa(v.obj), prop=v.prop}
      vars[#vars+1] = function(env,val,cont,i)
        var.obj(function(obj)
          if obj == nil then return env.error(\"Not a prop object: \"..tostring(var.obj)) end
          ER.executeSetProp(obj,var.prop,val,env)
          cont(i)
        end,env)
      end
    else
      error(\"Not supported assignment: \"..tostring(v.type))
    end
  end
  return ASSIGNM(vars, exprs)
end

function comp.incvar(expr) 
  if isHead then compError(\"'var incremental' not allowed in trigger expression\",expr) end
  return INCVAR(expr.name,expr.op,compa(expr.value)) 
end

function comp.getprop(expr) return GETPROP(expr.prop,compa(expr.obj)) end

local function makeVarAssign(var) return function(env,val,cont,i) env:setVariable(var,val) cont(i) end end

function comp.functiondef(expr)
  if isHead then compError(\"'function definition' not allowed in trigger expression\",expr) end
  local fun = compa(expr.fun)
  return ASSIGNM({makeVarAssign(expr.name[1])},{fun})
end

comp['function'] = function(expr)
  local fun = compa(expr.body)
  return FRAME(FUNC(expr.params, fun))
end

comp['functionexpr'] = function(expr) return compa(expr.fun) end

comp['varargstable'] = function(expr) return VARARGSTABLE() end

function compa(expr)
  if comp[expr.type] then return comp[expr.type](expr)
  else error(\"Not implemented:\"..tostring(expr.type)) end
end

function compile(ast)
  if ast.type == 'block' then
    return comp.block(ast,false)
  elseif ast.type == 'ruledef' then
    local head = ast.head
    local body = ast.body
    isHead = true
    local h = compa(head)
    isHead = false
    local b = compa(body)
    return IF(RULECHECK(h),b)
  else error(\"Not implemented:\"..tostring(ast.type)) end
end

local function eval(str,opts)
  assert(type(str) == \"string\",\"Expected string\")
  currentSrc = str
  opts = opts or {}
  local isRule = false
  local stat,ast = xpcall(function()
    local tkns = ER.tokenize(str)
    if opts.tokens then tkns.dump() end
    if tkns.containsType('t_rule') then
      table.insert(tkns.stream,1,{type='t_rulebegin',dbg={from=0,to=0}})
      table.insert(tkns.stream,{type='t_ruleend',dbg={from=0,to=0}})
      isRule = true
    end
    ast,j,k = ER.parse(tkns)
    return ast
  end,function(e)
    if fibaro.plua then 
      local info = debug.getinfo(2)
       dbg = debug.traceback()
    end
    return e
  end)
  if not stat then fibaro.error(__TAG,fmt(\"%s %s\",\"❌\",tostring(ast))) return idfun end
  if opts.tree then print(json.encodeFormated(ast)) end
  locals = nil
    local cstat,res = pcall(function()
    local cont = compile(ast)
    opts.src = ast._src
    return isRule and RULE(cont,opts) or EXPR(cont,opts)
  end)
  if not cstat then print(res) return idfun else return res end
end

ER.compile = compile
ER.eval = eval
ER.ASYNCFUN = ASYNCFUN
ER.COMPFUNS = funs","isMain":false,"isOpen":false},{"type":"lua","name":"utils","content":"fibaro.EventRunner = fibaro.EventRunner or { debugFlags = {} }
local ER = fibaro.EventRunner
local debugFlags = ER.debugFlags

local fmt = string.format

getmetatable(\"\").__idiv = function(str,len) return (#str < len or #str < 4) and str or str:sub(1,len-2)..\"..\" end -- truncate strings

local function copy(obj)
  if type(obj) == 'table' then
    local res = {} for k,v in pairs(obj) do res[k] = copy(v) end
    return res
  else return obj end
end

local function copyShallow(obj)
  if type(obj) == 'table' then
    local res = {} for k,v in pairs(obj) do res[k] = v end
    return res
  else return obj end
end

local function equal(e1,e2)
  if e1==e2 then return true
  else
    if type(e1) ~= 'table' or type(e2) ~= 'table' then return false
    else
      for k1,v1 in pairs(e1) do if e2[k1] == nil or not equal(v1,e2[k1]) then return false end end
      for k2,_  in pairs(e2) do if e1[k2] == nil then return false end end
      return true
    end
  end
end

table.copy = copy
table.copyShallow = copyShallow
table.equal = equal

function string.split(str, sep)
    local fields, s = {}, sep or \"%s\"
    str:gsub(\"([^\" .. s .. \"]+)\", function(c)
        fields[#fields + 1] = c
    end)
    return fields
end

if not table.maxn then 
  function table.maxn(tbl) local c=0 for i,_ in pairs(tbl) do c=i end return c end
end

function table.map(f,l,s) s = s or 1; local r,m={},table.maxn(l) for i=s,m do r[#r+1] = f(l[i]) end return r end
function table.mapf(f,l,s) s = s or 1; local e=true for i=s,table.maxn(l) do e = f(l[i]) end return e end
function table.mapAnd(f,l,s) s = s or 1; local e=true for i=s,table.maxn(l) do e = f(l[i]) if not e then return false end end return e end 
function table.mapOr(f,l,s) s = s or 1; for i=s,table.maxn(l) do local e = f(l[i]) if e then return e end end return false end
function table.reduce(f,l) local r = {}; for _,e in ipairs(l) do if f(e) then r[#r+1]=e end end; return r end
function table.mapk(f,l) local r={}; for k,v in pairs(l) do r[k]=f(v) end; return r end
function table.mapkv(f,l) local r={}; for k,v in pairs(l) do k,v=f(k,v) if k then r[k]=v end end; return r end
function table.mapkl(f,l) local r={} for i,j in pairs(l) do r[#r+1]=f(i,j) end return r end
function table.size(l) local n=0; for _,_ in pairs(l) do n=n+1 end return n end 

--------------- Time and Sun calc  functions -----------------------
local function toSeconds(str)
  __assert_type(str,\"string\" )
  local sun = str:match(\"(sun%a+)\")
  if sun then return toSeconds(str:gsub(sun,fibaro.getValue(1,sun..\"Hour\"))) end
  local var = str:match(\"(%$[A-Za-z]+)\")
  if var then return toSeconds(str:gsub(var,fibaro.getGlobalVariable(var:sub(2)))) end
  local h,m,s,op,off=str:match(\"(%d%d):(%d%d):?(%d*)([+%-]*)([%d:]*)\")
  off = off~=\"\" and (off:find(\":\") and toSeconds(off) or toSeconds(\"00:00:\"..off)) or 0
  return 3600*h+60*m+(s~=\"\" and s or 0)+((op=='-' or op =='+-') and -1 or 1)*off
end

---@diagnostic disable-next-line: param-type-mismatch
local function midnight() local t = os.date(\"*t\"); t.hour,t.min,t.sec = 0,0,0; return os.time(t) end
local function getWeekNumber(tm) return tonumber(os.date(\"%V\",tm)) end
local function now() return os.time()-midnight() end

local function between(start,stop,optTime)
  __assert_type(start,\"string\" )
  __assert_type(stop,\"string\" )
  start,stop,optTime=toSeconds(start),toSeconds(stop),optTime and toSeconds(optTime) or toSeconds(os.date(\"%H:%M\"))
  stop = stop>=start and stop or stop+24*3600
  optTime = optTime>=start and optTime or optTime+24*3600
  return start <= optTime and optTime <= stop
end
local function time2str(t) return fmt(\"%02d:%02d:%02d\",math.floor(t/3600),math.floor((t%3600)/60),t%60) end

local sunCalc 

local function hm2sec(hmstr,ns)
  local n = tonumber(hmstr)
  if n then return n end
  local offs,sun
  sun,offs = hmstr:match(\"^(%a+)([+-]?%d*)\")
  if sun and (sun == 'sunset' or sun == 'sunrise') then
    if ns then
      local sunrise,sunset = sunCalc(os.time()+24*3600)
      hmstr,offs = sun=='sunrise' and sunrise or sunset, tonumber(offs) or 0
    else
      hmstr,offs = fibaro.getValue(1,sun..\"Hour\"), tonumber(offs) or 0
    end
  end
  local sg,h,m,s = hmstr:match(\"^(%-?)(%d+):(%d+):?(%d*)\")
  if not (h and m) then error(fmt(\"Bad hm2sec string %s\",hmstr)) end
  return (sg == '-' and -1 or 1)*(tonumber(h)*3600+tonumber(m)*60+(tonumber(s) or 0)+(tonumber(offs or 0))*60)
end

-- toTime(\"10:00\")     -> 10*3600+0*60 secs
-- toTime(\"10:00:05\")  -> 10*3600+0*60+5*1 secs
-- toTime(\"t/10:00\")    -> (t)oday at 10:00. midnight+10*3600+0*60 secs
-- toTime(\"n/10:00\")    -> (n)ext time. today at 10.00AM if called before (or at) 10.00AM else 10:00AM next day
-- toTime(\"+/10:00\")    -> Plus time. os.time() + 10 hours
-- toTime(\"+/00:01:22\") -> Plus time. os.time() + 1min and 22sec
-- toTime(\"sunset\")     -> todays sunset in relative secs since midnight, E.g. sunset=\"05:10\", =>toTime(\"05:10\")
-- toTime(\"sunrise\")    -> todays sunrise
-- toTime(\"sunset+10\")  -> todays sunset + 10min. E.g. sunset=\"05:10\", =>toTime(\"05:10\")+10*60
-- toTime(\"sunrise-5\")  -> todays sunrise - 5min
-- toTime(\"t/sunset+10\")-> (t)oday at sunset in 'absolute' time. E.g. midnight+toTime(\"sunset+10\")

local function toTime(time)
  if type(time) == 'number' then return time end
  local p = time:sub(1,2)
  if p == '+/' then return hm2sec(time:sub(3))+os.time()
  elseif p == 'n/' then
    local t1,t2 = midnight()+hm2sec(time:sub(3),true),os.time()
    return t1 > t2 and t1 or t1+24*60*60
  elseif p == 't/' then return  hm2sec(time:sub(3))+midnight()
  else return hm2sec(time) end
end

local function sunturnTime(date, rising, latitude, longitude, zenith, local_offset)
  local rad,deg,floor = math.rad,math.deg,math.floor
  local frac = function(n) return n - floor(n) end
  local cos = function(d) return math.cos(rad(d)) end
  local acos = function(d) return deg(math.acos(d)) end
  local sin = function(d) return math.sin(rad(d)) end
  local asin = function(d) return deg(math.asin(d)) end
  local tan = function(d) return math.tan(rad(d)) end
  local atan = function(d) return deg(math.atan(d)) end
  
  local function day_of_year(date2)
    local n1 = floor(275 * date2.month / 9)
    local n2 = floor((date2.month + 9) / 12)
    local n3 = (1 + floor((date2.year - 4 * floor(date2.year / 4) + 2) / 3))
    return n1 - (n2 * n3) + date2.day - 30
  end
  
  local function fit_into_range(val, min, max)
    local range,count = max - min,nil
    if val < min then count = floor((min - val) / range) + 1; return val + count * range
    elseif val >= max then count = floor((val - max) / range) + 1; return val - count * range
    else return val end
  end
  
  -- Convert the longitude to hour value and calculate an approximate time
  local n,lng_hour,t =  day_of_year(date), longitude / 15,nil
  if rising then t = n + ((6 - lng_hour) / 24) -- Rising time is desired
  else t = n + ((18 - lng_hour) / 24) end -- Setting time is desired
  local M = (0.9856 * t) - 3.289 -- Calculate the Sun^s mean anomaly
  -- Calculate the Sun^s true longitude
  local L = fit_into_range(M + (1.916 * sin(M)) + (0.020 * sin(2 * M)) + 282.634, 0, 360)
  -- Calculate the Sun^s right ascension
  local RA = fit_into_range(atan(0.91764 * tan(L)), 0, 360)
  -- Right ascension value needs to be in the same quadrant as L
  local Lquadrant = floor(L / 90) * 90
  local RAquadrant = floor(RA / 90) * 90
  RA = RA + Lquadrant - RAquadrant; RA = RA / 15 -- Right ascension value needs to be converted into hours
  local sinDec = 0.39782 * sin(L) -- Calculate the Sun's declination
  local cosDec = cos(asin(sinDec))
  local cosH = (cos(zenith) - (sinDec * sin(latitude))) / (cosDec * cos(latitude)) -- Calculate the Sun^s local hour angle
  if rising and cosH > 1 then return -1 --\"N/R\" -- The sun never rises on this location on the specified date
  elseif cosH < -1 then return -1 end --\"N/S\" end -- The sun never sets on this location on the specified date
  
  local H -- Finish calculating H and convert into hours
  if rising then H = 360 - acos(cosH)
  else H = acos(cosH) end
  H = H / 15
  local T = H + RA - (0.06571 * t) - 6.622 -- Calculate local mean time of rising/setting
  local UT = fit_into_range(T - lng_hour, 0, 24) -- Adjust back to UTC
  local LT = UT + local_offset -- Convert UT value to local time zone of latitude/longitude
  ---@diagnostic disable-next-line: missing-fields
  return os.time({day = date.day,month = date.month,year = date.year,hour = floor(LT),min = math.modf(frac(LT) * 60)})
end

---@diagnostic disable-next-line: param-type-mismatch
local function getTimezone() local now = os.time() return os.difftime(now, os.time(os.date(\"!*t\", now))) end

function sunCalc(time)
  local hc3Location = api.get(\"/settings/location\")
  local lat = hc3Location.latitude or 0
  local lon = hc3Location.longitude or 0
  local utc = getTimezone() / 3600
  local zenith,zenith_twilight = 90.83, 96.0 -- sunset/sunrise 90°50′, civil twilight 96°0′
  
  local date = os.date(\"*t\",time or os.time())
  if date.isdst then utc = utc + 1 end
  local rise_time = os.date(\"*t\", sunturnTime(date, true, lat, lon, zenith, utc))
  local set_time = os.date(\"*t\", sunturnTime(date, false, lat, lon, zenith, utc))
  local rise_time_t = os.date(\"*t\", sunturnTime(date, true, lat, lon, zenith_twilight, utc))
  local set_time_t = os.date(\"*t\", sunturnTime(date, false, lat, lon, zenith_twilight, utc))
  local sunrise = rise_time.hour*3600 + rise_time.min*60
  local sunset = set_time.hour*3600 + set_time.min*60
  local sunrise_t = rise_time_t.hour*3600 + rise_time_t.min*60
  local sunset_t = set_time_t.hour*3600 + set_time_t.min*60
  return sunrise, sunset, sunrise_t, sunset_t
end

local function dateTest(dateStr0)
  local days = {sun=1,mon=2,tue=3,wed=4,thu=5,fri=6,sat=7}
  local months = {jan=1,feb=2,mar=3,apr=4,may=5,jun=6,jul=7,aug=8,sep=9,oct=10,nov=11,dec=12}
  local last,month = {31,28,31,30,31,30,31,31,30,31,30,31},nil
  
  local function seq2map(seq) local s = {} for _,v in ipairs(seq) do s[v] = true end return s; end
  
  local function flatten(seq,res) -- flattens a table of tables
    res = res or {}
    if type(seq) == 'table' then for _,v1 in ipairs(seq) do flatten(v1,res) end else res[#res+1] = seq end
    return res
  end
  
  local function _assert(test,msg,...) if not test then error(fmt(msg,...),3) end end
  
  local function expandDate(w1,md)
    local function resolve(id)
      local res
      if id == 'last' then month = md res=last[md]
      elseif id == 'lastw' then month = md res=last[md]-6
      else res= type(id) == 'number' and id or days[id] or months[id] or tonumber(id) end
      _assert(res,\"Bad date specifier '%s'\",id) return res
    end
    local step = tonumber(1)
    local w,m = w1[1],w1[2]
    local start,stop = w:match(\"(%w+)%p(%w+)\")
    if (start == nil) then return resolve(w) end
    start,stop = resolve(start), resolve(stop)
    local res,res2 = {},{}
    if w:find(\"/\") then
      if not w:find(\"-\") then -- 10/2
        step=stop; stop = m.max
      else step=(w:match(\"/(%d+)\")) end
    end
    step = tonumber(step)
    _assert(start>=m.min and start<=m.max and stop>=m.min and stop<=m.max,\"illegal date intervall\")
    while (start ~= stop) do -- 10-2
      res[#res+1] = start
      start = start+1; if start>m.max then start=m.min end
    end
    res[#res+1] = stop
    if step > 1 then for i=1,#res,step do res2[#res2+1]=res[i] end; res=res2 end
    return res
  end
  
  local function parseDateStr(dateStr) --,last)
    local map = table.map
    local seq = string.split(dateStr,\" \")   -- min,hour,day,month,wday
    local lim = {{min=0,max=59},{min=0,max=23},{min=1,max=31},{min=1,max=12},{min=1,max=7},{min=2000,max=3000}}
    for i=1,6 do if seq[i]=='*' or seq[i]==nil then seq[i]=tostring(lim[i].min)..\"-\"..lim[i].max end end
    seq = map(function(w) return string.split(w,\",\") end, seq)   -- split sequences \"3,4\"
    local month0 = os.date(\"*t\",os.time()).month
    seq = map(function(t) 
      local m = table.remove(lim,1);
      return flatten(map(function (g) return expandDate({g,m},month0) end, t)) 
    end, seq) -- expand intervalls \"3-5\"
    return map(seq2map,seq)
  end
  local sun,offs,day,sunPatch = dateStr0:match(\"^(sun%a+) ([%+%-]?%d+)\")
  if sun then
    sun = sun..\"Hour\"
    dateStr0=dateStr0:gsub(\"sun%a+ [%+%-]?%d+\",\"0 0\")
    sunPatch=function(dateSeq)
      local h,m = (fibaro.getValue(1,sun)):match(\"(%d%d):(%d%d)\")
      dateSeq[1]={[(tonumber(h)*60+tonumber(m)+tonumber(offs))%60]=true}
      dateSeq[2]={[math.floor((tonumber(h)*60+tonumber(m)+tonumber(offs))/60)]=true}
    end
  end
  local dateSeq = parseDateStr(dateStr0)
  return function() -- Pretty efficient way of testing dates...
    local t = os.date(\"*t\",os.time())
    if month and month~=t.month then dateSeq=parseDateStr(dateStr0) end -- Recalculate 'last' every month
    if sunPatch and (month and month~=t.month or day~=t.day) then sunPatch(dateSeq) day=t.day end -- Recalculate sunset/sunrise
    return
    dateSeq[1][t.min] and    -- min     0-59
    dateSeq[2][t.hour] and   -- hour    0-23
    dateSeq[3][t.day] and    -- day     1-31
    dateSeq[4][t.month] and  -- month   1-12
    dateSeq[5][t.wday] or false      -- weekday 1-7, 1=sun, 7=sat
  end
end

ER.eventFormatter = {}
--------------- Event engine -------------------
local EventMT = { 
  __tostring = function(ev)
    if ER.eventFormatter[ev.type or \"\"] then
      local f = ER.eventFormatter[ev.type or \"\"](ev)
      if f then return f end
    end
    local s = json.encodeFast(ev)
    if s:sub(1,1)=='#' then return s end
    local m = s:match(\"^.-,(.*)}$\") or \"\"
    return fmt(\"#%s{%s}\",ev.type,m) 
  end
}
ER.EventMT = EventMT

local function createEventEngine()
  local self = {}
  local HANDLER = '%EVENTHANDLER%'
  local BREAK = '%BREAK%'
  self.BREAK = BREAK
  local handlers = {}
  local function isEvent(e) return type(e) == 'table' and type(e.type)=='string' end
  
  local function coerce(x,y) local x1 = tonumber(x) if x1 then return x1,tonumber(y) else return x,y end end
  local constraints = {}
  constraints['=='] = function(val) return function(x) x,val=coerce(x,val) return x == val end end
  constraints['<>'] = function(val) return function(x) return tostring(x):match(val) end end
  constraints['>='] = function(val) return function(x) x,val=coerce(x,val) return x >= val end end
  constraints['<='] = function(val) return function(x) x,val=coerce(x,val) return x <= val end end
  constraints['>'] = function(val) return function(x) x,val=coerce(x,val) return x > val end end
  constraints['<'] = function(val) return function(x) x,val=coerce(x,val) return x < val end end
  constraints['~='] = function(val) return function(x) x,val=coerce(x,val) return x ~= val end end
  constraints[''] = function(_) return function(x) return x ~= nil end end
  
  local function compilePattern2(pattern)
    if type(pattern) == 'table' then
      if pattern._var_ then return end
      for k,v in pairs(pattern) do
        if type(v) == 'string' and v:sub(1,1) == '$' then
          local var,op,val = v:match(\"$([%w_]*)([<>=~]*)(.*)\")
          var = var ==\"\" and \"_\" or var
          local c = constraints[op](tonumber(val) or val)
          pattern[k] = {_var_=var, _constr=c, _str=v}
        else compilePattern2(v) end
      end
    end
    return pattern
  end
  
  local function compilePattern(pattern)
    pattern = compilePattern2(copy(pattern))
    assert(pattern)
    if pattern.type and type(pattern.id)=='table' and not pattern.id._constr then
      local m = {}; for _,id in ipairs(pattern.id) do m[id]=true end
      pattern.id = {_var_='_', _constr=function(val) return m[val] end, _str=pattern.id}
    end
    return pattern
  end
  self.compilePattern = compilePattern
  
  local function match(pattern0, expr0)
    local matches = {}
    local function unify(pattern,expr)
      if pattern == expr then return true
      elseif type(pattern) == 'table' then
        if pattern._var_ then
          local var, constr = pattern._var_, pattern._constr
          if var == '_' then return constr(expr)
          elseif matches[var] then return constr(expr) and unify(matches[var],expr) -- Hmm, equal?
          else matches[var] = expr return constr(expr) end
        end
        if type(expr) ~= \"table\" then return false end
        for k,v in pairs(pattern) do if not unify(v,expr[k]) then return false end end
        return true
      else return false end
    end
    return unify(pattern0,expr0) and matches or false
  end
  self.match = match
  
  local function invokeHandler(env)
    local t = os.time()
    env.last,env.rule.time = t-(env.rule.time or 0),t
    local status, res = pcall(env.rule.action,env) -- call the associated action
    if not status then
      --if type(res)=='string' and not debugFlags.extendedErrors then res = res:gsub(\"(%[.-%]:%d+:)\",\"\") end
      --fibaro.errorf(nil,\"in %s: %s\",env.rule.doc,res)
      env.rule._disabled = true -- disable rule to not generate more errors
      fibaro.error(__TAG,res)
      --em.stats.errors=(em.stats.errors or 0)+1
    else return res end
  end
  
  local toTime = self.toTime
  function self.post(ev,t,log,hook,customLog)
    local now,isEv = os.time(),isEvent(ev)
    t = type(t)=='string' and toTime(t) or t or 0
    if t < 0 then return elseif t < now then t = t+now end
    if debugFlags.post and (type(ev)=='function' or not ev._sh) then
      if isEv and not getmetatable(ev) then setmetatable(ev,EventMT) end
      (customLog or fibaro.trace)(__TAG,fmt(\"Posting %s at %s %s\",tostring(ev),os.date(\"%c\",t),type(log)=='string' and (\"(\"..log..\")\") or \"\"))
    end
    if type(ev) == 'function' then
      return setTimeout(function() ev(ev) end,1000*(t-now)),t
    elseif isEv then
      if not getmetatable(ev) then setmetatable(ev,EventMT) end
      local ref; ref = setTimeout(function() if hook then hook(ref) end self.handleEvent(ev) end,1000*(t-now))
      return ref,t
    else
      error(\"post(...) not event or fun;\"..tostring(ev))
    end
  end
  
  function self.cancel(id) clearTimeout(id) end
  
  local toHash,fromHash={},{}
  fromHash['device'] = function(e) return {\"device\"..e.id..e.property,\"device\"..e.id,\"device\"..e.property,\"device\"} end
  fromHash['global-variable'] = function(e) return {'global-variable'..e.name,'global-variable'} end
  fromHash['trigger-variable'] = function(e) return {'trigger-variable'..e.name,'trigger-variable'} end
  fromHash['quickvar'] = function(e) return {\"quickvar\"..e.id..e.name,\"quickvar\"..e.id,\"quickvar\"..e.name,\"quickvar\"} end
  fromHash['profile'] = function(e) return {'profile'..e.property,'profile'} end
  fromHash['weather'] = function(e) return {'weather'..e.property,'weather'} end
  fromHash['custom-event'] = function(e) return {'custom-event'..e.name,'custom-event'} end
  fromHash['deviceEvent'] = function(e) return {\"deviceEvent\"..e.id..e.value,\"deviceEvent\"..e.id,\"deviceEvent\"..e.value,\"deviceEvent\"} end
  fromHash['sceneEvent'] = function(e) return {\"sceneEvent\"..e.id..e.value,\"sceneEvent\"..e.id,\"sceneEvent\"..e.value,\"sceneEvent\"} end
  fromHash['Daily'] = function(e) return {'daily'..e.id,'daily'} end
  fromHash['Interval'] = function(e) return {'interval'..e.id,'interval'} end

  toHash['device'] = function(e) return \"device\"..(e.id or \"\")..(e.property or \"\") end
  toHash['global-variable'] = function(e) return 'global-variable'..(e.name or \"\") end
  toHash['trigger-variable'] = function(e) return 'trigger-variable'..(e.name or \"\") end
  toHash['quickvar'] = function(e) return 'quickvar'..(e.id or \"\")..(e.name or \"\") end
  toHash['profile'] = function(e) return 'profile'..(e.property or \"\") end
  toHash['weather'] = function(e) return 'weather'..(e.property or \"\") end
  toHash['custom-event'] = function(e) return 'custom-event'..(e.name or \"\") end
  toHash['deviceEvent'] = function(e) return 'deviceEvent'..(e.id or \"\")..(e.value or \"\") end
  toHash['sceneEvent'] = function(e) return 'sceneEvent'..(e.id or \"\")..(e.value or \"\") end
  toHash['Daily'] = function(e) return 'daily'..(e.id or \"\") end
  toHash['Interval'] = function(e) return 'interval'..(e.id or \"\") end


  local MTrule = { __tostring = function(self) return fmt(\"SourceTriggerSub:%s\",self.event.type) end }
  function self.addEventHandler(pattern,fun,doc)
    if not isEvent(pattern) then error(\"Bad event pattern, needs .type field\") end
    assert(type(fun)=='func'..'tion', \"Second argument must be Lua func\")
    local cpattern = compilePattern(pattern)
    local rule,hashKeys = {[HANDLER]=cpattern, event=pattern, action=fun, doc=doc},{}
    if toHash[pattern.type] and pattern.id and type(pattern.id) == 'table' then
      local oldid=pattern.id
      for _,id in ipairs(pattern.id) do
        pattern.id = id
        hashKeys[#hashKeys+1] = toHash[pattern.type](pattern)
        pattern.id = oldid
      end
    else hashKeys = {toHash[pattern.type] and toHash[pattern.type](pattern) or pattern.type} end
    for _,hashKey in ipairs(hashKeys) do
      handlers[hashKey] = handlers[hashKey] or {}
      local rules,fn = handlers[hashKey],true
      for _,rs in ipairs(rules) do -- Collect handlers with identical patterns. {{e1,e2,e3},{e1,e2,e3}}
        if equal(cpattern,rs[1].event) then
          rs[#rs+1] = rule
          fn = false break
        end
      end
      if fn then rules[#rules+1] = {rule} end
    end
    rule.enable = function() rule._disabled = nil return rule end
    rule.disable = function() rule._disabled = true return rule end
    return rule
  end
  
  function self.removeEventHandler(rule)
    local pattern,fun = rule.event,rule.action
    local hashKey = toHash[pattern.type] and toHash[pattern.type](pattern) or pattern.type
    local rules,i,j= handlers[hashKey] or {},1,1
    while j <= #rules do
      local rs = rules[j]
      while i <= #rs do
        if rs[i].action==fun then
          table.remove(rs,i)
        else i=i+i end
      end
      if #rs==0 then table.remove(rules,j) else j=j+1 end
    end
  end
  
  local callbacks = {}
  function self.registerCallback(fun) callbacks[#callbacks+1] = fun end
  
  function self.handleEvent(ev,firingTime)
    for _,cb in ipairs(callbacks) do cb(ev) end
    
    local hasKeys = fromHash[ev.type] and fromHash[ev.type](ev) or {ev.type}
    for _,hashKey in ipairs(hasKeys) do
      for _,rules in ipairs(handlers[hashKey] or {}) do -- Check all rules of 'type'
        local i,m=1,nil
        for j=1,#rules do
          if not rules[j]._disabled then    -- find first enabled rule, among rules with same head
            m = match(rules[i][HANDLER],ev) -- and match against that rule
            break
          end
        end
        if m then                           -- we have a match
          for j=i,#rules do                 -- executes all rules with same head
            local rule=rules[j]
            if not rule._disabled then
              if invokeHandler({event = ev, time = firingTime, p=m, rule=rule}) == BREAK then return end
            end
          end
        end
      end
    end
  end
  
  -- This can be used to \"post\" an event into this QA... Ex. fibaro.call(ID,'RECIEVE_EVENT',{type='myEvent'})
  function QuickApp.RECIEVE_EVENT(_,ev)
    assert(isEvent(ev),\"Bad argument to remote event\")
    local time = ev.ev._time
    ev,ev.ev._time = ev.ev,nil
    setmetatable(ev,EventMT)
    if time and time+5 < os.time() then fibaro.warning(__TAG,fmt(\"Slow events %s, %ss\",tostring(ev),os.time()-time)) end
    self.post(ev)
  end
  
  function self.postRemote(uuid,id,ev)
    if ev == nil then
      id,ev = uuid,id
      assert(tonumber(id) and isEvent(ev),\"Bad argument to postRemote\")
      ev._from,ev._time = plugin.mainDeviceId,os.time()
      fibaro.call(id,'RECIEVE_EVENT',{type='EVENT',ev=ev}) -- We need this as the system converts \"99\" to 99 and other \"helpful\" conversions
    else
      -- post to slave box in the future
    end
  end
  
  return self
end -- createEventEngine

local function quickVarEvent(d,_,post)
  local old={}; for _,v in ipairs(d.oldValue) do old[v.name] = v.value end
  for _,v in ipairs(d.newValue) do
    if not equal(v.value,old[v.name]) then
      post({type='quickvar', id=d.id, name=v.name, value=v.value, old=old[v.name]})
    end
  end
end

-- There are more, but these are what I seen so far...

local EventTypes = {
  AlarmPartitionArmedEvent = function(d,_,post) post({type='alarm', property='armed', id = d.partitionId, value=d.armed}) end,
  AlarmPartitionBreachedEvent = function(d,_,post) post({type='alarm', property='breached', id = d.partitionId, value=d.breached}) end,
  AlarmPartitionModifiedEvent = function(d,_,post) print(json.encode(d)) end,
  HomeArmStateChangedEvent = function(d,_,post) post({type='alarm', property='homeArmed', value=d.newValue}) end,
  HomeDisarmStateChangedEvent = function(d,_,post) post({type='alarm', property='homeArmed', value=not d.newValue}) end,
  HomeBreachedEvent = function(d,_,post) post({type='alarm', property='homeBreached', value=d.breached}) end,
  WeatherChangedEvent = function(d,_,post) post({type='weather',property=d.change, value=d.newValue, old=d.oldValue}) end,
  GlobalVariableChangedEvent = function(d,_,post) post({type='global-variable', name=d.variableName, value=d.newValue, old=d.oldValue}) end,
  GlobalVariableAddedEvent = function(d,_,post) post({type='global-variable', name=d.variableName, value=d.value, old=nil}) end,
  DevicePropertyUpdatedEvent = function(d,_,post)
    if d.property=='quickAppVariables' then quickVarEvent(d,_,post)
    else
      post({type='device', id=d.id or d.deviceId, property=d.property, value=d.newValue, old=d.oldValue})
    end
  end,
  CentralSceneEvent = function(d,_,post)
    d.id,d.icon = d.id or d.deviceId,nil
    post({type='device', property='centralSceneEvent', id=d.id, value={keyId=d.keyId, keyAttribute=d.keyAttribute}})
  end,
  SceneActivationEvent = function(d,_,post)
    d.id = d.id or d.deviceId
    post({type='device', property='sceneActivationEvent', id=d.id, value={sceneId=d.sceneId}})
  end,
  AccessControlEvent = function(d,_,post)
    post({type='device', property='accessControlEvent', id=d.id, value=d})
  end,
  CustomEvent = function(d,_,post)
    local value = api.get(\"/customEvents/\"..d.name)
    post({type='custom-event', name=d.name, value=value and value.userDescription})
  end,
  PluginChangedViewEvent = function(d,_,post) post({type='PluginChangedViewEvent', value=d}) end,
  WizardStepStateChangedEvent = function(d,_,post) post({type='WizardStepStateChangedEvent', value=d})  end,
  UpdateReadyEvent = function(d,_,post) post({type='updateReadyEvent', value=d}) end,
  DeviceRemovedEvent = function(d,_,post)  post({type='deviceEvent', id=d.id, value='removed'}) end,
  DeviceChangedRoomEvent = function(d,_,post)  post({type='deviceEvent', id=d.id, value='changedRoom'}) end,
  DeviceCreatedEvent = function(d,_,post)  post({type='deviceEvent', id=d.id, value='created'}) end,
  DeviceModifiedEvent = function(d,_,post) post({type='deviceEvent', id=d.id, value='modified'}) end,
  PluginProcessCrashedEvent = function(d,_,post) post({type='deviceEvent', id=d.deviceId, value='crashed', error=d.error}) end,
  SceneStartedEvent = function(d,_,post)   post({type='sceneEvent', id=d.id, value='started'}) end,
  SceneFinishedEvent = function(d,_,post)  post({type='sceneEvent', id=d.id, value='finished'})end,
  SceneRunningInstancesEvent = function(d,_,post) post({type='sceneEvent', id=d.id, value='instance', instance=d}) end,
  SceneRemovedEvent = function(d,_,post)  post({type='sceneEvent', id=d.id, value='removed'}) end,
  SceneModifiedEvent = function(d,_,post)  post({type='sceneEvent', id=d.id, value='modified'}) end,
  SceneCreatedEvent = function(d,_,post)  post({type='sceneEvent', id=d.id, value='created'}) end,
  OnlineStatusUpdatedEvent = function(d,_,post) post({type='onlineEvent', value=d.online}) end,
  ActiveProfileChangedEvent = function(d,_,post)
    post({type='profile',property='activeProfile',value=d.newActiveProfile, old=d.oldActiveProfile})
  end,
  ClimateZoneChangedEvent = function(d,_,post) --ClimateZoneChangedEvent
    if d.changes and type(d.changes)=='table' then
      for _,c in ipairs(d.changes) do
        c.type,c.id='ClimateZone',d.id
        post(c)
      end
    end
  end,
  ClimateZoneSetpointChangedEvent = function(d,_,post) d.type = 'ClimateZoneSetpoint' post(d,_,post) end,
  NotificationCreatedEvent = function(d,_,post) post({type='notification', id=d.id, value='created'}) end,
  NotificationRemovedEvent = function(d,_,post) post({type='notification', id=d.id, value='removed'}) end,
  NotificationUpdatedEvent = function(d,_,post) post({type='notification', id=d.id, value='updated'}) end,
  RoomCreatedEvent = function(d,_,post) post({type='room', id=d.id, value='created'}) end,
  RoomRemovedEvent = function(d,_,post) post({type='room', id=d.id, value='removed'}) end,
  RoomModifiedEvent = function(d,_,post) post({type='room', id=d.id, value='modified'}) end,
  SectionCreatedEvent = function(d,_,post) post({type='section', id=d.id, value='created'}) end,
  SectionRemovedEvent = function(d,_,post) post({type='section', id=d.id, value='removed'}) end,
  SectionModifiedEvent = function(d,_,post) post({type='section', id=d.id, value='modified'}) end,
  QuickAppFilesChangedEvent = function(_) end,
  ZwaveDeviceParametersChangedEvent = function(_) end,
  ZwaveNodeAddedEvent = function(_) end,
  RefreshRequiredEvent = function(_) end,
  DeviceFirmwareUpdateEvent = function(_) end,
  GeofenceEvent = function(d,_,post) post({type='location',id=d.userId,property=d.locationId,value=d.geofenceAction,timestamp=d.timestamp}) end,
  DeviceActionRanEvent = function(d,e,post)
    if e.sourceType=='user' then
      post({type='user',id=e.sourceId,value='action',data=d})
    elseif e.sourceType=='system' then
      post({type='system',value='action',data=d})
    end
  end,
}

local aEventEngine = nil

SourceTrigger = {}
class 'SourceTrigger'
function SourceTrigger:__init()
  self.refresh = RefreshStateSubscriber()
  self.eventEngine = createEventEngine()
  aEventEngine = self.eventEngine
  local function post(event,firingTime)
    setmetatable(event,EventMT)
    if debugFlags.sourceTrigger and not (debugFlags.ignoreSourceTrigger and  debugFlags.ignoreSourceTrigger[event.type]) then 
      fibaro.trace(__TAG,fmt(\"SourceTrigger: %s\",tostring(event) // (debugFlags.truncLog or 100)))
    end
    self.eventEngine.handleEvent(event,firingTime)
  end
  local function filter(ev)
    if debugFlags.refreshEvents then
      fibaro.trace(__TAG,fmt(\"RefreshEvent: %s:%s\",ev.type,json.encodeFast(ev.data)) // (debugFlags.truncLog or 80))
    end
    return true
  end
  local function handler(ev)
    if EventTypes[ev.type] then
      EventTypes[ev.type](ev.data,ev,post)
    end
  end
  self.refresh:subscribe(filter,handler)
end
function SourceTrigger:run() self.refresh:run() end
function SourceTrigger:subscribe(event,handler) --> subscription
  return self.eventEngine.addEventHandler(event,handler)
end
function SourceTrigger:unsubscribe(subscription)
  self.eventEngine.removeEventHandler(subscription)
end
function SourceTrigger:enableSubscription(subscription)
  subscription.enable()
end
function SourceTrigger:disableSubscription(subscription)
  subscription.disable()
end
function SourceTrigger:post(event,time,log,hook,customLog)
  return self.eventEngine.post(event,time,log,hook,customLog)
end
function SourceTrigger:registerCallback(fun)
  return self.eventEngine.registerCallback(fun)
end
function SourceTrigger:cancel(ref)
  return self.eventEngine.cancel(ref)
end
function SourceTrigger:postRemote(id,event)
  return self.eventEngine.postRemote(id,event)
end

local _marshalBool={['true']=true,['True']=true,['TRUE']=true,['false']=false,['False']=false,['FALSE']=false}

local function marshallFrom(v) 
  if v == nil then return nil end
  local fc = v:sub(1,1)
  if fc == '[' or fc == '{' then local s,t = pcall(json.decode,v); if s then return t end end
  if tonumber(v) then return tonumber(v)
  elseif _marshalBool[v ]~=nil then return _marshalBool[v ] end
  if v=='nil' then 
    return nil 
  end
  local test = v:match(\"^[0-9%$s]\")
  if not test then return v end
  local s,t = pcall(toTime,v,true); return s and t or v 
end

local fmt = string.format
local escTab = {[\"\\\\\"]=\"\\\\\\\\\",['\"']='\\\\\"'}
local sortKeys = {\"type\",\"device\",\"deviceID\",\"id\",\"name\",\"properties\",\"value\",\"oldValue\",\"val\",\"key\",\"arg\",\"event\",\"events\",\"msg\",\"res\"}
local sortOrder={}
for i,s in ipairs(sortKeys) do sortOrder[s]=\"\\n\"..string.char(i+64)..\" \"..s end
local function keyCompare(a,b)
  local av,bv = sortOrder[a] or a, sortOrder[b] or b
  return av < bv
end

--gsub(\"[\\\\\\\"]\",{[\"\\\\\"]=\"\\\\\\\\\",['\"']='\\\\\"'})
-- our own json encode, as we don't have 'pure' json structs, and sorts keys in order (i.e. \"stable\" output)

local function quote(s)
  local t = type(s)
  if t == 'string' then return s end
  return \"[\"..tostring(s)..\"]\"
end

local function prettyJsonFlat(e0) 
  local res,seen = {},{}
  local function pretty(e)
    local t = type(e)
    if t == 'string' then res[#res+1] = '\"' res[#res+1] = e:gsub(\"[\\\\\\\"]\",escTab) res[#res+1] = '\"'
    elseif t == 'number' then res[#res+1] = e
    elseif t == 'boolean' or t == 'function' or t=='thread' or t=='userdata' then
      if e == json.null then res[#res+1]='null'
      else res[#res+1] = tostring(e) end
    elseif t == 'table' then
      local mt = getmetatable(e)
      if seen[e] then res[#res+1]=\"..rec..\"
      elseif mt and mt.__tostring then
        local tstr = mt.__tostring
        mt.__tostring = nil
        res[#res+1] = tstr(e)
        mt.__tostring = tstr
      elseif next(e)==nil then
        if mt and mt.__isArray then
          res[#res+1]='[]'
        else
          res[#res+1]='{}'
        end
      elseif e[1] or #e>0 then
        seen[e]=true
        res[#res+1] = \"[\" pretty(e[1])
        for i=2,#e do res[#res+1] = \",\" pretty(e[i]) end
        res[#res+1] = \"]\"
        seen[e]=nil
      else
        seen[e]=true
        if e._var_  then res[#res+1] = fmt('\"%s\"',e._str) return end
        local k,kmap = {},{} for key,_ in pairs(e) do local ks = tostring(key) k[#k+1] = ks; kmap[ks]=key end
        table.sort(k,keyCompare)
        if #k == 0 then res[#res+1] = \"[]\" return end
        res[#res+1] = '{'; res[#res+1] = '\"' t = k[1] res[#res+1] = t; res[#res+1] = '\":' pretty(e[kmap[t]])
        for i=2,#k do
          res[#res+1] = ',\"' t = k[i] res[#res+1] = t; res[#res+1] = '\":' pretty(e[kmap[t]])
        end
        res[#res+1] = '}'
        seen[e]=nil
      end
    elseif e == nil then res[#res+1]='null'
    else error(\"bad json expr:\"..tostring(e)) end
  end
  pretty(e0)
  return table.concat(res)
end

local alarmFuns = {}
function alarmFuns.armPartition(id)
  if id == 0 then
    return api.post(\"/alarms/v1/partitions/actions/arm\",{})
  else
    return api.post(\"/alarms/v1/partitions/\"..id..\"/actions/arm\",{})
  end
end

function alarmFuns.unarmPartition(id)
  if id == 0 then
    return api.delete(\"/alarms/v1/partitions/actions/arm\")
  else
    return api.delete(\"/alarms/v1/partitions/\"..id..\"/actions/arm\")
  end
end

function alarmFuns.tryArmPartition(id)
  local res,code
  if id == 0 then
    res,code = api.post(\"/alarms/v1/partitions/actions/tryArm\",{})
    if type(res) == 'table' then
      local r = {}
      for _,p in ipairs(res) do r[p.id]=p.breachedDevices end
      return next(r) and r or nil
    else
      return nil
    end
  else
    local res,code = api.post(\"/alarms/v1/partitions/\"..id..\"/actions/tryArm\",{})
    if res.armDelayed and #res.armDelayed > 0 then return {[id]=res.breachedDevices} else return nil end
  end
end

json.encodeFast = prettyJsonFlat

local function base64encode(data)
  __assert_type(data,\"string\")
  local bC='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
  return ((data:gsub('.', function(x)
    local r,b='',x:byte() for i=8,1,-1 do r=r..(b%2^i-b%2^(i-1)>0 and '1' or '0') end
    return r;
  end)..'0000'):gsub('%d%d%d?%d?%d?%d?', function(x)
    if (#x < 6) then return '' end
    local c=0
    for i=1,6 do c=c+(x:sub(i,i)=='1' and 2^(6-i) or 0) end
    return bC:sub(c+1,c+1)
  end)..({ '', '==', '=' })[#data%3+1])
end

local oldSetTimeout,oldClearTimeout = setTimeout,clearTimeout

local longRefs,maxt = {},2147483648-1
function setTimeout(fun,ms,errh)
  __assert_type(fun,\"function\") __assert_type(ms,\"number\")
  if ms <= maxt then return oldSetTimeout(fun,ms,errh) end
  local longRef = nil
  local function lsetTimeout()
    if ms > maxt then
      ms = ms-maxt
      local ref = oldSetTimeout(lsetTimeout,maxt)
      longRefs[longRef or ref] = ref
      longRef = ref
      return ref
    else
      if longRef then longRefs[longRef] = nil end
      return oldSetTimeout(fun,ms,errh)
    end
  end
  return lsetTimeout()
end

function clearTimeout2(ref)
  if longRefs[ref] then oldClearTimeout(longRefs[ref]) longRefs[ref]=nil else oldClearTimeout(ref) end
end

ER.alarmFuns = alarmFuns
ER.toSeconds = toSeconds
ER.midnight = midnight
ER.getWeekNumber = getWeekNumber
ER.now = now
ER.between = between
ER.hm2sec = hm2sec
ER.toTime = toTime
ER.sunCalc = sunCalc
ER.dateTest = dateTest
ER.marshallFrom = marshallFrom
ER.base64encode = base64encode","isMain":false,"isOpen":false},{"type":"lua","name":"rule","content":"local VERSION = \"0.0.50\"

fibaro.EventRunner = fibaro.EventRunner or { debugFlags = {} }
local ER = fibaro.EventRunner
local debugFlags = ER.debugFlags
local sourceTrigger

local fmt  = string.format
local function printf(...) print(string.format(...)) end
local findTriggers, evalArg
local Rules,RuleEnv = {},{}
ER.ruleEnv = RuleEnv
local catch = math.huge
local idFun = function() end
ER.rules = Rules

local function safeFmt(fm,...) if #{...}==0 then return fm else return fmt(fm,...) end end
local function Event(ev) return setmetatable(ev, ER.EventMT) end
local function INFO(...) fibaro.debug(__TAG,safeFmt(...)) end
local function ERROR(...) fibaro.error(__TAG,safeFmt(...)) end
local function WARNING(...) fibaro.warning(__TAG,safeFmt(...)) end

local dfltPrefix = {
  warningPrefix = \"⚠️\",
  ruleDefPrefix = \"✅\",
  triggerListPrefix = \"⚡\",
  dailyListPrefix = \"🕒\",
  startPrefix = \"🎬\", 
  stopPrefix = \"🛑\",
  successPrefix = \"👍\", -- 😀
  failPrefix = \"👎\", -- 🙁
  resultPrefix = \"📋\", 
  errorPrefix = \"❌\",
  waitPrefix = \"💤\", -- 😴
  waitedPrefix = \"⏰\", -- 🤗
}

local T2020 = os.time{year=2020, month=1, day=1, hour=0, min=0, sec=0}
local function timeStr(t) 
  if t < T2020 then return fmt(\"%02d:%02d:%02d\",t//3600,t%3600//60,t%60) else return os.date(\"%Y-%m-%d %H:%M:%S\",t) end
end
ER.T2020 = T2020

local function mkEvent(ev) return setmetatable(ev, ER.EventMT) end

local RuleMT = {
  __tostring = function(r) return fmt(\"[Rule:%d%s]\", r.id, r.name and (\" \"..r.name) or \"\") end,
  -- __index = function(r,k)
  --   if k == 'short' then return fmt(\"%s %s\",r,r.src // 80):gsub(\"%s*\\n%s*\",\" \") end
  --   return rawget(r,k)
  -- end,
}

local function started_rule(rule, env, event) 
  local str = tostring(event) 
  INFO(\"%s %s: %s\", rule.startPrefix, rule, str) 
end
local function check_rule(rule, env, arg, ...) 
  local str = tostring(rule)
  if arg then INFO(\"%s %s\", rule.successPrefix, str) else INFO(\"%s %s\", rule.failPrefix, str) end
end
local function result_rule(rule, ...) 
  local res = {ER.args2str(...)}
  local rstr = #res>0 and table.concat(res,\", \") or \"<nil>\"
  INFO(\"%s %s: %s\", rule.resultPrefix, rule, rstr)
end
local function waiting_rule(rule, env, time)
  if time < T2020 then time= time + ER.now() end
  INFO(\"%s %s: ⏰%s\", rule.waitPrefix, rule, timeStr(time))
end
local function waited_rule(rule, ...)
  INFO(\"%s %s: awake\", rule.waitedPrefix, rule)
end

local function flatten(t)
  if type(t) == 'table' then 
    local r = {}
    for _,v in ipairs(t) do
      local v = flatten(v)
      if type(v) == 'table' then
        for _,w in ipairs(v) do r[#r+1] = w end
      else
        r[#r+1] = v
      end
    end
    return r
  else
    return t
  end
end

local ruleGetVar = { id = true, src = true, name = true, disabled = true }
--local ruleSetVar = { id = true, src = true, name = true, disabled = true }
local ruleSetFun = { enable = true, disable = true, start = true }
local function ruleWrapper(rule)
  return setmetatable({_rule = rule},{
    __tostring = function(r) return tostring(rule) end,
    __index = function(r,k)
      if ruleGetVar[k] then return (rule or {})[k] elseif ruleSetFun[k] then 
        return function(_,...) 
          if r then rule[k](rule,...) end return r end 
        end
    end,
  })
end

local function createRule(expr, data, opts)
  local self = { id = data.id, triggers = data.triggers, daily = data.daily, interval = data.interval, src = opts.src, name = opts.name}
  local timers = {}
  local opts = opts or {}
  opts = table.copyShallow(opts)
  opts.env = RuleEnv

  for k,v in pairs(dfltPrefix) do if opts[k] == nil then self[k] = v else self[k] = opts[k] end end
  if opts.started and type(opts.started) == 'boolean' then opts.started = started_rule end
  if opts.check and type(opts.check) == 'boolean' then opts.check = check_rule end
  if opts.result and type(opts.result) == 'boolean' then opts.result = result_rule end
  if opts.waiting and type(opts.waiting) == 'boolean' then opts.waiting = waiting_rule end
  if opts.waited and type(opts.waited) == 'boolean' then opts.waited = waited_rule end

  local function rsetTimeout(f,t)
    local ref
    local function fun(...) 
      local res = {pcall(f,...)} 
      timers[ref] = nil
      return table.unpack(res)
    end
    ref = setTimeout(fun,t)
    timers[ref] = true
    return ref
  end
  local function rclearTimeout(ref) if timers[ref] then clearTimeout(ref) timers[ref] = nil end end
  local function hook(ref) timers[ref] = nil end -- When posts are posted.
  local function rpost(event,time) local ref = sourceTrigger:post(event,time,nil,hook) timers[ref] = true; return ref end
  opts.setTimeout,opts.clearTimeout = rsetTimeout, rclearTimeout 

  opts.cont = function(...) if opts.result then opts.result(self,...) end end
  opts.err = opts.err or function(str,warning) 
    if warning then end
    local msg = fmt(\"%s: %s (disabling)\", self, str) 
    ERROR(msg)
    ER.sourceTrigger:post({type='rule-error',rule=self,message=msg},0)
    self:disable()
  end
  self.env = ER.createEnv(opts.cont,opts.err,opts)
  self.env.check = opts.check
  self.env.waiting = opts.waiting
  self.env.waited = opts.waited
  self.env.rule = self

  local dailyEvent = mkEvent({ type = 'Daily', id = self.id })
  local intervalEvent = mkEvent({ type = 'Interval', id = self.id })
  
  local skipTrigger = false
  if self.daily and next(self.daily)~=nil then
    sourceTrigger:subscribe(dailyEvent,function(event) 
      self:start(event.event) 
    end)
    skipTrigger = data.seenDaily
  end
  
  if self.interval then
    sourceTrigger:subscribe(intervalEvent,function(event) 
      self:start(event.event)
    end)
    skipTrigger = true
  end
  
  for evid,t in pairs(self.triggers) do
    if t.type ~= 'Daily' and t.type ~= 'Interval' then
      if not skipTrigger then
        local eventId = evid
        sourceTrigger:subscribe(t,function(event)
          self:start(event.event,eventId,event.p)
        end)
      elseif t._df then
        t._df = nil
        sourceTrigger:subscribe(t,function(event)
          self:setupDaily(false)
        end)
      end
    end
  end
  
  function self:dumpTriggers()
    printf(\"Rule %d triggers:\",self.id)
    for _,t in pairs(self.triggers) do print(fmt(\"⚡ %s\", json.encodeFast(t))) end
    if self.daily then 
      evalArg(function(values)
        if type(values) ~= 'table' then values = {values} else values = flatten(values) end
        for i,t in ipairs(values) do 
          if t ~= catch then printf(\"🕒 %s\",timeStr(t)) end
        end
      end, self.env, table.unpack(self.daily))
    end
  end
  
  if opts.triggers then self:dumpTriggers() end

  local dailyTimers = {}
  local function clearDailyTimers() for t,_ in ipairs(dailyTimers) do rclearTimeout(t) end; dailyTimers = {} end

  function self:setupDaily(start,skew)
    local skew = skew or 0
    clearDailyTimers()
    if self.daily then
      evalArg(function(values)
        local now = ER.now()
        if type(values) ~= 'table' then values = {values} else values = flatten(values) end
        if opts.log then INFO(\"Setting up daily trigger for rule %d at %s\", self.id, json.encodeFast(values)) end
        local catchFlag,n = false,0
        for _,t in ipairs(values) do n=n+1 if t == catch then catchFlag = true; break end end
        for _,t in ipairs(values) do
          if t ~= catch then
            local torg = t
            if type(t) ~= 'number' then return self.env.error(\"Invalid daily time: \"..tostring(t)) end
            if t < now+skew then 
              t = t + 24*3600
              if catchFlag and start then rsetTimeout(function() self:start(dailyEvent) end,0) end -- Catch up, run immediately
            end
            dailyTimers[rpost({type='Daily',id=self.id,time=timeStr(torg)},t-now)]=true
          end
        end
      end, self.env, table.unpack(self.daily))
    end
  end
  
  local intervalTimer
  function self:setupInterval()
    if intervalTimer then rclearTimeout(intervalTimer); intervalTimer = nil end
    if self.interval then
      self.interval(function(value)
        if type(value) ~= 'number' then return self.env.error(\"Invalid interval time: \"..tostring(value)) end
        local delay = 0
        if value < 0 then value=-value delay = (os.time() // value + 1)*value - os.time() end
        local nextTime = os.time() + delay
        local function loop()
          self:start(intervalEvent)
          nextTime = nextTime + value
          intervalTimer = rsetTimeout(loop, (nextTime-os.time())*1000)
        end
        intervalTimer = rsetTimeout(loop, (nextTime-os.time())*1000)
      end, self.env)
    end
  end
  
  function self:clearTimers() for t,_ in pairs(timers) do rclearTimeout(t) end; timers = {} end

  function self:enable() self.disabled = nil; self:setupDaily(false) self:setupInterval() end
  function self:disable() self.disabled = true; self:clearTimers()end

  function self:start(event,id,matchvars)
    if self.disabled then return end
    local env = table.copyShallow(self.env)
    env.trigger = event or {type='_startRule'}
    env.eventId = id
    matchvars = matchvars or {}
    matchvars.env = {event = event, p = matchvars}
    matchvars.rule = self
    env.locals = matchvars
    if opts.started then opts.started(self,env,event) end
    expr(opts.cont,env)
    if event and event._df then self:setupDaily(false) end
  end

  setmetatable(self, RuleMT)
  self.short = fmt(\"%s %s\",self,self.src // 80):gsub(\"%s*\\n%s*\",\" \")
  return ruleWrapper(self)
end

local function defRule(expr, opts)
  local head = expr.__doc[2]
  local src = opts.src
  local id = #Rules+1
  local env = ER.createEnv(idFun,idFun,opts)
  for k,v in pairs({
    id = id,
    triggers = {},
    daily = nil,
    interval = nil,
    error = function(str) ERROR(\"❌ Rule %s: %s '%s'\", tostring(id), tostring(str), src:gsub(\"%s*\\n%s*\",\" \") // 80) os.exit() end, -- Only used when checking triggers
  }) do env[k] = v end
  
  local function cont()
    --triggers = env.triggers
  end

  findTriggers(head, cont, env)

  if env.interval and env.seenDaily then return env.error(\"Only one @daily or @@interval per rule\") end
  if env.daily then env.triggers[\"D\"]=Event({type='Daily',id=env.id}) end
  
  if env.interval == nil and env.daily == nil and next(env.triggers)==nil then
    return env.error(\"Rule has no triggers\")
  end

  local rule = createRule(expr, env, opts)
  rule._rule:setupDaily(true)
  rule._rule:setupInterval()
  Rules[#Rules+1] = rule._rule
  if opts.defined then
    if type(opts.defined) == 'func'..'tion' then
      local stat,res = pcall(opts.defined,rule)
      if stat and res then return end
    end
    printf(\"%s %s\",rule._rule.ruleDefPrefix,rule._rule.short)
  end
  return rule
end

local function etype(c) return c.__doc[1] end
local function earg(c,i) return c.__doc[1+i] end
local function eargs(c) return table.unpack(c.__doc,2) end

local function scanArg(cont, env, df, arg, ...)
  local rest = {...}
  findTriggers(arg,function() 
    if #rest > 0 then scanArg(cont, env, df, table.unpack(rest)) else cont() end
  end, env, df)
end

local function evalArgAux(vals, cont, env, arg, ...)
  local rest = {...}
  arg(function(...) 
    for _,v in ipairs({...}) do vals[#vals+1] = v end
    if #rest > 0 then evalArgAux(vals, cont, env, table.unpack(rest)) else cont(vals) end
  end, env)
end
function evalArg(cont, env, ...) evalArgAux({}, cont, env, ...) end

local evid = 0
function findTriggers(c, cont, env, df)
  if c == nil then
    return
  end
  local typ = etype(c)
  if typ == 'unop' then
    local op,arg,df = earg(c,1), earg(c,2),nil
    if op == 'daily' then
      if env.seenDaily then env.error(\"Only one @daily per rule\") end
      env.seenDaily = true
      env.daily = env.daily or {}
      table.insert(env.daily,arg) 
      df = true
    elseif op == 'interv' then
      if env.interval then env.error(\"Only one @interv per rule\") end
      env.triggers[\"I\"]=Event({type='Interval',id=env.id})
      env.interval = arg 
    end
    scanArg(cont, env, df, arg)
  elseif typ == 'and' or typ == 'or' then 
    scanArg(cont, env, df, table.unpack(eargs(c)))
  elseif typ == 'getprop' then
    local obj = earg(c,2)
    local prop = earg(c,1)
    if ER.propFilters[prop] then 
      return scanArg(cont, env, df, obj)
    end
    obj(function(values)
      if values == nil then env.error(fmt(\"getprop object is nil: %s %s\",prop,tostring(obj))) end
      if type(values) == 'table' and next(values)==nil then env.error(fmt(\"getprop object is empty table: %s %s\",prop,tostring(obj))) end
      if not(type(values) == 'table' and not values._isPropObject) then values = {values} end
      for _,o in ipairs(values) do
        local obj = ER.resolvePropObject(o)
        if not obj:isProp(prop) then
          env.error(fmt(\"Unknown property in getprop trigger: %s %s\",prop,tostring(obj)))
        end
        if not obj:isTrigger(prop) then return cont() end
        local tr = obj:getTrigger(o,prop)
        env.triggers[\"DEV:\"..tostring(o)..prop]=Event(tr)
      end
      cont()
    end,env)
  elseif typ == 'const' then
    local t = earg(c,1)
    if type(t) == 'table' and type(t.type) == 'string' then
      evid = evid+1
      local eventId = \"EV:\"..evid
      c.evalHook = function(c,cont,env) 
        if not env.trigger then cont(false)
        elseif env.trigger.type == '_startRule' then cont(true)
        elseif env.eventId ~= eventId then return cont(false) else
        cont(true) end
      end
      env.triggers[eventId]=Event(t)
    end
    cont()
  elseif typ == 'table' then
    local args = {}
    for _,v in ipairs(eargs(c)) do 
      args[#args+1] = v.value 
    end
    if next(args) then
      c(function(tab) 
        if type(tab)=='table' and type(tab.type)=='string' then
          evid = evid+1
          local eventId = \"EV:\"..evid
          c.evalHook = function(c,cont,env) 
            if not env.trigger then cont(false)
            elseif env.trigger.type == '_startRule' then cont(true)
            elseif env.eventId ~= eventId then return cont(false) else
              cont(true) end
            end
            env.triggers[eventId]=Event(tab)
          end
        end, env)
      end
    scanArg(cont, env, df, table.unpack(args))
  elseif typ == 'binop' then
    local op,a1,a2 = earg(c,1), earg(c,2), earg(c,3) -- ToDo: Add 1 to a2
    a2 = ER.COMPFUNS.UNOP('add',a2,1)
    if op == 'betw' then
      if env.daily == nil then env.daily = {a1,a2}
      else 
        for _,v in ipairs({a1,a2}) do table.insert(env.daily,v) end
      end
    end
    scanArg(cont, env ,df, a1, a2)
  elseif typ == 'rulecheck' then
    scanArg(cont, env, df, earg(c,1))
  elseif typ == 'call' then
    local args = earg(c,2)
    if #args > 0 then
      scanArg(cont, env, df, table.unpack(args)) -- fun, args
    else cont() end
  elseif typ == 'var' then
    local name = earg(c,1)
    if ER.triggerVars[name] then
      env.triggers['TV:'..name]=Event({type='trigger-variable',name=name, _df=df})
    end
    cont()
  elseif typ == 'gvar' then
    local name = earg(c,1)
    env.triggers['GV:'..name]=Event({type='global-variable',name=name, _df=df})
    cont()
  elseif typ == 'qvar' then
    local name = earg(c,1)
    env.triggers['QV:'..name]=Event({type='quickvar',id=quickApp.id,name=name, _df=df})
    cont()
  elseif typ == 'aref' then
    scanArg(cont, env, df, eargs(c))
  else
    print(\"Unsupported trigger type:\", etype(c), json.encodeFast(c))
  end
end

ER.defRule = defRule
ER.computedVar = {}

local function setupVariables(er)
  local var = er.variables
  var.sunrise, var.sunset,var.dawn,var.dusk = ER.sunCalc()
  var.midnight, var.vnum = ER.midnight(), tonumber(os.date(\"%V\"))
end

local _er

local function midnightLoop(er)
  local dt,var = os.date(\"*t\"), er.variables
  local midnight = os.time{year=dt.year, month=dt.month, day=dt.day+1, hour=0, min=0, sec=0}
  local function loop()
   setupVariables(er)
    for _,r in pairs(Rules) do
      if r.daily then r:setupDaily(false) end
      r.once = nil -- clear once flag every midnight
    end
    local dt = os.date(\"*t\")
    local midnight = os.time{year=dt.year, month=dt.month, day=dt.day+1, hour=0, min=0, sec=0}
   setTimeout(loop, (midnight-os.time())*1000)
  end
  setTimeout(loop, (midnight-os.time())*1000)
end

function createER(qa)
  quickApp = qa
  if _er then return _er end
  _er = { qa = qa }
  ER._er = _er
  sourceTrigger = SourceTrigger()
  sourceTrigger:run()
  ER.sourceTrigger = sourceTrigger
  
  local env = {catch = catch}
  for k,v in pairs(env) do RuleEnv[k] = {v} end
  for k,v in pairs(ER.builtin) do RuleEnv[k] = {v} end

  local async = setmetatable({},{
    __index = function(t,k) local v = RuleEnv[k] return v and v[1] or nil end,
    __newindex = function(t,k,f) local var = RuleEnv[k] if var then var[1] = ER.ASYNCFUN(f) else RuleEnv[k] = {ER.ASYNCFUN(f)} end end,
  })

  _er.variables = setmetatable({ async = async },{
    __index = function(t,k) local v = RuleEnv[k] return v and v[1] or nil end,
    __newindex = function(t,k,v) 
      local var = RuleEnv[k] 
      if var then
        if var[1] ~= v then 
          if ER.triggerVars[k] then 
            ER.sourceTrigger:post({type='trigger-variable',name=k},0) 
          end
        end
        var[1] = v 
      else RuleEnv[k] = {v} end 
    end,
  })

  ER.triggerVars = {}
  _er.triggerVariables = setmetatable({},{ 
    __index = function(t,k) return  _er.variables[k] end,
    __newindex = function(t,k,v) ER.triggerVars[k]=true _er.variables[k] = v end
  })
  function _er.rule(...)
    local args = {...}
    local str = args[1]
    local opts = args[2] 
    if type(str)=='string' and type(opts)=='string' then
      str,opts = args[2],args[3]
      opts = opts or {}
      assert(type(opts)=='table',\"Options must be a table\")
      opts.name = args[1]
    end
    opts = opts or {}
    assert(type(str)=='string',\"First argument must be a rule string\")
    assert(type(opts)=='table',\"Options must be a table\")
    for k,v in pairs(_er.opts or {}) do if opts[k] == nil then opts[k] = v end end 
    if opts.defined == nil then opts.defined = true end
    opts.env = opts.env or RuleEnv
    return ER.eval(str,opts)() 
  end
  function _er.start() 
    setTimeout(function()
      setupVariables(_er)
      midnightLoop(_er)
      ER.customDefs(_er)
      print(\"=========== Loading rules ================\")
      local t0 = os.clock()
      local stat,err = pcall(function() _er.qa:main(_er) end)
      if not stat then fibaro.error(__TAG,err) end
      printf(\"=========== Load time: %.3fs ============\",os.clock()-t0)
    end,1)
  end
  _er.definePropClass = ER.definePropClass
  function _er.speed(time) return ER.speedTime(time,_er.start) end
  function _er.post(event,time) return sourceTrigger:post(event,time) end
  function _er.cancel(ref) return sourceTrigger:cancel(ref) end
  function _er.postRemote(id,event) sourceTrigger:postRemote(id,event) end
  _er.loadSimDevice = ER.loadSimDev
  _er.createAsyncFun = ER.ASYNCFUN
  _er.base64encode = ER.base64encode
  _er.eval = _er.rule -- alias
  setmetatable(_er,{
    __tostring = function() return fmt(\"EventRunner6 v%s\",VERSION) end,
  })
  return _er
end

setmetatable(ER,{
  __tostring = function() return fmt(\"EventRunner6 v%s\",VERSION) end,
  __call = function(_,qa) return createER(qa) end
})

function fibaro.loadLibrary(lf) lf(fibaro.EventRunner._er) end ","isMain":false,"isOpen":false},{"type":"lua","name":"builtin","content":"fibaro.EventRunner = fibaro.EventRunner or { debugFlags = {} }
local ER = fibaro.EventRunner
local debugFlags = ER.debugFlags
local fmt = string.format

local args = {}
local builtin = {}
ER.builtin = builtin

local function detag(str) 
  str = str:gsub(\"(#C:)(.-)(#)\",function(_,c) color=c return \"\" end)
  if color then str=string.format(\"<font color='%s'>%s</font>\",color,str) end
  return str
end

function builtin.log(...) -- printable tables and #C:color# tag
  local args,n = {...},0
  for i=1,#args do 
    local a = args[i]
    local typ = type(a)
    n = n+1
    if typ == 'string' then args[i] = detag(a)
    elseif typ == 'table' or typ == 'userdata' then 
      local mt = getmetatable(a)
      if mt and mt.__tostring then args[i] = tostring(a)
      else args[i] = json.encodeFast(a) end
    end
  end
  local msg = \"\"
  if n == 1 then msg = args[1] elseif n > 1 then msg = string.format(table.unpack(args)) end
  print(msg)
  return msg
end

function builtin.post(ev,time) return ER._er.post(ev,time) end
function builtin.cancel(ref) return ER._er.cancel(ref) end
function builtin.fmt(...) return string.format(...) end
function builtin.HM(t) return os.date(\"%H:%M\",t < os.time()-8760*3600 and t+ER.midnight() or t) end
function builtin.HMS(t) return os.date(\"%H:%M\",t < os.time()-8760*3600 and t+ER.midnight() or t) end
function builtin.sign(t) return t < 0 and -1 or 1 end
function builtin.rnd(min,max) return math.random(min,max)end
function builtin.round(num) return math.floor(num+0.5) end
function builtin.sum(...) 
  local args = {...}
  if #args == 1 and type(args[1]) == \"table\" then args = args[1] end
  local s = 0 for i=1,#arg do s = s + arg[i] end
  return s
end
function builtin.average(...) local s = builtin.sum(...) return s / select(\"#\", ...) end
function builtin.size(t) return #t end
function builtin.min(...) 
  local args = {...}
  if #args == 1 and type(args[1]) == \"table\" then args = args[1] end
  return math.min(table.unpack(args))
end
function builtin.max(...) 
  local args = {...}
  if #args == 1 and type(args[1]) == \"table\" then args = args[1] end
  return math.max(table.unpack(args))
end
function builtin.sort(t) table.sort(t) return t end
function builtin.osdate(a,b) return os.date(a,b) end
function builtin.ostime(t) return os.time(t) end

function builtin.global(name)
  local s = fibaro.getGlobalVariable(name)     
  local a,b = api.post(\"/globalVariables/\",{name=name,value = \"\"})
  return s == nil,(s == nil and fmt(\"'%s' created\",name) or fmt(\"'%s' exists\",name))
end

function builtin.listglobals() return api.get(\"/globalVariables\") end
function builtin.deleteglobal(name) api.delete(\"/globalVariables/\"..name) end

function builtin.subscribe(event) end
function builtin.publish(event) end
function builtin.remote(deviceId,event) end
function builtin.adde(t,v) table.insert(t,v) return t end
function builtin.remove(t,v) 
  for i=#t,1,-1 do if t[i]==v then table.remove(t,i) end end 
  return t
end

function builtin.enable(rule) end
function builtin.disable(rule) end

function ER.customDefs(er)
    local rule,var = er.rule,er.variables

    ER.computedVar.now = ER.now
    ER.computedVar.wnum = function() return tonumber(os.date(\"%V\",os.time())) end

    function var.async.trueFor(cb,time,expr)
    local trueFor = cb.env.rule.trueFor or {}
    cb.env.rule.trueFor = trueFor
    if expr then -- test is true
      if not trueFor.ref then -- new, start timer
        trueFor.trigger = cb.env.trigger
        trueFor.ref = cb.env:setTimeout(function() trueFor.ref = nil; cb(true) end, time*1000)
        return math.huge
      else -- already true and we have timer waiting
        cb(false) -- do nothing
      end
    elseif trueFor.ref then -- test is false, and we have timer
      cb.env:clearTimeout(trueFor.ref)
      trueFor.ref = nil
      cb(false)
    else
      cb(false) -- do nothing
    end
    return -1 -- not async...
  end

  function var.async.again(cb,n)
    local trueFor = cb.env.rule.trueFor
    if trueFor then
      if trueFor.again and trueFor.again == 0 then trueFor.again = nil return cb(0) end 
      if trueFor.again == nil then trueFor.again,trueFor.againN = n,n end-- reset
      trueFor.again = trueFor.again - 1
      if trueFor.trigger and  trueFor.again > 0 then 
        cb.env:setTimeout(function() cb.env.rule:start(trueFor.trigger) end, 0)
        cb(trueFor.againN - trueFor.again)
      else trueFor.again = nil cb(trueFor.againN) end
    else cb(0) end
    return -1 -- not async...
  end

  function var.async.once(cb,expr)
    local once = cb.env.rule.once
    if expr then
      if not once then 
        cb.env.rule.once = true
        cb(true)
      else cb(false) 
      end
    else  cb.env.rule.once = nil; cb(false) end
    return -1 -- not async
  end
  
  function var.async.wait(cb,time)
    if time < ER.T2020 then time = time + ER.now() end
    if cb.env.waiting then cb.env.waiting(cb.env.rule,cb.env,time) end
    cb.env:setTimeout(function() 
      if cb.env.waited then cb.env.waited(cb.env.rule,cb.env,time) end
      cb(true) 
    end, 
    (time-ER.now())*1000)
    return -1 -- not async
  end

  local function makeDateFun(str,cache)
    if cache[str] then return cache[str] end
    local f = ER.dateTest(str)
    cache[str] = f
    return f
  end
  
  local cache = { date={}, day = {}, month={}, wday={} }
  var.date = function(s) return (cache.date[s] or makeDateFun(s,cache.date))() end               -- min,hour,days,month,wday
  var.day = function(s) return (cache.day[s] or makeDateFun(\"* * \"..s,cache.day))() end          -- day('1-31'), day('1,3,5')
  var.month = function(s) return (cache.month[s] or makeDateFun(\"* * * \"..s,cache.month))() end  -- month('jan-feb'), month('jan,mar,jun')
  var.wday = function(s) return (cache.wday[s] or makeDateFun(\"* * * * \"..s,cache.wday))() end   -- wday('fri-sat'), wday('mon,tue,wed')
  
  var.S1 = {click = \"16\", double = \"14\", tripple = \"15\", hold = \"12\", release = \"13\"}
  var.S2 = {click = \"26\", double = \"24\", tripple = \"25\", hold = \"22\", release = \"23\"}
  
  function var.nextDST()
    local d0 = os.date(\"*t\")
    local t0 = os.time({year=d0.year, month=d0.month, day=1, hour=0})
    local h = d0.hour
    repeat  t0 = t0 + 3600*24*30; d0 = os.date(\"*t\",t0) until d0.hour ~= h
    t0 = t0 - 3600*24*30; d0 = os.date(\"*t\",t0)
    repeat h = d0.hour; t0 = t0 + 3600*24; d0 = os.date(\"*t\",t0) until d0.hour ~= h
    t0 = t0 - 3600*24; d0 = os.date(\"*t\",t0)
    repeat h = d0.hour; t0 = t0 + 3600; d0 = os.date(\"*t\",t0) until d0.hour ~= (h+1) % 24
    if d0.month > 7 then t0 = t0 + 3600 end
    return t0
  end
  
    -- Example of home made property object
  Weather = {}
  er.definePropClass(\"Weather\") -- Define custom weather object
  function Weather:__init() PropObject.__init(self) end
  function Weather.getProp.temp(prop,env) return api.get(\"/weather\").Temperature end
  function Weather.getProp.humidity(prop,env) return  api.get(\"/weather\").Humidity end
  function Weather.getProp.wind(prop,env) return  api.get(\"/weather\").Wind end
  function Weather.getProp.condition(prop,env) return  api.get(\"/weather\").WeatherCondition end
  function Weather.trigger.temp(prop) return {type='weather', property='Temperature'} end
  function Weather.trigger.humidity(prop) return {type='weather', property='Humidity'} end
  function Weather.trigger.wind(prop) return {type='weather', property='Wind'} end
  function Weather.trigger.condition(prop) return {type='weather', property='WeatherCondition'} end
  var.weather = Weather()
  
  ------- Patch fibaro.call to track manual switches -------------------------
  local lastID,switchMap = {},{}
  local oldFibaroCall = fibaro.call
  function fibaro.call(id,action,...)
    if ({turnOff=true,turnOn=true,on=true,toggle=true,off=true,setValue=true})[action] then lastID[id]={script=true,time=os.time()} end
    if action=='setValue' and switchMap[id]==nil then
      local actions = (__fibaro_get_device(id) or {}).actions or {}
      switchMap[id] = actions.turnOff and not actions.setValue
    end
    if action=='setValue' and switchMap[id] then return oldFibaroCall(id,({...})[1] and 'turnOn' or 'turnOff') end
    return oldFibaroCall(id,action,...)
  end
  
  local function lastHandler(ev)
    if ev.type=='device' and ev.property=='value' then
      local last = lastID[ev.id]
      local _,t = fibaro.get(ev.id,'value')
      if not(last and last.script and t-last.time <= 2) then
        lastID[ev.id]={script=false, time=t}
      end
    end
  end
  
  ER.sourceTrigger.eventEngine.registerCallback(lastHandler)
  
  function QuickApp:lastManual(id)
    local last = lastID[id]
    if not last then return -1 end
    return last.script and -1 or os.time()-last.time
  end

  local deviceFormatter = {}
  function deviceFormatter.centralSceneEvent(ev) 
    local val = ev.value or {}
    return fmt(\"#key{id:%s,%s:%s}\", ev.id,val.keyId or \"*\", val.keyAttribute or \"*\")
  end
  function ER.eventFormatter.device(ev)
    if deviceFormatter[ev.property] then return deviceFormatter[ev.property](ev) end
    return false
  end
  
end


","isMain":false,"isOpen":false},{"type":"lua","name":"props","content":"fibaro.EventRunner = fibaro.EventRunner or { debugFlags = {} }
local ER = fibaro.EventRunner
local debugFlags = ER.debugFlags
ER.propFilters = {}

-------------- builtin props -------------------------
-- getProps helpers
local function BN(x) if type(x)=='boolean' then return x and 1 or 0 else return tonumber(x) or 0 end end
local function get(id,prop) return fibaro.get(id,prop) end
local function getnum(id,prop) return tonumber((fibaro.get(id,prop))) or nil end
local function on(id,prop) return BN(fibaro.get(id,prop)) > 0 end
local function off(id,prop) return BN(fibaro.get(id,prop)) == 0 end
local function call(id,cmd) fibaro.call(id,cmd); return true end
local function toggle(id,prop) if on(id,prop) then fibaro.call(id,'turnOff') else fibaro.call(id,'turnOn') end return true end
local function profile(id,_) return api.get(\"/profiles/\"..id) end
local function child(id,_) return quickApp.childDevices[id] end
local function last(id,prop) local _,t=fibaro.get(id,prop); local r = t and os.time()-t or 0; return r end
local function cce(id,_,e) 
  if e==nil then return {} end
  return e.type=='device' and e.property=='centralSceneEvent'and e.id==id and e.value or {} 
end
local function ace(id,_,e) if e==nil then return {} end return e.type=='device' and e.property=='accessControlEvent' and e.id==id and e.value or {} end
local function sae(id,_,e) if e==nil then return nil end return e.type=='device' and e.property=='sceneActivationEvent' and e.id==id and e.value.sceneId end
local mapOr,mapAnd,mapF=table.mapOr,table.mapAnd,function(f,l,s) table.mapf(f,l,s); return true end
local function partition(id) return api.get(\"/alarms/v1/partitions/\" .. id) or {} end
local function armState(id) return id==0 and fibaro.getHomeArmState() or fibaro.getPartitionArmState(id) end
local function arm(id,action)
  if action=='arm' then 
    local _,res = ER.alarmFuns.armPartition(id); return res == 200
  else
    local _,res = ER.alarmFuns.unarmPartition(id); return res == 200
  end
end
local function tryArm(id)
  local data,res = ER.alarmFuns.tryArmPartition(id)
  if res ~= 200 then return false end
  if type(data) == 'table' then
    ER.sourceTrigger:post({type='alarm',id=id,action='tryArm',property='delayed',value=data})
  end
  return true
end
local helpers = { BN=BN, get=get, on=on, off=off, call=call, profile=profile, child=child, last=last, cce=cce, ace=ace, sae=sae, mapOr=mapOr, mapAnd=mapAnd, mapF=mapF }

local getProps={}
ER.getProps = getProps
-- { type, function to get prop, property name in sourceTrigger, reduce function, if props is a rule trigger }
getProps.value={'device',get,'value',nil,true}
getProps.state={'device',get,'state',nil,true}
getProps.bat={'device',getnum,'batteryLevel',nil,true}
getProps.power={'device',getnum,'power',nil,true}
getProps.isDead={'device',get,'dead',mapOr,true}
getProps.isOn={'device',on,'value',mapOr,true}
getProps.isOff={'device',off,'value',mapAnd,true}
getProps.isAllOn={'device',on,'value',mapAnd,true}
getProps.isAnyOff={'device',off,'value',mapOr,true}
getProps.last={'device',last,'value',nil,true}

getProps.armed={'alarm',function(id) return  armState(id)=='armed' end,'armed',mapOr,true}
getProps.tryArm={'alarm',tryArm,nil,'alarm',false}
getProps.isArmed={'alarm',function(id) return partition(id).armed end,'armed',mapOr,true}             -- api.get(\"/alarms/v1/partitions/\" .. id)
getProps.isAllArmed={'alarm',function(id) return partition(id).armed end,'armed',mapAnd,true,true}    -- fibaro.getHomeArmState()
getProps.isDisarmed={'alarm',function(id) return partition(id).armed==false end,'armed',mapAnd,true}  --  fibaro.getPartitionArmState(id)
getProps.isAnyDisarmed={'alarm',function(id) return partition(id).armed==false end,'armed',mapOr,true,false} -- ER.alarmFuns.armPartition(id)
getProps.isAlarmBreached={'alarm',function(id) return partition(id).breached end,'breached',mapOr,true}      -- ER.alarmFuns.unarmPartition(id)
getProps.isAlarmSafe={'alarm',function(id) return partition(id).breached==false end,'breached',mapAnd,true}  -- ER.alarmFuns.tryArmPartition(id)
getProps.isAllAlarmBreached={'alarm',function(id) return partition(id).breached end,'breached',mapAnd,true}
getProps.isAnyAlarmSafe={'alarm',function(id) return partition(id).breached==false end,'breached',mapOr,true,false}

getProps.child={'device',child,nil,nil,false}
getProps.parent={'device',function(id) return api.get(\"/devices/\"..id).parentId end,nil,nil,false}
getProps.profile={'device',profile,nil,nil,false}
getProps.scene={'device',sae,'sceneActivationEvent',nil,true}
getProps.access={'device',ace,'accessControlEvent',nil,true}
getProps.central={'device',cce,'centralSceneEvent',nil,true}
local keyMT = { __tostring = function(t) return string.format(\"%s:%s\",t.keyId or '',t.keyAttribute or '') end }
getProps.key={'device',function(id,_,ev) local e = cce(id,_,ev); e = e or {} e.id,e.attr = e.keyId,e.keyAttribute return setmetatable(e or {},keyMT) end,'centralSceneEvent',nil,true}
getProps.safe={'device',off,'value',mapAnd,true}
getProps.breached={'device',on,'value',mapOr,true}
getProps.isOpen={'device',on,'value',mapOr,true}
getProps.isClosed={'device',off,'value',mapAnd,true}
getProps.lux={'device',getnum,'value',nil,true}
getProps.volume={'device',get,'volume',nil,true}
getProps.position={'device',get,'position',nil,true}
getProps.temp={'device',get,'value',nil,true}
getProps.coolingThermostatSetpoint={'device',get,'coolingThermostatSetpoint',nil,true}
getProps.coolingThermostatSetpointCapabilitiesMax={'device',get,'coolingThermostatSetpointCapabilitiesMax',nil,true}
getProps.coolingThermostatSetpointCapabilitiesMin={'device',get,'coolingThermostatSetpointCapabilitiesMin',nil,true}
getProps.coolingThermostatSetpointFuture={'device',get,'coolingThermostatSetpointFuture',nil,true}
getProps.coolingThermostatSetpointStep={'device',get,'coolingThermostatSetpointStep',nil,true}
getProps.heatingThermostatSetpoint={'device',get,'heatingThermostatSetpoint',nil,true}
getProps.heatingThermostatSetpointCapabilitiesMax={'device',get,'heatingThermostatSetpointCapabilitiesMax',nil,true}
getProps.heatingThermostatSetpointCapabilitiesMin={'device',get,'heatingThermostatSetpointCapabilitiesMin',nil,true}
getProps.heatingThermostatSetpointFuture={'device',get,'heatingThermostatSetpointFuture',nil,true}
getProps.heatingThermostatSetpointStep={'device',get,'heatingThermostatSetpointStep',nil,true}
getProps.thermostatFanMode={'device',get,'thermostatFanMode',nil,true}
getProps.thermostatFanOff={'device',get,'thermostatFanOff',nil,true}
getProps.thermostatMode={'device',get,'thermostatMode',nil,true}
getProps.thermostatModeFuture={'device',get,'thermostatModeFuture',nil,true}
getProps.on={'device',call,'turnOn',mapF,true}
getProps.off={'device',call,'turnOff',mapF,true}
getProps.play={'device',call,'play',mapF,nil}
getProps.pause={'device',call,'pause',mapF,nil}
getProps.open={'device',call,'open',mapF,true}
getProps.close={'device',call,'close',mapF,true}
getProps.stop={'device',call,'stop',mapF,true}
getProps.secure={'device',call,'secure',mapF,false}
getProps.unsecure={'device',call,'unsecure',mapF,false}
getProps.isSecure={'device',on,'secured',mapAnd,true}
getProps.isUnsecure={'device',off,'secured',mapOr,true}
getProps.name={'device',function(id) return fibaro.getName(id) end,nil,nil,false}
getProps.partition={'alarm',function(id) return partition(id) end,nil,nil,false}
getProps.HTname={'device',function(id) return ER.reverseVar(id) end,nil,nil,false}
getProps.roomName={'device',function(id) return fibaro.getRoomNameByDeviceID(id) end,nil,nil,false}
getProps.trigger={'device',function() return true end,'value',nil,true}
getProps.time={'device',get,'time',nil,true}
getProps.manual={'device',function(id) return quickApp:lastManual(id) end,'value',nil,true}
getProps.start={'device',function(id) return fibaro.scene(\"execute\",{id}) end,\"\",mapF,false}
getProps.kill={'device',function(id) return fibaro.scene(\"kill\",{id}) end,\"\",mapF,false}
getProps.toggle={'device',toggle,'value',mapF,true}
getProps.wake={'device',call,'wakeUpDeadDevice',mapF,true}
getProps.removeSchedule={'device',call,'removeSchedule',mapF,true}
getProps.retryScheduleSynchronization={'device',call,'retryScheduleSynchronization',mapF,true}
getProps.setAllSchedules={'device',call,'setAllSchedules',mapF,true}
getProps.levelIncrease={'device',call,'startLevelIncrease',mapF,nil}
getProps.levelDecrease={'device',call,'startLevelDecrease',mapF,nil}
getProps.levelStop={'device',call,'stopLevelChange',mapF,nil}
getProps.type={'device',function(id) return ER.getDeviceInfo(id).type end,'type',mapF,nil}

-- setProps helpers
local function set(id,cmd,val) fibaro.call(id,cmd,val); return val end
local function set2(id,cmd,val)
  assert(type(val)=='table' and #val>=3,\"setColor expects a table with 3 values\")
  fibaro.call(id,cmd,table.unpack(val)); 
  return val 
end
local function setProfile(id,_,val) if val then fibaro.profile(\"activateProfile\",id) end return val end
local function setState(id,_,val) fibaro.call(id,\"updateProperty\",\"state\",val); return val end
local function setProps(id,cmd,val) fibaro.call(id,\"updateProperty\",cmd,val); return val end
local function dim2(id,_,val) ER.utilities.dimLight(id,table.unpack(val)) end
local function pushMsg(id,cmd,val) fibaro.alert(fibaro._pushMethod,{id},val); return val end
local function setAlarm(id,cmd,val) arm(id,val and 'arm' or 'disarm') return val end
helpers.set, helpers.set2, helpers.setProfile, helpers.setState, helpers.setProps, helpers.dim2, helpers.pushMsg = set, set2, setProfile, setState, setProps, dim2, pushMsg

local setProps = {}
ER.setProps = setProps
-- { function to get prop, property name }
setProps.R={set,'setR'} -- Don't think the RGBs are valid anymore...
setProps.G={set,'setG'}
setProps.B={set,'setB'}
setProps.W={set,'setW'}
setProps.value={set,'setValue'}
setProps.state={setState,'setState'}
setProps.prop={function(id,_,val) fibaro.call(id,\"updateProperty\",table.unpack(val)) end,'upDateProp'}

setProps.armed={setAlarm,'setAlarm'}

setProps.profile={setProfile,'setProfile'}
setProps.time={set,'setTime'}
setProps.power={set,'setPower'}
setProps.targetLevel={set,'setTargetLevel'}
setProps.interval={set,'setInterval'}
setProps.mode={set,'setMode'}
setProps.setpointMode={set,'setSetpointMode'}
setProps.defaultPartyTime={set,'setDefaultPartyTime'}
setProps.scheduleState={set,'setScheduleState'}
setProps.color={set2,'setColor'}
setProps.volume={set,'setVolume'}
setProps.position={set,'setPosition'}
setProps.positions={setProps,'availablePositions'}
setProps.mute={set,'setMute'}
setProps.thermostatSetpoint={set2,'setThermostatSetpoint'}
setProps.thermostatMode={set,'setThermostatMode'}
setProps.heatingThermostatSetpoint={set,'setHeatingThermostatSetpoint'}
setProps.coolingThermostatSetpoint={set,'setCoolingThermostatSetpoint'}
setProps.thermostatFanMode={set,'setThermostatFanMode'}
setProps.schedule={set2,'setSchedule'}
setProps.dim={dim2,'dim'}
fibaro._pushMethod = 'push'
setProps.msg={pushMsg,\"push\"}
setProps.defemail={set,'sendDefinedEmailNotification'}
setProps.btn={set,'pressButton'} -- ToDo: click button on QA?
setProps.email={function(id,_,val) local _,_ = val:match(\"(.-):(.*)\"); fibaro.alert('email',{id},val) return val end,\"\"}
setProps.start={function(id,_,val) 
  if type(val)=='table' and val.type then 
    ER.sourceTrigger:postRemote(id,val) return true
  else 
    fibaro.scene(\"execute\",{id}) return true
  end
end,\"\"}
setProps.sim_pressed={function(id,_,val) ER.sourceTrigger:post({type='device',id=id,property='centralSceneEvent',value={keyId=val,keyAttribute='Pressed'}}) end,\"push\"} -- For simulated button presses
setProps.sim_helddown={function(id,_,val) ER.sourceTrigger:post({type='device',id=id,property='centralSceneEvent',value={keyId=val,keyAttribute='HeldDown'}}) end,\"push\"}
setProps.sim_released={function(id,_,val) ER.sourceTrigger:post({type='device',id=id,property='centralSceneEvent',value={keyId=val,keyAttribute='Released'}}) end,\"push\"}

local filters = ER.propFilters
ER.propFilterTriggers = {}
local function NB(x) if type(x)=='number' then return x~=0 and true or false else return x end end
local function mapAnd(l) for _,v in ipairs(l) do if not NB(v) then return false end end return true end
local function mapOr(l) for _,v in ipairs(l) do if NB(v) then return true end end return false end
function filters.average(list) local s = 0; for _,v in ipairs(list) do s=s+BN(v) end return s/#list end
function filters.sum(list) local s = 0; for _,v in ipairs(list) do s=s+BN(v) end return s end
function filters.allFalse(list) return not mapOr(list) end
function filters.someFalse(list) return not mapAnd(list)  end
function filters.allTrue(list) return mapAnd(list) end
function filters.someTrue(list) return mapOr(list)  end
function filters.mostlyTrue(list) local s = 0; for _,v in ipairs(list) do s=s+(NB(v) and 1 or 0) end return s>#list/2 end
function filters.mostlyFalse(list) local s = 0; for _,v in ipairs(list) do s=s+(NB(v) and 0 or 1) end return s>#list/2 end
function filters.bin(list) local s={}; for _,v in ipairs(list) do s[#s+1]=NB(v) and 1 or 0 end return s end
function filters.id(list,ev) return ev and next(ev) and ev.id or list end -- If we called from rule trigger collector we return whole list
local function collect(t,m)
  if type(t)=='table' then
    for _,v in pairs(t) do collect(v,m) end
  else m[t]=true end
end
function filters.leaf(tree)
  local map,res = {},{}
  collect(tree,map)
  for e,_ in pairs(map) do res[#res+1]=e end
  return res 
end

----------------------------------------- PropObject handling --------------------------------------

PropObject = {}
class 'PropObject'
function PropObject:__init()
  self._isPropObject = true
  self.__str=\"PObj:\"..tostring({}):match(\"(%d.*)\")
end
function PropObject:isProp(prop) return self.getProp[prop] or self.setProp[prop] end
function PropObject:isTrigger(prop) return self.trigger[prop] end
function PropObject:hasReduce(prop) return self.map[prop] end
function PropObject:_setProp(prop,value)
  local sp = self.setProp[prop]
  if not sp then return nil,\"Unknown property: \"..tostring(prop) end
  sp(self,prop,value)
  return true
end
function PropObject:_getProp(prop,env)
  local gp = self.getProp[prop]
  if not gp then return nil,\"Unknown property: \"..tostring(prop) end
  return gp(self,prop)
end
function PropObject:getTrigger(id,prop)
  local t = self.trigger[prop]
  return t and type(t) == \"func\"..\"tion\" and t(self,id,prop) or type(t) == 'table' and t or nil
end
function PropObject:__tostring() return self.__str end

ER.PropObject = PropObject
function ER.definePropClass(name)
  class(name)(PropObject)
  local cl = _G[name]
  cl.getProp,cl.setProp,cl.trigger,cl.map={},{},{},{}
end

NumberPropObject = {}
class 'NumberPropObject'(PropObject)
function NumberPropObject:__init(num)  PropObject.__init(self) self.id = num end
function NumberPropObject:_getProp(prop,env)
  local gp = getProps[prop]
  if not gp then env.error(\"Unknown property: \"..tostring(prop)) os.exit() end
  local fun = gp[2]
  local prop = gp[3]
  local value = fun(self.id,prop,env.trigger)
  return value
end
function NumberPropObject:_setProp(prop,value)
  local sp = setProps[prop]
  if not sp then return nil,\"Unknown property: \"..tostring(prop) end
  local fun = sp[1]
  local cmd = sp[2]
  local r = fun(self.id,cmd,value)
  return true
end
function NumberPropObject:hasReduce(prop) return  (getProps[prop] or {})[4] end
function NumberPropObject:isProp(prop) return getProps[prop] or setProps[prop] end
function NumberPropObject:isTrigger(prop) return (getProps[prop] or {})[5] end
function NumberPropObject:getTrigger(id, prop) return {type='device', id = self.id, property =  getProps[prop][3]} end

local numObjects = {}
local function preResolvePropObject(id,obj) numObjects[id] = obj end

local function resolvePropObject(obj)
  if type(obj) == 'userdata' and obj._isPropObject then return obj
  elseif type(obj) == 'number' then 
    local po = numObjects[obj] or NumberPropObject(obj)
    numObjects[obj] = po
    return po
  else return nil end
end

local function dumpTable(obj)
  local r = {} for k,v in pairs(obj) do r[#r+1]=string.format(\"%s=%s\",tostring(k),tostring(v)) end
  return \"{\"..table.concat(r,\",\")..\"}\"
end

local function executeGetProp(obj,prop,env)
  if type(obj) == 'table' then
    if next(obj) == nil then return env.error(\"Expected non-empty table, got empty table\") end
    if ER.propFilters[prop] then
      local filter = ER.propFilters[prop]
      if not filter then env.error(\"Unknown filter: \"..tostring(prop)) os.exit() end
      return filter(obj, env.trigger)
    end
    if #obj == 0 then return env.error(\"Expected non-empty table, got empty table\") end

    local r,fo = {},nil
    for k,v in pairs(obj) do
      local v0 = resolvePropObject(v)
      fo = fo or v0
      if not v0 then return env.error(\"Not a prop object: \"..tostring(v)) end
      r[k] = v0
    end
    local red,res = fo:hasReduce(prop)
    if red then 
      res = red(function(v) 
        if not v then return env.error(\"Not a proper table: \"..dumpTable(obj)) 
        else return v:_getProp(prop,env) end
      end,r)
    else res = table.map(function(v) return v:_getProp(prop,env) end,r) end
    return res
  else
    if ER.propFilters[prop] then return ER.propFilters[prop](obj, env.trigger) end
    local v = resolvePropObject(obj)
    if not v then return env.error(\"Not a prop object: \"..tostring(obj)) end
    return v:_getProp(prop,env)
  end
end

local function executeSetProp(obj,prop,value,env)
  if type(obj) == 'table' then
    if #obj == 0 then 
      if next(obj) ~= nil then 
        return env.error(\"Expected array, got key-value table: \"..dumpTable(obj)) 
      end
      return env.error(\"Expected non-empty table, got empty table\") 
    end
    for _,v in pairs(obj) do
      local v0 = resolvePropObject(v)
      if not v0 then return env.error(\"Not a prop object: \"..tostring(v)) end
      v0:_setProp(prop,value,env)
    end
  else
    local v = resolvePropObject(obj)
    if not v then return env.error(\"Not a prop object: \"..tostring(obj)) end
    v:_setProp(prop,value,env)
  end
end

ER.executeGetProp = executeGetProp
ER.executeSetProp = executeSetProp
ER.resolvePropObject = resolvePropObject
ER.preResolvePropObject = preResolvePropObject","isMain":false,"isOpen":false}],"initialInterfaces":[],"initialProperties":{"apiVersion":"1.3","buildNumber":1,"deviceRole":"Other","quickAppUuid":"f1e8b22e2-3c4b-4d5a-9f6a-7b8c2360e1f2c","quickAppVariables":[],"supportedDeviceRoles":["Other"],"typeTemplateInitialized":true,"uiCallbacks":[],"uiView":[{"type":"horizontal","components":[{"type":"label","name":"info","style":{"weight":"1.0"},"text":"EventRunnner 6","visible":true}],"style":{"weight":"1.0"}}],"useEmbededView":true,"useUiView":true,"userDescription":"","viewLayout":{"$jason":{"body":{"header":{"style":{"height":"0"},"title":"quickApp_device_52"},"sections":{"items":[{"type":"vertical","components":[{"type":"label","name":"info","style":{"weight":"1.2"},"text":"EventRunnner 6","visible":true},{"type":"space","style":{"weight":"0.5"}}],"style":{"weight":"1.2"}}]}},"head":{"title":"quickApp_device_52"}}}}}